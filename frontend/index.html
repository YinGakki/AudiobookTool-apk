<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¯­éŸ³å·¥ä½œå®¤ Pro (æœ‰å£°ä¹¦åˆ¶ä½œ)</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="main-layout">
    <!-- Global Header -->
    <header class="global-header">
        <h1 class="app-title">AI è¯­éŸ³å·¥ä½œå®¤ Pro</h1>
        <div class="status-group">
            <p id="global-status">æ¬¢è¿ä½¿ç”¨ï¼è¯·åœ¨å·¦ä¾§é€‰æ‹©æˆ–ä¸Šä¼ å°è¯´ä»¥å¼€å§‹ã€‚</p>
            <div id="backend-log-display" class="backend-info-display hidden-log-display">
                <p>ç³»ç»Ÿæ—¥å¿—åŠ è½½ä¸­...</p>
            </div>
            <div id="global-progress" class="progress-bar"><div class="progress-bar-inner"></div></div>
        </div>
        <div class="config-group inline-group"">
            <button id="toggleLogBtn" class="btn-settings" title="æ˜¾ç¤ºå®æ—¶æ—¥å¿—">ğŸ—’ï¸</button>
            <label style="font-size: 0.9rem; vertical-align: bottom;">è®¾ç½®</label>
            <button id="settingsBtn" class="btn-settings" title="å…¨å±€è®¾ç½®">âš™ï¸</button>
        </div>
        
    </header>

    <!-- 4-Column Workspace -->
    <main class="main-container spa-layout">
        <!-- Column 1: Novel Management & Processing -->
		<div class="content-column">
			<h2 class="column-header">å°è¯´ç®¡ç†ä¸å¤„ç†</h2>
			
            <div class="column-controls-panel">
                <div class="btn-group-row" disabled style="flex-grow: 1;">
                    <label for="llmModelSelector">é€‰æ‹©å¤„ç†æ¨¡å‹</label>
                    <select id="llmModelSelector">
                        <option value="gemini-1.5-flash">Gemini Flash</option>
                        <option value="qwen-plus">é€šä¹‰åƒé—® Plus</option>
                    </select>
					<button id="uploadTxtLabelBtn" class="btn" style="flex-grow: 1;">ä¸Šä¼ å°è¯´</button>
					<input type="file" id="novelTxtFile" accept=".txt" style="display: none;">
				</div>
            </div>
			<div class="config-group inline-group">
				<label for="novelSelector">é€‰æ‹©å°è¯´é¡¹ç›®</label>
                <div class="btn-group" style="display: flex; gap: 0.5rem; width: 100%;">
				    <select id="novelSelector" style="flex-grow: 1;"><option>æ­£åœ¨åŠ è½½...</option></select>
                    <button id="deleteNovelBtn" class="btn btn-danger" title="åˆ é™¤å½“å‰é€‰ä¸­çš„å°è¯´é¡¹ç›®" disabled style="padding: 0.5rem; flex-shrink: 0;">ğŸ—‘ï¸</button>
                </div>
			</div>
			<div class="column-controls-panel" style="padding-top: 0; border-top: 1px solid var(--border-color);">
				<div class="btn-group-row">
					<button id="processTxtBtn" class="btn" disabled style="flex-grow: 1;">å¤„ç†æ–‡æœ¬</button>
					<button id="processAllBtn" class="btn btn-primary" disabled style="flex-grow: 1;">ç”Ÿæˆè¯­éŸ³</button>
					<button id="downloadSpliceBtn" class="btn" disabled style="flex-grow: 1;">ä¸‹è½½å£°éŸ³</button>
					<button id="manageReplaceDictBtn" class="btn" disabled style="flex-grow: 1;">åŒéŸ³è¯ç®¡ç†</button>
				</div>
				<hr style="border: none; border-top: 1px solid var(--border-color); margin: 0; padding-top: var(--spacing-sm);">
			</div>
			<hr style="border: none; border-top: 1px solid var(--border-color); margin: 1rem 0;">
			
			<!-- NEW: This wrapper will contain everything that scrolls -->
			<div id="col1-content-wrapper" class="scrollable-content">
				<!-- This is now the fixed controls container -->
				<div class="chapter-controls">
					<div class="config-group">
						<label>ç« èŠ‚åˆ—è¡¨ (å¯å¤šé€‰)</label>
						<div class="controls" style="display: flex; gap: 0.5rem;">
							<button id="selectAllChaptersBtn" class="btn">å…¨é€‰</button>
							<button id="selectNoneChaptersBtn" class="btn">å…¨ä¸é€‰</button>
							<button id="filterBtn" class="btn" style="margin-left: auto;">è¿‡æ»¤ ğŸ”</button>
							<button id="rangeSelectBtn" class="btn" title="ç‚¹å‡»å¼€å¯æ¨¡å¼ï¼šå…ˆç‚¹èµ·å§‹ç« ï¼Œå†ç‚¹ç»“æŸç« ">èŒƒå›´é€‰æ‹© â†”ï¸</button>
						</div>
					</div>
				</div>

				<!-- This wrapper will now scroll -->
				<div id="chapter-list-wrapper">
					<ul id="chapter-list" class="info-list">
						<p class="placeholder-text">è¯·å…ˆé€‰æ‹©æˆ–ä¸Šä¼ å°è¯´</p>
					</ul>
				</div>
			</div>
			<div class="column-resizer" data-col="1"></div> <!-- æ·»åŠ  Resizer -->
		</div>

        <!-- Column 2: Character-Timbre Configuration -->
		<div class="content-column">
			<h2 class="column-header">è§’è‰²-éŸ³è‰²é…ç½®åŒº</h2>
			
            <div class="column-controls-panel">
                <div class="btn-group-row">
                    <button id="manageCharactersBtn" class="btn" disabled style="flex-grow: 1;">è§’è‰²ç®¡ç†</button>
                    <button id="detectTimbreConflictsBtn" class="btn" disabled style="flex-grow: 1;">æ£€æµ‹éŸ³è‰²å†²çª</button>
                    <button id="autoAssignTimbreBtn" class="btn btn-primary" disabled style="flex-grow: 1;">è‡ªåŠ¨åˆ†é…éŸ³è‰²</button>
                </div>
            </div>

			<div id="character-list" class="scrollable-content info-list">
				 <p class="placeholder-text">è¯·åœ¨å·¦ä¾§é€‰æ‹©ç« èŠ‚</p>
			</div>
			<div class="column-resizer" data-col="2"></div> <!-- æ·»åŠ  Resizer -->
		</div>

		<!-- Column 3: Timbre Library -->
		<div class="content-column">
			<h2 class="column-header">
				<span>éŸ³è‰²åº“</span>
			</h2>
            <div class="column-controls-panel">
                <div class="btn-group-row" style="display: flex; flex-wrap: wrap; gap: 1rem 1.5rem;">
                    <button id="manageTimbresBtn" class="btn" style="flex-grow: 1;">éŸ³è‰²ç®¡ç†</button>
                    <button id="manageEmoPromptsBtn" class="btn" style="flex-grow: 1;">æƒ…ç»ªå‚è€ƒéŸ³é¢‘ç®¡ç†</button>
                    <button id="uploadTimbreLabelBtn" class="btn btn-primary" style="flex-grow: 1;">æ·»åŠ éŸ³è‰²</button>
                    <input type="file" id="timbreFile" accept="audio/*" style="display: none;">
                    <select id="categoryFilter" style="font-size: 0.9rem; flex-grow: 1;">
						<!-- JSåŠ¨æ€ç”Ÿæˆ -->
					</select>
                </div>
            </div>
			<div id="timbre-list" class="scrollable-content info-list">
				<p class="placeholder-text">æ­£åœ¨åŠ è½½éŸ³è‰²...</p>
			</div>
			<div class="column-resizer" data-col="3"></div> <!-- æ·»åŠ  Resizer -->
		</div>
		
		<!-- Column 4: Content Editor -->
		<div class="content-column">
			<h2 id="content-title" class="column-header">
				<span id="editor-title-text">å†…å®¹ç¼–è¾‘åŒº</span>
			</h2>
            <div id="editor-controls-panel" class="column-controls-panel" style="display: none;">
                <div class="btn-group-row">
                    <!-- æŒ‰é’®å…¨éƒ¨å¹¶å…¥ä¸€è¡Œ -->
					<button id="toggleProofreadModeBtn" class="btn" style="flex-grow: 1;">ğŸ“ æ ¡å¯¹æ¨¡å¼</button> 
                    <button id="viewSourceBtn" class="btn" disabled style="flex-grow: 1;">ğŸ“„ æŸ¥çœ‹åŸæ–‡</button>
				    <button id="chapterPlayStopBtn" class="btn" disabled style="flex-grow: 1;">â–¶ æ’­æ”¾ç« èŠ‚</button>
                    <div style="width: 1px; background-color: var(--divider-color); margin: 0 var(--spacing-xs);"></div> <!-- æ·»åŠ åˆ†éš”ç¬¦ -->
                    <button id="addRowStartBtn" class="btn" style="flex-grow: 1;">æ·»åŠ é¦–è¡Œ</button>
					<button id="saveChapterBtn" class="btn btn-primary" disabled style="flex-grow: 2;">ä¿å­˜ä¿®æ”¹</button>
                </div>
            </div>
			<div id="editor-view" class="scrollable-content">
				<p class="placeholder-text">è¯·åœ¨å·¦ä¾§é€‰æ‹©ä¸€ä¸ªå·²å¤„ç†ç« èŠ‚ä»¥æ˜¾ç¤ºå†…å®¹ã€‚</p>
				<div id="raw-text-view" style="display: none;">
					<h4 id="raw-text-title" style="margin-top: 0;"></h4>
					<pre id="raw-text-content" class="scrollable-content" style="white-space: pre-wrap; word-wrap: break-word; font-family: 'Noto Sans SC', sans-serif; height: calc(100% - 30px); background-color: #f8f9fa; padding: 1rem; border-radius: 4px;"></pre>
				</div>
				<table class="content-table" style="display:none; align-items: center;">
					<thead>
						<tr>
							<th style="width: 1%;">å¢åˆ </th>
							<th style="width: 1%;">#</th>
							<th style="width: 10%;">è§’è‰²</th>
							<th style="width: 12%;">éŸ³è‰²</th>
							<th>å†…å®¹</th>
							<th style="width: 5%;">æƒ…ç»ª</th> 
							<th style="width: 1%;">ç”Ÿæˆ/æ’­æ”¾</th>
						</tr>
					</thead>
					<tbody id="content-table-body"></tbody>
				</table>
			</div>
			<div id="batch-view" class="scrollable-content" style="display: none; align-items: center; justify-content: center;">
				 <p class="placeholder-text" id="batch-view-message" style="font-size: 1.1rem;"></p>
			</div>
		</div>
    </main>
</div>

<div id="sourceTextModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 800px; height: 80vh; display: flex; flex-direction: column;">
        <h3 id="sourceTextModalTitle" class="modal-header">ç« èŠ‚åŸæ–‡</h3>
        <div id="sourceTextModalBody" class="scrollable-content" style="flex-grow: 1; background-color: #f8f9fa; padding: 1rem; border-radius: var(--border-radius); white-space: pre-wrap; word-wrap: break-word; font-family: 'Noto Sans SC', sans-serif;">
            <!-- åŸæ–‡å†…å®¹å°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
            <p class="placeholder-text">æ­£åœ¨åŠ è½½åŸæ–‡...</p>
        </div>
        <div class="modal-actions" style="margin-top: 1rem;">
            <button id="sourceTextModalCloseBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>

<!-- Modals -->
<div id="timbreUploadModal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-header">ä¸Šä¼ æ–°éŸ³è‰²</h3>
        <div class="input-group"><label for="newTimbreName">éŸ³è‰²åç§°</label><input type="text" id="newTimbreName"></div>
		<div class="input-group">
			<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
				<label for="newTimbreText" style="margin: 0;">å‚è€ƒæ–‡æœ¬</label>
                <div class="btn-group" style="display: flex; gap: 0.5rem; align-items: center;">
				    <button id="previewUploadBtn" class="audio-player-btn playable" title="è¯•å¬ä¸Šä¼ çš„éŸ³é¢‘" disabled style="width: 28px; height: 28px;">â–¶</button>
					<!-- é»˜è®¤éšè—è‡ªåŠ¨è¯†åˆ«æŒ‰é’® -->
					<button id="transcribeBtn" class="btn" disabled style="display: none;">è‡ªåŠ¨è¯†åˆ«</button>
                </div>
			</div>
			<textarea id="newTimbreText" rows="4"></textarea>
		</div>
		<div class="input-group">
			<label for="uploadTimbreCategory">é€‰æ‹©åˆ†ç±» (å¯é€‰)</label>
			<select id="uploadTimbreCategory">
				<option value="">-- ä¸å½’ç±» --</option>
			</select>
		</div>
        <div class="input-group"> <!-- å°†å…¶åŒ…è£…åœ¨ input-group ä¸­ï¼Œæ ·å¼æ›´ä¸€è‡´ -->
            <label for="normalizeVolume" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; margin-bottom: 0;">
                <span>éŸ³é‡æ ‡å‡†åŒ–</span>
                <input type="checkbox" id="normalizeVolume" checked style="width: auto; height: auto; margin-left: 0.5rem;">
            </label>
        </div>
        <div class="modal-actions"><button id="cancelUploadBtn" class="btn">å–æ¶ˆ</button><button id="confirmUploadBtn" class="btn btn-primary">ç¡®è®¤</button></div>
    </div>
</div>
<div id="profileModal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="profileModalTitle" class="modal-header">è§’è‰²ç®€ä»‹</h3>
        <div id="profileModalBody">æ­£åœ¨åŠ è½½...</div>
        <div class="modal-actions"><button id="profileModalCloseBtn" class="btn">å…³é—­</button></div>
    </div>
</div><div id="globalSettingsModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 700px; padding: 0;">
        <div class="modal-header" style="padding: 1.5rem 2rem 1rem 2rem; border-bottom: 1px solid var(--border-color);">
            <h3 style="margin: 0;">å…¨å±€è®¾ç½®</h3>
        </div>

        <div class="settings-container">
            <!-- æ ‡ç­¾é¡µå¯¼èˆª -->
            <nav class="settings-tabs">
                <button class="tab-link active" data-tab="tab-general">é€šç”¨è®¾ç½®</button>
                <button class="tab-link" data-tab="tab-models">LLMæ¨¡å‹é…ç½®</button>
				<button class="tab-link" data-tab="tab-tts">TTSæ¨¡å‹é…ç½®</button>
                <button class="tab-link" data-tab="tab-audio-export">éŸ³é¢‘å¯¼å‡ºè®¾ç½®</button>
            </nav>

            <!-- å†…å®¹é¢æ¿ -->
            <div class="settings-content">
                <!-- é€šç”¨è®¾ç½®é¢æ¿ -->
                <div id="tab-general" class="tab-content active">
                    <fieldset style="border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;">
                        <legend style="font-weight: 500;">é»˜è®¤LLMæ¨¡å‹</legend>
                        <div class="config-group">
                            <label for="settingsDefaultModel">å¤„ç†æ–°ç« èŠ‚æ—¶é»˜è®¤ä½¿ç”¨çš„æ¨¡å‹</label>
                            <select id="settingsDefaultModel">
                                <!-- é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                            </select>
                        </div>
                    </fieldset>
					<fieldset style="border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;">
						<legend style="font-weight: 500;">é»˜è®¤TTSæ¨¡å‹</legend>
						<div class="config-group">
							<label for="settingsDefaultTtsModel">ç”Ÿæˆè¯­éŸ³æ—¶é»˜è®¤ä½¿ç”¨çš„ TTSæ¨¡å‹</label>
							<select id="settingsDefaultTtsModel">
								<!-- é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
							</select>
						</div>
					</fieldset>
                    <fieldset style="border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem;">
                        <legend style="font-weight: 500;">ä»£ç†æœåŠ¡å™¨ (Proxy)</legend>
                        <div class="config-group inline-group" style="margin-bottom: 1.5rem;">
                            <label for="settingsProxyEnabled">å¯ç”¨ä»£ç†</label>
                            <input type="checkbox" id="settingsProxyEnabled" style="width: auto; height: auto;">
                        </div>
                        <div id="proxy-details-group" style="display: none;">
                            <div class="config-group">
                                <label for="settingsProxyProtocol">åè®®</label>
                                <select id="settingsProxyProtocol">
                                    <option value="socks5h">SOCKS5 (socks5h)</option>
                                    <option value="http">HTTP</option>
                                    <option value="https">HTTPS</option>
                                </select>
                            </div>
                            <div class="config-group">
                                <label for="settingsProxyAddress">åœ°å€</label>
                                <input type="text" id="settingsProxyAddress" placeholder="e.g., 127.0.0.1">
                            </div>
                            <div class="config-group">
                                <label for="settingsProxyPort">ç«¯å£</label>
                                <input type="text" id="settingsProxyPort" placeholder="e.g., 1080">
                            </div>
                        </div>
                    </fieldset>
                </div>

                <!-- æ¨¡å‹é…ç½®é¢æ¿ -->
                <div id="tab-models" class="tab-content">
                    <p style="font-size: 0.85rem; color: var(--text-color-secondary); margin-top: 0; margin-bottom: 1.5rem;">
                        åœ¨æ­¤é…ç½®ç”¨äºå¤„ç†ç« èŠ‚çš„AIæ¨¡å‹çš„API Keyå’Œå‚æ•°ã€‚é…ç½®å°†ä¿å­˜åœ¨æœåŠ¡å™¨ã€‚
                    </p>
                    <div id="llmSettingsForm">
                        <p class="placeholder-text">æ­£åœ¨åŠ è½½é…ç½®...</p>
                    </div>
                </div>
				
				<div id="tab-tts" class="tab-content">
					<p style="font-size: 0.85rem; color: var(--text-color-secondary); margin-top: 0; margin-bottom: 1.5rem;">
						åœ¨æ­¤é…ç½®ç”¨äºç”Ÿæˆè¯­éŸ³çš„TTSï¼ˆæ–‡æœ¬è½¬è¯­éŸ³ï¼‰æœåŠ¡çš„åœ°å€å’Œæ˜¾ç¤ºåç§°ã€‚
					</p>
					<div id="ttsSettingsForm">
						<p class="placeholder-text">æ­£åœ¨åŠ è½½é…ç½®...</p>
					</div>
				</div>

                <!-- éŸ³é¢‘å¯¼å‡ºé¢æ¿ -->
                <div id="tab-audio-export" class="tab-content">
                    <div class="input-group">
                        <label for="exportFormat">éŸ³é¢‘æ ¼å¼</label>
                        <select id="exportFormat">
                            <option value="mp3">MP3</option>
                            <option value="wav">WAV</option>
                            <option value="m4a">M4A (AAC)</option>
                            <option value="ogg">OGG</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="exportQuality">éŸ³é¢‘è´¨é‡</label>
                        <select id="exportQuality"></select>
                    </div>
                </div>
            </div>
        </div>

        <div class="modal-actions" style="padding: 1rem 2rem 1.5rem 2rem; border-top: 1px solid var(--border-color); background-color: #f8f9fa;">
            <button id="globalSettingsCloseBtn" class="btn">å…³é—­</button>
            <button id="globalSettingsSaveBtn" class="btn btn-primary">ä¿å­˜å…¨éƒ¨è®¾ç½®</button>
        </div>
    </div>
</div>
<div id="filterModal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-header">ç« èŠ‚è¿‡æ»¤å™¨</h3>
        <div class="filter-options">
            <div class="filter-group">
                <fieldset>
                    <legend>æŒ‰çŠ¶æ€è¿‡æ»¤</legend>
                    <div class="radio-group" style="display: flex; flex-wrap: wrap; gap: 1rem 1.5rem;">
                        <label><input type="radio" name="filterStatus" value="all" checked> æ˜¾ç¤ºå…¨éƒ¨</label>
                        <label><input type="radio" name="filterStatus" value="unprocessed"> åªæ˜¾ç¤ºæœªå¤„ç†</label>
                        <label><input type="radio" name="filterStatus" value="processed"> åªæ˜¾ç¤ºå·²å¤„ç†æ–‡æœ¬ (ğŸ“„)</label>
                        <label><input type="radio" name="filterStatus" value="spliced"> åªæ˜¾ç¤ºå·²ç”Ÿæˆè¯­éŸ³ (ğŸ”ˆ)</label>
                    </div>
                </fieldset>
            </div>
            <div class="filter-group">
                 <fieldset>
                    <legend>æŒ‰èŒƒå›´è¿‡æ»¤ (åŸºäºåˆ—è¡¨é¡ºåº)</legend>
                    <div class="range-group">
                        <label for="rangeStart">ä»ç¬¬</label>
                        <input type="number" id="rangeStart" min="1" placeholder="èµ·å§‹">
                        <label for="rangeEnd">åˆ°ç¬¬</label>
                        <input type="number" id="rangeEnd" min="1" placeholder="ç»“æŸ">
                        <span>ç« </span>
                    </div>
                </fieldset>
            </div>
        </div>
        <div class="modal-actions">
            <button id="clearFilterBtn" class="btn">æ¸…é™¤è¿‡æ»¤</button>
            <button id="applyFilterBtn" class="btn btn-primary">åº”ç”¨è¿‡æ»¤</button>
        </div>
    </div>
</div>
<div id="dialogueModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 600px;">
        <h3 id="dialogueModalTitle" class="modal-header">è§’è‰²å¯¹è¯é¢„è§ˆ</h3>
        <div id="dialogueModalBody" class="scrollable-content" style="max-height: 60vh; background-color: #f8f9fa; padding: 1rem; border-radius: var(--border-radius);">
            <!-- å¯¹è¯å†…å®¹å°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
        </div>
        <div class="modal-actions">
            <button id="dialogueModalCloseBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>

<!-- NEW CHORAL EFFECT MODAL START -->
<div id="choralModal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="choralModalTitle" class="modal-header">é€‰æ‹©å‚ä¸â€œå¤šäººåŒå£°â€çš„éŸ³è‰²</h3>
        <div id="choralTimbreList" class="scrollable-content" style="max-height: 50vh; border: 1px solid var(--border-color); padding: 0.5rem;">
            <!-- éŸ³è‰²åˆ—è¡¨å°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
        </div>
        <div class="modal-actions">
            <button id="cancelChoralBtn" class="btn">å–æ¶ˆ</button>
            <button id="confirmChoralBtn" class="btn btn-primary">ç¡®è®¤ç”Ÿæˆ</button>
        </div>
    </div>
</div>
<!-- NEW CHORAL EFFECT MODAL END -->

<div id="replaceDictModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 700px; display: flex; flex-direction: column; height: 80vh;">
        <h3 class="modal-header">å°è¯´ä¸“å±æ›¿æ¢è¯å…¸ (<span id="replaceDictNovelName"></span>)</h3>
        <div class="replace-dict-body" style="flex-grow: 1; display: flex; flex-direction: column; overflow: hidden;">
            <div class="input-group" style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                <input type="text" id="newOriginalWord" class="form-control" placeholder="åŸè¯ (ä¾‹å¦‚: è¡Œé•¿)" style="flex: 1;">
                <input type="text" id="newReplacementWord" class="form-control" placeholder="æ›¿æ¢ä¸º (ä¾‹å¦‚: hangé•¿)" style="flex: 1;">
                <input type="text" id="newDescription" class="form-control" placeholder="æè¿° (å¯é€‰)" style="flex: 1;">
                <button id="addReplaceRuleBtn" class="btn btn-primary" style="flex-shrink: 0;">æ·»åŠ è§„åˆ™</button>
            </div>
            <div class="search-group" style="margin-bottom: 1rem;">
                <input type="text" id="replaceRuleSearchInput" class="form-control" placeholder="æœç´¢è§„åˆ™..." style="width: 100%;">
            </div>
            <div id="replaceRulesList" class="scrollable-content info-list" style="flex-grow: 1; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem;">
                <!-- æ›¿æ¢è§„åˆ™åˆ—è¡¨å°†åŠ¨æ€åŠ è½½åˆ°è¿™é‡Œ -->
                <p class="placeholder-text">æš‚æ— æ›¿æ¢è§„åˆ™</p>
            </div>
        </div>
        <div class="modal-actions" style="margin-top: 1rem;">
            <button id="closeReplaceDictBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>

<div id="deleteNovelModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 500px;">
        <h3 class="modal-header" style="color: var(--danger-color);">ç¡®è®¤æ°¸ä¹…åˆ é™¤</h3>
        <p>æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤å°è¯´é¡¹ç›® <strong id="novelToDeleteName"></strong> çš„æ‰€æœ‰ç›¸å…³æ–‡ä»¶ï¼ŒåŒ…æ‹¬ç« èŠ‚ã€é…ç½®å’Œå·²ç”Ÿæˆçš„éŸ³é¢‘æ–‡ä»¶ã€‚</p>
        <p>æ­¤æ“ä½œ**ä¸å¯æ’¤é”€**ã€‚</p>
        <div class="input-group">
            <label for="deleteConfirmInput">è¯·è¾“å…¥â€œ<b style="user-select: none;">åˆ é™¤</b>â€ä»¥ç¡®è®¤ï¼š</label>
            <input type="text" id="deleteConfirmInput" placeholder="åˆ é™¤">
        </div>
        <div class="modal-actions">
            <button id="cancelDeleteBtn" class="btn">å–æ¶ˆ</button>
            <button id="confirmDeleteBtn" class="btn btn-danger" disabled>ç¡®è®¤åˆ é™¤</button>
        </div>
    </div>
</div>

<div id="charManageModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 800px; display: flex; flex-direction: column; height: 80vh;">
        <h3 class="modal-header">è§’è‰²ç®¡ç†</h3>
        <div style="display: flex; flex-grow: 1; gap: 1rem; overflow: hidden;">
            <!-- Left Panel: Character List -->
            <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid var(--border-color); border-radius: 4px;">
                <div style="padding: 0.5rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
						<input type="text" style="width: 100%;" id="charSearchInput" placeholder="æœç´¢è§’è‰²å...">
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                        <input type="text" id="newCharManageNameInput" placeholder="è¾“å…¥æ–°è§’è‰²å" style="flex-grow: 1;">
                        <button id="addCharManageBtn" class="btn btn-primary" style="flex-shrink: 0;">æ–°å¢è§’è‰²</button>
                    </div>
                </div>
                <div id="charManageList" class="scrollable-content" style="padding: 0.5rem;">
                    <!-- Character list will be populated here -->
                </div>
            </div>
            <!-- Right Panel: Merge Controls -->
            <div style="flex: 1; display: flex; flex-direction: column; gap: 1rem;">
                <h4>åˆå¹¶é€‰ä¸­çš„è§’è‰²</h4>
                <div class="input-group">
                    <label>1. ä»¥ä¸‹è§’è‰²å°†è¢«åˆå¹¶ (è‡³å°‘é€‰æ‹©2ä¸ª):</label>
                    <div id="charsToMerge" style="min-height: 100px; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; background-color: #f8f9fa;"></div>
                </div>
                <div class="input-group">
                    <label for="targetCharSelect">2. é€‰æ‹©ä¸€ä¸ªä½œä¸ºä¸»è§’è‰²å:</label>
                    <select id="targetCharSelect" disabled></select>
                </div>
                <button id="confirmMergeBtn" class="btn btn-primary" disabled style="margin-top: auto;">ç¡®è®¤åˆå¹¶</button>
            </div>
        </div>
        <div class="modal-actions" style="margin-top: 1rem;">
            <button id="closeCharManageBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>
<!-- +++ ç®¡ç†æƒ…ç»ªå‚è€ƒéŸ³é¢‘æ¨¡æ€æ¡† +++ -->
<div id="emoPromptsManageModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 600px; height: 70vh; display: flex; flex-direction: column;">
        <h3 class="modal-header">æƒ…ç»ªå‚è€ƒéŸ³é¢‘ç®¡ç†</h3>
        <div id="emo-prompts-list" class="scrollable-content info-list" style="flex-grow: 1; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem;">
            <p class="placeholder-text">æ­£åœ¨åŠ è½½...</p>
        </div>
        <div class="modal-actions" style="justify-content: space-between; margin-top: 1rem;">
            <button id="closeEmoPromptsManageBtn" class="btn">å…³é—­</button>
            <button id="uploadEmoPromptLabelBtn" class="btn btn-primary">ä¸Šä¼ æ–°éŸ³é¢‘</button>
            <input type="file" id="emoPromptFileInput" accept="audio/*" style="display: none;">
        </div>
    </div>
</div>

<!-- Fine-Tune Modal (è¡Œçº§å¾®è°ƒæ¨¡æ€æ¡†) -->
<div id="fineTuneModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 650px;">
        <h3 id="fineTuneModalTitle" class="modal-header">è¡Œçº§å¾®è°ƒä¸ç”Ÿæˆ</h3>
        <div class="modal-body" style="display: flex; flex-direction: column; gap: 1rem; padding: 1rem;">
            <div class="input-group">
                <label>å¯¹è¯å†…å®¹</label>
                <textarea id="fineTuneContent" rows="3" disabled style="color: var(--text-color-secondary);"></textarea>
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;">
                <!-- TTS æ¨¡å‹é€‰æ‹© -->
                <div class="config-group inline-group" style="flex: 1 1 200px;">
                    <label for="fineTuneTtsModelSelect">TTS æ¨¡å‹</label>
                    <select id="fineTuneTtsModelSelect"></select>
                </div>
                
                <!-- æ¨¡å¼é€‰æ‹© -->
                <div class="config-group inline-group" style="flex: 1 1 150px;">
                    <label for="fineTuneModeSelect">æ¨¡å¼</label>
                    <select id="fineTuneModeSelect">
                        <option value="zero_shot">æ­£å¸¸</option>
                        <option value="cross_lingual">ç²¾ç»†</option>
                        <option value="instruct">æŒ‡ä»¤</option>
                    </select>
                </div>

                <!-- æƒ…ç»ªå‚è€ƒéŸ³é¢‘ç»„ï¼ˆé»˜è®¤éšè—ï¼‰ -->
                <div id="fineTuneEmoPromptGroup" class="config-group inline-group" style="display: none; flex: 1 1 250px;">
                    <label for="fineTuneEmoPromptSelect">æƒ…ç»ªå‚è€ƒ</label>
                    <select id="fineTuneEmoPromptSelect" style="flex-grow: 1;"></select>
                    <label for="fineTuneEmoWeightInput" style="flex-shrink: 0; margin-left: 0.5rem;">æƒé‡</label>
                    <input type="number" id="fineTuneEmoWeightInput" min="0" max="10" step="1" value="5" style="width: 50px;">
                </div>
            </div>

            <!-- æŒ‡ä»¤è¾“å…¥æ¡†ï¼ˆé»˜è®¤éšè—ï¼‰ -->
            <div id="fineTuneInstructGroup" class="input-group" style="display: none;">
                <label for="fineTuneInstructInput">æŒ‡ä»¤æ–‡æœ¬</label>
                <input type="text" id="fineTuneInstructInput" placeholder="è¯·è¾“å…¥æŒ‡ä»¤">
            </div>

            <!-- ç”Ÿæˆå’Œç‰¹æ•ˆæŒ‰é’® -->
            <div class="modal-actions" style="margin-top: 1rem; justify-content: space-between; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                <div>
                    <button id="fineTuneGenerateBtn" class="btn btn-primary" disabled>ç”ŸæˆéŸ³é¢‘</button>
                    <button id="fineTunePlayBtn" class="btn btn-secondary" disabled>â–¶</button>
                </div>
                
                <div class="popover-container">
                    <button id="fineTuneEffectsBtn" class="btn btn-primary" disabled>ç‰¹æ•ˆ</button>
                    <div class="popover-content">
                        <ul class="effects-menu">
                            <li><button data-effect="reverb"><span>ğŸ”Š</span> å®¤å†…å›å£°</button></li>
                            <li><button data-effect="phone"><span>ğŸ“</span> é€šè¯</button></li>
                            <li><button data-effect="megaphone"><span>ğŸ“£</span> å–‡å­</button></li>
                            <li style="border-top: 1px solid var(--border-color); margin-top: 0.25rem; padding-top: 0.25rem;"><button data-effect="choral"><span>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦</span> å¤šäººåŒå£°</button></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-actions" style="border-top: 1px solid var(--border-color); padding-top: 1rem;">
            <button id="fineTuneCloseBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // === 1. STATE MANAGEMENT ===
    let state = {
        novelName: '', isTxtMode: false, txtChapters: [], selectedChapterPaths: [],
        characterMapping: {}, allTimbres: [], selectedCharacter: null, novelData: [],
        generatedFiles: {}, isProcessing: false, isProcessingCancelled: false,
		isTxtProcessing: false, isTxtProcessingCancelled: false, // 
        selectedLLM: 'gemini-2.5-flash',
        isRangeSelectMode: false, // æ˜¯å¦å¤„äºèŒƒå›´é€‰æ‹©æ¨¡å¼
        rangeStartCheckbox: null, // è®°å½•èŒƒå›´é€‰æ‹©çš„èµ·ç‚¹
		globalAudioPlayer: null, // ç”¨äºç« èŠ‚æ’­æ”¾
		simpleAudioPlayer: null, // ç”¨äºå•å¥å’ŒéŸ³è‰²è¯•å¬
		activeSimplePlayerButton: null, // è¿½è¸ªå½“å‰æ¿€æ´»çš„ç®€å•æ’­æ”¾æŒ‰é’®
        currentBlobURL: null, 
		allNovelsData: {}, 
		timbreDetails: {}, 
		fileToUpload: null,
        lastCheckedIndex: -1,
		globalConfig: {}, // stores the entire config from backend
        screenWakeLock: null, // 
		filter: {
			status: 'all', // 'all', 'processed', 'unprocessed'
			start: null,   // 1-based index
			end: null      // 1-based index
		},
        replaceDict: [],// å°è¯´ä¸“å±æ›¿æ¢è§„åˆ™
        allEmoPrompts: [], // ç¼“å­˜æ‰€æœ‰æƒ…ç»ªå‚è€ƒéŸ³é¢‘æ–‡ä»¶å
        allAvailableCharacters: [],
        chapterCharacterMap: {},   // æ¯ä¸ªç« èŠ‚å‡ºç°è¿‡çš„è§’è‰² {'ç« èŠ‚A': ['è§’è‰²1', 'è§’è‰²2'], ...}
        chapterOrderList: [],      // æ‰€æœ‰ç« èŠ‚çš„æœ‰åºæ ‡é¢˜åˆ—è¡¨ ['ç« èŠ‚1', 'ç« èŠ‚2', ...]
        timbreConflictCache: {},   // ç¼“å­˜æŸä¸ªéŸ³è‰²åœ¨ä¸å½“å‰é€‰ä¸­è§’è‰²ç›¸é‚»ç« èŠ‚ä¸­æ˜¯å¦è¢«ä½¿ç”¨è¿‡ {'éŸ³è‰²X': true/false}
		selectedEditorRowIndexes: [], // è·Ÿè¸ªå†…å®¹ç¼–è¾‘å™¨ä¸­å½“å‰é€‰ä¸­çš„è¡Œç´¢å¼•æ•°ç»„
		currentFineTuneRowIndex: -1, 
        isChapterDirty: false,
        currentFineTuneLineId: null,
		isProofreadMode: false,     //æ ¡å¯¹æ¨¡å¼å¼€å…³çŠ¶æ€
		chapterSourceText: '', 
		chapterSourceTextConsumedIndex: 0, 
        isDraggingModal: false,     // æ˜¯å¦æ­£åœ¨æ‹–æ‹½æ¨¡æ€æ¡†
        dragOffsetX: 0,             // é¼ æ ‡æŒ‰ä¸‹æ—¶ç›¸å¯¹äºæ¨¡æ€æ¡†å·¦ä¸Šè§’çš„Xåç§»
        dragOffsetY: 0,             // é¼ æ ‡æŒ‰ä¸‹æ—¶ç›¸å¯¹äºæ¨¡æ€æ¡†å·¦ä¸Šè§’çš„Yåç§»
        activeDraggableModal: null, // å½“å‰æ­£åœ¨æ‹–æ‹½çš„æ¨¡æ€æ¡†å†…å®¹å…ƒç´  (ä¾‹å¦‚ #sourceTextModal .modal-content)
        proofreadMatches: new Map(), // å­˜å‚¨æ¯æ¡è¯­å¥åœ¨åŸæ–‡ä¸­çš„æœ€ä½³åŒ¹é…ä¿¡æ¯
        proofreadOriginalFragments: [], // å­˜å‚¨åˆ‡å‰²åçš„åŸæ–‡ç‰‡æ®µåˆ—è¡¨
        isProofreadDataStale: false, // æ ¡å¯¹æ•°æ®æ˜¯å¦å·²è¿‡æœŸ		
        lineIdToDisplayFragmentsMap: new Map(),
    };
    const timbreColorClasses = ['timbre-color-1', 'timbre-color-2', 'timbre-color-3', 'timbre-color-4', 'timbre-color-5', 'timbre-color-6'];

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    // === 2. DOM ELEMENTS ===
    const dom = {
        novelSelector: document.getElementById('novelSelector'), novelTxtFile: document.getElementById('novelTxtFile'),
        chapterListEl: document.getElementById('chapter-list'), selectAllChaptersBtn: document.getElementById('selectAllChaptersBtn'),
        selectNoneChaptersBtn: document.getElementById('selectNoneChaptersBtn'), processTxtBtn: document.getElementById('processTxtBtn'),
        rangeSelectBtn: document.getElementById('rangeSelectBtn'), // ã€æ–°å¢ã€‘
        characterListEl: document.getElementById('character-list'),
        timbreListEl: document.getElementById('timbre-list'),
        uploadTimbreLabelBtn: document.getElementById('uploadTimbreLabelBtn'), timbreFile: document.getElementById('timbreFile'),
        editorView: document.getElementById('editor-view'),
        contentTable: document.querySelector('.content-table'), contentTableBody: document.getElementById('content-table-body'),
        batchView: document.getElementById('batch-view'), batchViewMessage: document.getElementById('batch-view-message'),
        globalStatus: document.getElementById('global-status'), globalProgress: document.getElementById('global-progress'),
        globalProgressBar: document.getElementById('global-progress').querySelector('.progress-bar-inner'),
        processAllBtn: document.getElementById('processAllBtn'), 
		audioPlayerModal: document.getElementById('audioPlayerModal'),
		playerModalTitle: document.getElementById('playerModalTitle'),
		playerPlayPauseBtn: document.getElementById('playerPlayPauseBtn'),
        backendLogDisplay: document.getElementById('backend-log-display'), // ã€æ–°å¢ã€‘
        toggleLogBtn: document.getElementById('toggleLogBtn'),
		playerProgressBar: document.getElementById('playerProgressBar'),
		playerCurrentTime: document.getElementById('playerCurrentTime'),
		playerTotalDuration: document.getElementById('playerTotalDuration'),
		playerModalCloseBtn: document.getElementById('playerModalCloseBtn'),
        downloadSpliceBtn: document.getElementById('downloadSpliceBtn'), 
        timbreUploadModal: document.getElementById('timbreUploadModal'), newTimbreNameInput: document.getElementById('newTimbreName'),
        newTimbreTextInput: document.getElementById('newTimbreText'), cancelUploadBtn: document.getElementById('cancelUploadBtn'),
		transcribeBtn: document.getElementById('transcribeBtn'),
        previewUploadBtn: document.getElementById('previewUploadBtn'),
        confirmUploadBtn: document.getElementById('confirmUploadBtn'), profileModal: document.getElementById('profileModal'),
        profileModalTitle: document.getElementById('profileModalTitle'), profileModalBody: document.getElementById('profileModalBody'),
        profileModalCloseBtn: document.getElementById('profileModalCloseBtn'),
        settingsBtn: document.getElementById('settingsBtn'),
        exportFormat: document.getElementById('exportFormat'),
        exportQuality: document.getElementById('exportQuality'),
		saveChapterBtn: document.getElementById('saveChapterBtn'),
		addRowStartBtn: document.getElementById('addRowStartBtn'),
		filterBtn: document.getElementById('filterBtn'),
		filterModal: document.getElementById('filterModal'),
		applyFilterBtn: document.getElementById('applyFilterBtn'),
		clearFilterBtn: document.getElementById('clearFilterBtn'),
		rangeStartInput: document.getElementById('rangeStart'),
		rangeEndInput: document.getElementById('rangeEnd'),
        dialogueModal: document.getElementById('dialogueModal'),
        dialogueModalTitle: document.getElementById('dialogueModalTitle'),
        dialogueModalBody: document.getElementById('dialogueModalBody'),
        dialogueModalCloseBtn: document.getElementById('dialogueModalCloseBtn'),
        choralModal: document.getElementById('choralModal'),
        choralModalTitle: document.getElementById('choralModalTitle'),
        choralTimbreList: document.getElementById('choralTimbreList'),
        cancelChoralBtn: document.getElementById('cancelChoralBtn'),
        confirmChoralBtn: document.getElementById('confirmChoralBtn'),
        llmModelSelector: document.getElementById('llmModelSelector'),
        globalSettingsModal: document.getElementById('globalSettingsModal'),
        globalSettingsCloseBtn: document.getElementById('globalSettingsCloseBtn'),
        globalSettingsSaveBtn: document.getElementById('globalSettingsSaveBtn'),
        llmSettingsForm: document.getElementById('llmSettingsForm'),
		ttsSettingsForm: document.getElementById('ttsSettingsForm'),
        exportFormat: document.getElementById('exportFormat'),
        exportQuality: document.getElementById('exportQuality'),
        deleteNovelBtn: document.getElementById('deleteNovelBtn'),
        manageReplaceDictBtn: document.getElementById('manageReplaceDictBtn'),
        deleteNovelModal: document.getElementById('deleteNovelModal'),
        novelToDeleteName: document.getElementById('novelToDeleteName'),
        deleteConfirmInput: document.getElementById('deleteConfirmInput'),
        cancelDeleteBtn: document.getElementById('cancelDeleteBtn'),
        confirmDeleteBtn: document.getElementById('confirmDeleteBtn'),
        uploadTxtLabelBtn: document.getElementById('uploadTxtLabelBtn'),
        manageCharactersBtn: document.getElementById('manageCharactersBtn'),
		newCharManageNameInput: document.getElementById('newCharManageNameInput'),
		addCharManageBtn: document.getElementById('addCharManageBtn'),
        charManageModal: document.getElementById('charManageModal'),
        charSearchInput: document.getElementById('charSearchInput'),
        charManageList: document.getElementById('charManageList'),
        charsToMerge: document.getElementById('charsToMerge'),
        targetCharSelect: document.getElementById('targetCharSelect'),
        confirmMergeBtn: document.getElementById('confirmMergeBtn'),
        closeCharManageBtn: document.getElementById('closeCharManageBtn'),
		settingsDefaultModel: document.getElementById('settingsDefaultModel'),
		settingsProxyEnabled: document.getElementById('settingsProxyEnabled'),
		proxyDetailsGroup: document.getElementById('proxy-details-group'),
		settingsProxyProtocol: document.getElementById('settingsProxyProtocol'),
		settingsProxyAddress: document.getElementById('settingsProxyAddress'),
		settingsProxyPort: document.getElementById('settingsProxyPort'),
		settingsDefaultTtsModel: document.getElementById('settingsDefaultTtsModel'),
		editorTitleText: document.getElementById('editor-title-text'),
		editorTitleText: document.getElementById('editor-title-text'),
		chapterPlayStopBtn: document.getElementById('chapterPlayStopBtn'),
        viewSourceBtn: document.getElementById('viewSourceBtn'),
        sourceTextModal: document.getElementById('sourceTextModal'),
        sourceTextModalTitle: document.getElementById('sourceTextModalTitle'),
        sourceTextModalBody: document.getElementById('sourceTextModalBody'),
        sourceTextModalCloseBtn: document.getElementById('sourceTextModalCloseBtn'),
		manageTimbresBtn: document.getElementById('manageTimbresBtn'),
		timbresManageModal: document.getElementById('timbresManageModal'),
		closeTimbresManageBtn: document.getElementById('closeTimbresManageBtn'),
		managerCategoryList: document.getElementById('manager-category-list'),
		managerNewCategoryInput: document.getElementById('managerNewCategoryInput'),
		managerAddCategoryBtn: document.getElementById('managerAddCategoryBtn'),
		managerTimbresTitle: document.getElementById('manager-timbres-title'),
		managerTimbresList: document.getElementById('manager-timbres-list'),
		uploadTimbreCategory: document.getElementById('uploadTimbreCategory'),
        // Replace Dictionary Modal DOM elements
        detectTimbreConflictsBtn: document.getElementById('detectTimbreConflictsBtn'),
        replaceDictModal: document.getElementById('replaceDictModal'),
        replaceDictNovelName: document.getElementById('replaceDictNovelName'),
        newOriginalWord: document.getElementById('newOriginalWord'),
        newReplacementWord: document.getElementById('newReplacementWord'),
        newDescription: document.getElementById('newDescription'),
        addReplaceRuleBtn: document.getElementById('addReplaceRuleBtn'),
        replaceRuleSearchInput: document.getElementById('replaceRuleSearchInput'),
        replaceRulesList: document.getElementById('replaceRulesList'),
        closeReplaceDictBtn: document.getElementById('closeReplaceDictBtn'),
        manageEmoPromptsBtn: document.getElementById('manageEmoPromptsBtn'),
        emoPromptsManageModal: document.getElementById('emoPromptsManageModal'),
        emoPromptsListEl: document.getElementById('emo-prompts-list'),
        closeEmoPromptsManageBtn: document.getElementById('closeEmoPromptsManageBtn'),
        uploadEmoPromptLabelBtn: document.getElementById('uploadEmoPromptLabelBtn'),
        emoPromptFileInput: document.getElementById('emoPromptFileInput'),
        detectTimbreConflictsBtn: document.getElementById('detectTimbreConflictsBtn'),
        timbreConflictModal: document.getElementById('timbreConflictModal'),
        timbreConflictModalBody: document.getElementById('timbreConflictModalBody'),
        closeTimbreConflictBtn: document.getElementById('closeTimbreConflictBtn'),
		autoAssignTimbreBtn: document.getElementById('autoAssignTimbreBtn'),
		fineTuneModal: document.getElementById('fineTuneModal'),
		fineTuneModalTitle: document.getElementById('fineTuneModalTitle'),
		fineTuneContent: document.getElementById('fineTuneContent'),
		fineTuneTtsModelSelect: document.getElementById('fineTuneTtsModelSelect'),
		fineTuneModeSelect: document.getElementById('fineTuneModeSelect'),
		fineTuneInstructGroup: document.getElementById('fineTuneInstructGroup'),
		fineTuneInstructInput: document.getElementById('fineTuneInstructInput'),
		fineTuneEmoPromptGroup: document.getElementById('fineTuneEmoPromptGroup'),
		fineTuneEmoPromptSelect: document.getElementById('fineTuneEmoPromptSelect'),
		fineTuneEmoWeightInput: document.getElementById('fineTuneEmoWeightInput'),
		fineTuneGenerateBtn: document.getElementById('fineTuneGenerateBtn'),
		fineTunePlayBtn: document.getElementById('fineTunePlayBtn'),
		fineTuneEffectsBtn: document.getElementById('fineTuneEffectsBtn'),
		fineTuneCloseBtn: document.getElementById('fineTuneCloseBtn'),
        editorControlsPanel: document.getElementById('editor-controls-panel'),
    };

    // === 3. HELPER FUNCTIONS ===
    function updateModeDependentUI(row, currentMode) {
        const instructInput = row.querySelector('.instruct-input');
        const emoPromptGroup = row.querySelector('.emo-prompt-group');

        if (instructInput) {
            instructInput.style.display = currentMode === 'instruct' ? 'block' : 'none';
        }
        if (emoPromptGroup) {
            emoPromptGroup.style.display = currentMode === 'emo_prompt' ? 'flex' : 'none';
        }
    }
	
    function playAudio(audioPath) {
        stopAllAudio(); // æ’­æ”¾å‰ç¡®ä¿åœæ­¢æ‰€æœ‰å…¶ä»–éŸ³é¢‘

        // æ³¨æ„ï¼šæˆ‘ä»¬ä»ç„¶ä½¿ç”¨ state.simpleAudioPlayer æ¥æ’­æ”¾ï¼Œ
        // è¿™æ · stopAllAudio ä¹Ÿèƒ½æ­£ç¡®åœ°åœæ­¢å®ƒã€‚
        state.simpleAudioPlayer = new Audio(`${audioPath}?t=${new Date().getTime()}`);
        
        const audio = state.simpleAudioPlayer;

        // ç»‘å®šå¿…è¦çš„äº‹ä»¶ï¼Œä»¥ä¾¿åœ¨æ’­æ”¾ç»“æŸæˆ–å‡ºé”™æ—¶æ¸…ç†è‡ªèº«
        const onEnded = () => {
            // æ’­æ”¾å®Œåï¼Œåªæ¸…ç†æ’­æ”¾å™¨å®ä¾‹ï¼Œä¸ç¢°ä»»ä½•UIæŒ‰é’®
            if (state.simpleAudioPlayer === audio) {
                state.simpleAudioPlayer = null;
            }
        };
        const onError = () => { setStatus(`æ’­æ”¾å¤±è´¥`, 'error'); onEnded(); };
        
        audio.addEventListener('ended', onEnded);
        audio.addEventListener('error', onError);

        audio.play().catch(e => {
            if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
            onEnded();
        });
    }
	function formatTime(seconds) {
		const minutes = Math.floor(seconds / 60);
		const secs = Math.floor(seconds % 60);
		return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
	}
    // --- æ–°å¢ï¼šé˜²æ­¢å±å¹•ä¼‘çœ çš„è¾…åŠ©å‡½æ•° ---
    async function requestWakeLock() {
        if ('wakeLock' in navigator) {
            try {
                // å¦‚æœå·²å­˜åœ¨ä¸€ä¸ªé”ï¼Œå…ˆé‡Šæ”¾å®ƒ
                await releaseWakeLock();
                state.screenWakeLock = await navigator.wakeLock.request('screen');
                console.log('å±å¹•å”¤é†’é”å·²æ¿€æ´»ã€‚');
                setStatus('é•¿æ—¶é—´ä»»åŠ¡è¿›è¡Œä¸­ï¼Œå±å¹•å°†ä¿æŒå”¤é†’...', 'info');

                // ç›‘å¬é”çš„é‡Šæ”¾äº‹ä»¶ï¼Œä»¥é˜²æµè§ˆå™¨è‡ªåŠ¨é‡Šæ”¾ï¼ˆä¾‹å¦‚åˆ‡æ¢æ ‡ç­¾é¡µï¼‰
                state.screenWakeLock.addEventListener('release', () => {
                    console.log('å±å¹•å”¤é†’é”å·²è¢«æµè§ˆå™¨é‡Šæ”¾ã€‚');
                    state.screenWakeLock = null;
                });
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
                // å¿½ç•¥é”™è¯¯ï¼Œå› ä¸ºè¿™ä¸æ˜¯æ ¸å¿ƒåŠŸèƒ½
            }
        } else {
            console.warn('æµè§ˆå™¨ä¸æ”¯æŒ Screen Wake Lock APIã€‚');
        }
    }

    async function releaseWakeLock() {
        if (state.screenWakeLock !== null) {
            try {
                await state.screenWakeLock.release();
                state.screenWakeLock = null;
                console.log('å±å¹•å”¤é†’é”å·²é‡Šæ”¾ã€‚');
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }
    }
	
	function sanitizeTitleForFilename(title) {
		// This regex replaces any character that is NOT a letter, number, space, underscore, or hyphen.
		// We specifically keep Chinese characters by including the Unicode range \u4e00-\u9fa5.
		// The logic should perfectly match the Python backend's safe_title generation.
		// Python: "".join(c for c in title if c.isalnum() or c in " _-").rstrip()
		// JS equivalent is a bit more complex with regex to cover different languages.
		// A simpler regex that removes most problematic characters is often sufficient.
		
		// This simplified version removes common illegal characters for filenames.
		// It keeps letters (including Chinese), numbers, spaces, underscores, and hyphens.
		// It removes characters like ï¼ˆ, ï¼‰, ã€, ?, etc.
		return title.replace(/[^\p{L}\p{N}\s_-]/gu, '').trim();
	}
	
	let currentFineTuneRowIndex = -1; // è·Ÿè¸ªå½“å‰æ­£åœ¨å¾®è°ƒçš„è¡Œç´¢å¼•
	async function openFineTuneModal(rowIndex) {
		currentFineTuneRowIndex = rowIndex;
		let currentFineTuneLineId = null;
		await loadAndRenderEmoPrompts(false); // ä¼ å…¥ falseï¼Œè¡¨ç¤ºä¸æ¸²æŸ“ç®¡ç†æ¨¡æ€æ¡†ï¼Œåªæ›´æ–° state.allEmoPrompts
		
		const item = state.novelData[rowIndex];
		if (!item) {
			setStatus('é”™è¯¯ï¼šæœªèƒ½æ‰¾åˆ°è¯¥è¡Œçš„æ•°æ®è¿›è¡Œå¾®è°ƒã€‚', 'error');
			return;
		}
        state.currentFineTuneLineId = item.line_id;

		dom.fineTuneModal.classList.add('active');
		dom.fineTuneModalTitle.textContent = `è¡Œ ${rowIndex + 1} éŸ³é¢‘ç”Ÿæˆ`;
		dom.fineTuneContent.value = item.content; // æ˜¾ç¤ºå†…å®¹

		// é»˜è®¤ TTS æ¨¡å‹å’Œæ¨¡å¼ (å¦‚æœ item ä¸­æ²¡æœ‰ï¼Œå°±ç”¨å…¨å±€é»˜è®¤)
		const defaultTtsModelId = state.globalConfig?.general?.default_tts_model || '';
		const ttsModels = state.globalConfig?.tts_models || {};
		
		let ttsOptionsHtml = '';
		for (const modelId in ttsModels) {
			const model = ttsModels[modelId];
			ttsOptionsHtml += `<option value="${modelId}">${model.display_name || modelId}</option>`;
		}
		dom.fineTuneTtsModelSelect.innerHTML = ttsOptionsHtml;
		dom.fineTuneTtsModelSelect.value = item.tts_model || defaultTtsModelId;


		// --- åŠ¨æ€ç”Ÿæˆæ¨¡å¼é€‰é¡¹ï¼Œå¹¶å¤„ç†æƒ…ç»ªå‚è€ƒé€‰é¡¹çš„æ·»åŠ  ---
		const currentSelectedTtsModelForMode = dom.fineTuneTtsModelSelect.value; // è·å–å½“å‰ TTS æ¨¡å‹
		const shouldHaveEmoPromptOptionForMode = currentSelectedTtsModelForMode.toLowerCase().includes('indextts');
		
        let finalInferenceMode = item.inference_mode || ttsModels[dom.fineTuneTtsModelSelect.value]?.default_mode || 'zero_shot';

        // å¦‚æœæ•°æ®ä¸­çš„æ¨¡å¼æ˜¯ emo_promptï¼Œä½†å½“å‰æ¨¡å‹ä¸æ”¯æŒï¼Œåˆ™å›é€€åˆ° zero_shot
        if (finalInferenceMode === 'emo_prompt' && !shouldHaveEmoPromptOptionForMode) {
             finalInferenceMode = 'zero_shot';
        }
        let emoPromptOptionsHtml = '<option value="">é€‰æ‹©å‚è€ƒéŸ³é¢‘</option>';
        state.allEmoPrompts.forEach(p => {
            emoPromptOptionsHtml += `<option value="${p}" ${item.emo_audio_prompt === p ? 'selected' : ''}>${p}</option>`;
        });
        dom.fineTuneEmoPromptSelect.innerHTML = emoPromptOptionsHtml;
        dom.fineTuneEmoWeightInput.value = item.emo_weight !== undefined ? item.emo_weight : 5;

		let modeOptionsHtml = `
			<option value="zero_shot" ${item.inference_mode === 'zero_shot' ? 'selected' : ''}>æ­£å¸¸</option>
			<option value="cross_lingual" ${item.inference_mode === 'cross_lingual' ? 'selected' : ''}>ç²¾ç»†</option>
			<option value="instruct" ${item.inference_mode === 'instruct' ? 'selected' : ''}>æŒ‡ä»¤</option>
		`;
		if (shouldHaveEmoPromptOptionForMode) {
			modeOptionsHtml += `<option value="emo_prompt" ${item.inference_mode === 'emo_prompt' ? 'selected' : ''}>æƒ…ç»ªå‚è€ƒ</option>`;
		}
		dom.fineTuneModeSelect.innerHTML = modeOptionsHtml;
		dom.fineTuneModeSelect.value = item.inference_mode || ttsModels[dom.fineTuneTtsModelSelect.value]?.default_mode || 'zero_shot';

		// æŒ‡ä»¤è¾“å…¥æ¡†
		dom.fineTuneInstructInput.value = item.instruct_text || '';
		dom.fineTuneInstructGroup.style.display = (dom.fineTuneModeSelect.value === 'instruct') ? 'block' : 'none';

		// æƒ…ç»ªå‚è€ƒç»„
		dom.fineTuneEmoPromptGroup.style.display = (shouldHaveEmoPromptOptionForMode && dom.fineTuneModeSelect.value === 'emo_prompt') ? 'flex' : 'none';

		// æ›´æ–°ç”Ÿæˆã€æ’­æ”¾å’Œç‰¹æ•ˆæŒ‰é’®çŠ¶æ€
		const fileExists = state.generatedFiles[state.currentFineTuneLineId];
		const timbreOverrideEl = document.querySelector(`#content-row-${rowIndex} .timbre-override-select`);
		const currentTimbre = timbreOverrideEl ? timbreOverrideEl.value : (state.characterMapping[item.speaker] || null);

		dom.fineTuneGenerateBtn.disabled = !currentTimbre; // åªè¦æœ‰éŸ³è‰²å°±å¯ç”Ÿæˆ
		dom.fineTunePlayBtn.disabled = !fileExists; // æœ‰æ–‡ä»¶å°±å¯æ’­æ”¾
		dom.fineTuneEffectsBtn.disabled = !fileExists; // æœ‰æ–‡ä»¶å°±å¯ç‰¹æ•ˆ

		// ä¸ºæ¨¡æ€æ¡†å†…çš„é€‰æ‹©å™¨å’Œè¾“å…¥æ¡†æ·»åŠ äº‹ä»¶ç›‘å¬
		addFineTuneModalEventListeners(rowIndex);
	}

	// --- æ–°å¢å‡½æ•°ï¼šä¸ºå¾®è°ƒæ¨¡æ€æ¡†å†…çš„æ§ä»¶æ·»åŠ äº‹ä»¶ç›‘å¬ ---
	function addFineTuneModalEventListeners(rowIndex) {
		// å…ˆç§»é™¤æ—§çš„ç›‘å¬å™¨ï¼Œé˜²æ­¢é‡å¤æ·»åŠ 
		dom.fineTuneTtsModelSelect.removeEventListener('change', handleFineTuneChange);
		dom.fineTuneModeSelect.removeEventListener('change', handleFineTuneChange);
		dom.fineTuneInstructInput.removeEventListener('input', handleFineTuneInput);
		dom.fineTuneEmoPromptSelect.removeEventListener('change', handleFineTuneChange);
		dom.fineTuneEmoWeightInput.removeEventListener('change', handleFineTuneChange);

		// æ·»åŠ æ–°çš„ç›‘å¬å™¨
		dom.fineTuneTtsModelSelect.addEventListener('change', handleFineTuneChange);
		dom.fineTuneModeSelect.addEventListener('change', handleFineTuneChange);
		dom.fineTuneInstructInput.addEventListener('input', handleFineTuneInput);
		dom.fineTuneEmoPromptSelect.addEventListener('change', handleFineTuneChange);
		dom.fineTuneEmoWeightInput.addEventListener('change', handleFineTuneChange);
	}

	// --- æ–°å¢å‡½æ•°ï¼šå¤„ç†å¾®è°ƒæ¨¡æ€æ¡†å†…çš„å˜åŒ– (ä»…æ›´æ–°æ¨¡æ€æ¡†UIï¼Œä¸ç›´æ¥æ›´æ–° state.novelData) ---
	function handleFineTuneChange() {
		const currentSelectedTtsModel = dom.fineTuneTtsModelSelect.value;
		const currentSelectedTtsModelForEmo = dom.fineTuneTtsModelSelect.value;
		const shouldHaveEmoPromptOption = currentSelectedTtsModelForEmo.toLowerCase().includes('indextts');
		const existingEmoOption = dom.fineTuneModeSelect.querySelector('option[value="emo_prompt"]');
		if (shouldHaveEmoPromptOption && !existingEmoOption) {
			// å¦‚æœåº”è¯¥æ˜¯ IndexTTS ä½†é€‰é¡¹ä¸å­˜åœ¨ï¼Œåˆ™æ·»åŠ 
			const option = document.createElement('option');
			option.value = "emo_prompt";
			option.textContent = "æƒ…ç»ªå‚è€ƒ";
			dom.fineTuneModeSelect.appendChild(option);
		} else if (!shouldHaveEmoPromptOption && existingEmoOption) {
			// å¦‚æœä¸æ˜¯ IndexTTS ä½†é€‰é¡¹å­˜åœ¨ï¼Œåˆ™ç§»é™¤
			if (dom.fineTuneModeSelect.value === 'emo_prompt') {
				dom.fineTuneModeSelect.value = 'zero_shot'; // å¦‚æœå½“å‰é€‰ä¸­æ˜¯æƒ…ç»ªå‚è€ƒï¼Œåˆ™åˆ‡æ¢åˆ°é»˜è®¤
			}
			existingEmoOption.remove();
		}
		dom.fineTuneInstructGroup.style.display = (dom.fineTuneModeSelect.value === 'instruct') ? 'block' : 'none';
		if (shouldHaveEmoPromptOption && dom.fineTuneModeSelect.value === 'emo_prompt') {
			dom.fineTuneEmoPromptGroup.style.display = 'flex';
		} else {
			dom.fineTuneEmoPromptGroup.style.display = 'none';
		}
	}
	function handleFineTuneInput() {
		// å¯¹äºæŒ‡ä»¤è¾“å…¥ï¼Œä»…æ›´æ–°æ¨¡æ€æ¡†UIï¼Œä¸ç›´æ¥æ›´æ–° state.novelData
		// å®é™…ä¸Šè¿™ä¸ªå‡½æ•°å¯ä»¥ç®€åŒ–ï¼Œå› ä¸ºæˆ‘ä»¬ä¸ç›´æ¥ä¿å­˜åˆ° item
		handleFineTuneChange();
	}
    function sanitizeForFilename(text) {
        if (!text) return '';
        // è¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼ä½¿ç”¨ Unicode å±æ€§ \p{L} (ä»»ä½•è¯­è¨€çš„å­—æ¯) å’Œ \p{N} (ä»»ä½•è¯­è¨€çš„æ•°å­—)
        // å®ƒæ¨¡æ‹Ÿäº† Python çš„ isalnum() è¡Œä¸ºï¼ŒåŒæ—¶ä¿ç•™äº†ä¸‹åˆ’çº¿ã€è¿å­—ç¬¦å’Œç©ºæ ¼ã€‚
        // 'u' æ ‡å¿—å¯ç”¨äº† Unicode æ”¯æŒã€‚
        return text.replace(/[^\p{L}\p{N}\s_-]/gu, '').trim();
    }
	
	function markChapterAsDirty() {
		state.isChapterDirty = true;
		dom.saveChapterBtn.disabled = false;
		setStatus('å†…å®¹å·²ä¿®æ”¹ï¼Œè¯·è®°å¾—ä¿å­˜ã€‚', 'warning');
        state.isProofreadDataStale = true;
	}
    function setStatus(msg, type = 'info') {
        dom.globalStatus.textContent = msg;
        const colorMap = { 'info': '#5f6368', 'success': '#56773D', 'error': '#d93025', 'warning': '#f9ab00' };
        dom.globalStatus.style.color = colorMap[type];
    }
    async function fetchFromServer(url, options = {}) {
        const response = await fetch(url, options);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: response.statusText }));
            throw new Error(errorData.detail || `è¯·æ±‚å¤±è´¥: ${response.status}`);
        }
        return response.json();
    }
		
	function stopAllAudio(fromSimplePlayerClick = false) {
		// åœæ­¢ç« èŠ‚æ’­æ”¾å™¨
		if (state.globalAudioPlayer) {
			const audio = state.globalAudioPlayer;
			audio.pause();
			if (audio._listeners) {
				audio.removeEventListener('loadedmetadata', audio._listeners.onLoadedMetadata);
				audio.removeEventListener('timeupdate', audio._listeners.onTimeUpdate);
				audio.removeEventListener('play', audio._listeners.onPlay);
				audio.removeEventListener('pause', audio._listeners.onPause);
				audio.removeEventListener('ended', audio._listeners.onEnded);
				audio.removeEventListener('error', audio._listeners.onError);
			}
			state.globalAudioPlayer = null;
			dom.chapterPlayStopBtn.textContent = 'â–¶ æ’­æ”¾ç« èŠ‚';
            dom.audioPlayerModal.classList.remove('active'); // ç§»é™¤ active ç±»
		}

		// åœæ­¢ç®€å•æ’­æ”¾å™¨
		if (state.simpleAudioPlayer) {
            // æ£€æŸ¥ URL æ˜¯å¦ä¸º blob URLï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é‡Šæ”¾å®ƒä»¥é¿å…å†…å­˜æ³„æ¼
            if (state.simpleAudioPlayer.src && state.simpleAudioPlayer.src.startsWith('blob:')) {
                URL.revokeObjectURL(state.simpleAudioPlayer.src);
            }
			state.simpleAudioPlayer.pause();
			if (state.simpleAudioPlayer._listeners) {
				 state.simpleAudioPlayer.removeEventListener('ended', state.simpleAudioPlayer._listeners.onEnded);
				 state.simpleAudioPlayer.removeEventListener('error', state.simpleAudioPlayer._listeners.onError);
			}
			state.simpleAudioPlayer = null;
		}

		// é‡ç½®ç®€å•æ’­æ”¾æŒ‰é’®çš„å›¾æ ‡
		if (state.activeSimplePlayerButton) {
			state.activeSimplePlayerButton.innerHTML = 'â–¶';
			state.activeSimplePlayerButton = null;
		}
	}
	
    function toggleLocalBlobAudio(button, file) {
        // è¿™ä¸ªå‡½æ•°ä¸“é—¨ç”¨äºå¤„ç†æœ¬åœ°æ–‡ä»¶é¢„è§ˆçš„æ’­æ”¾

        // æ­¥éª¤ 1: å¦‚æœå½“å‰æ­£åœ¨æ’­æ”¾çš„å°±æ˜¯è¿™ä¸ªæŒ‰é’®ï¼Œåˆ™åœæ­¢å®ƒ
        if (state.activeSimplePlayerButton === button) {
            stopAllAudio(); // stopAllAudio ä¼šå¤„ç†å›¾æ ‡é‡ç½®å’ŒéŸ³é¢‘åœæ­¢
            return;
        }

        // æ­¥éª¤ 2: åœæ­¢æ‰€æœ‰å…¶ä»–å¯èƒ½æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
        stopAllAudio();

        // æ­¥éª¤ 3: ä¸ºæœ¬åœ°æ–‡ä»¶åˆ›å»ºä¸€ä¸ªæ–°çš„ blob URL
        const localAudioURL = URL.createObjectURL(file);

        // æ­¥éª¤ 4: æ›´æ–°çŠ¶æ€å¹¶å¼€å§‹æ’­æ”¾
        state.activeSimplePlayerButton = button;
        button.innerHTML = 'â—¼';

        state.simpleAudioPlayer = new Audio(localAudioURL); // ç›´æ¥ä½¿ç”¨ï¼Œä¸åŠ æ—¶é—´æˆ³
        const audio = state.simpleAudioPlayer;
        
        const onEnded = () => {
            URL.revokeObjectURL(localAudioURL); // åœ¨æ’­æ”¾ç»“æŸåé‡Šæ”¾ URL
            stopAllAudio();
        };
        const onError = () => {
            setStatus(`æ’­æ”¾å¤±è´¥`, 'error');
            URL.revokeObjectURL(localAudioURL); // å‡ºé”™æ—¶ä¹Ÿè¦é‡Šæ”¾ URL
            stopAllAudio();
        };
        
        audio.addEventListener('ended', onEnded);
        audio.addEventListener('error', onError);
        audio._listeners = { onEnded, onError }; // è®°å½•ä¸‹æ¥ä»¥ä¾¿ stopAllAudio èƒ½ç§»é™¤

        audio.play().catch(e => {
            if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
            URL.revokeObjectURL(localAudioURL); // å‡ºé”™æ—¶ä¹Ÿè¦é‡Šæ”¾ URL
            stopAllAudio();
        });
    }

	/**
	 * æ–°åŠŸèƒ½ 1: æ’­æ”¾/åœæ­¢ ç« èŠ‚éŸ³é¢‘ (ç”±å†…å®¹ç¼–è¾‘å™¨æ ‡é¢˜æ æŒ‰é’®è§¦å‘)
	 */
	function toggleChapterAudio() {
		if (state.globalAudioPlayer) {
			stopAllAudio();
			return;
		}

		const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
		if (selectedCheckboxes.length === 1) {
			const checkbox = selectedCheckboxes[0];
			const chapterTitle = checkbox.dataset.title;
			const pathParts = checkbox.value.replace('.json', '').split(/[/\\]/);
			const novel = pathParts[0];
			const chapter = pathParts.length > 1 ? pathParts[1] : pathParts[0];
			const audioFormat = state.globalConfig.audio_export?.format || 'mp3';
			const audioPath = `/output/${novel}/${chapter}.${audioFormat}`;
			
			stopAllAudio();
			state.globalAudioPlayer = new Audio(`${audioPath}?t=${new Date().getTime()}`);
			const audio = state.globalAudioPlayer;

			dom.playerModalTitle.textContent = `æ­£åœ¨æ’­æ”¾: ${chapterTitle}`;
            dom.audioPlayerModal.classList.add('active'); // ä½¿ç”¨ active ç±»
			dom.chapterPlayStopBtn.textContent = 'â—¼ åœæ­¢æ’­æ”¾';

			// --- å®Œæ•´çš„äº‹ä»¶å¤„ç†å™¨å®šä¹‰ ---
			const onLoadedMetadata = () => {
				dom.playerProgressBar.max = audio.duration;
				dom.playerTotalDuration.textContent = formatTime(audio.duration);
			};
			const onTimeUpdate = () => {
				dom.playerProgressBar.value = audio.currentTime;
				dom.playerCurrentTime.textContent = formatTime(audio.currentTime);
			};
			const onPlay = () => dom.playerPlayPauseBtn.innerHTML = 'âšâš';
			const onPause = () => dom.playerPlayPauseBtn.innerHTML = 'â–¶';
			const onEnded = stopAllAudio;
			const onError = () => { setStatus(`æ— æ³•åŠ è½½éŸ³é¢‘`, 'error'); stopAllAudio(); };

			audio.addEventListener('loadedmetadata', onLoadedMetadata);
			audio.addEventListener('timeupdate', onTimeUpdate);
			audio.addEventListener('play', onPlay);
			audio.addEventListener('pause', onPause);
			audio.addEventListener('ended', onEnded);
			audio.addEventListener('error', onError);
			audio._listeners = { onLoadedMetadata, onTimeUpdate, onPlay, onPause, onEnded, onError };
			
			audio.play().catch(e => {
				if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
				stopAllAudio();
			});
		}
	}

	/**
	 * æ–°åŠŸèƒ½ 2: æ’­æ”¾/åœæ­¢ ç®€å•éŸ³é¢‘ (ç”±åœ†å½¢æŒ‰é’®è§¦å‘)
	 */
	function toggleSimpleAudio(button, audioPath) {
        // åœ¨å¼€å§‹æ’­æ”¾æ–°éŸ³é¢‘å‰ï¼Œæ£€æŸ¥å¹¶é‡Šæ”¾ä¸Šä¸€ä¸ª blob URL
        if (state.currentBlobURL) {
            URL.revokeObjectURL(state.currentBlobURL);
            state.currentBlobURL = null;
        }
		const isCurrentlyPlaying = state.activeSimplePlayerButton === button;

		// 1. æ— è®ºå¦‚ä½•ï¼Œå…ˆåœæ­¢æ‰€æœ‰å½“å‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘ã€‚
		//    stopAllAudio() ä¼šè´Ÿè´£å°†æ—§çš„ activeSimplePlayerButton çš„å›¾æ ‡æ¢å¤ä¸º â–¶
		stopAllAudio();

		// 2. å¦‚æœåˆšæ‰ç‚¹å‡»çš„æŒ‰é’®å°±æ˜¯æ­£åœ¨æ’­æ”¾çš„é‚£ä¸ªï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ä»»åŠ¡åªæ˜¯åœæ­¢å®ƒï¼Œæ‰€ä»¥åˆ°æ­¤ä¸ºæ­¢ã€‚
		if (isCurrentlyPlaying) {
			return;
		}

		// 3. å¦åˆ™ï¼Œæˆ‘ä»¬è¦å¼€å§‹æ’­æ”¾æ–°çš„éŸ³é¢‘ã€‚
		state.activeSimplePlayerButton = button;
		button.innerHTML = 'â—¼';

        // å¦‚æœæ˜¯ blob URLï¼Œåˆ™è®°å½•ä¸‹æ¥ä»¥ä¾¿åç»­é‡Šæ”¾
        if (audioPath.startsWith('blob:')) {
            state.currentBlobURL = audioPath;
        }
		state.simpleAudioPlayer = new Audio(`${audioPath}?t=${new Date().getTime()}`);
		const audio = state.simpleAudioPlayer;
		
		const onEnded = () => {
			// æ’­æ”¾å®Œåï¼Œè°ƒç”¨ stopAllAudio æ¥æ¸…ç†ä¸€åˆ‡å¹¶é‡ç½®UI
			stopAllAudio();
		};
		const onError = () => { setStatus(`æ’­æ”¾å¤±è´¥`, 'error'); stopAllAudio(); };
		
		audio.addEventListener('ended', onEnded);
		audio.addEventListener('error', onError);
		audio._listeners = { onEnded, onError };

		audio.play().catch(e => {
			if (e.name !== 'AbortError') setStatus(`æ’­æ”¾å¤±è´¥: ${e.message}`, 'error');
			stopAllAudio(); // å‡ºé”™æ—¶ä¹Ÿè¦æ¸…ç†
		});
	}
	
    function toBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }
    async function checkFileExists(filePath) {
		try {
			const response = await fetch(filePath, { method: 'HEAD', cache: 'no-store' });
			return response.ok;
		} catch (error) { return false; }
	}

    // === 4. CORE LOGIC & RENDERING ===

    async function loadNovels(shouldRender = true) { // å¢åŠ ä¸€ä¸ª shouldRender å‚æ•°
        try {
            const data = await fetchFromServer('/api/list_novels');
            // +++ åªåˆå§‹åŒ–åŸºæœ¬ç»“æ„ +++
            const novelsDetails = data.novels_details || {};
			
            // æ¯æ¬¡éƒ½å®Œå…¨é‡å»º state.allNovelsDataï¼Œè€Œä¸æ˜¯å¢é‡æ›´æ–°
            state.allNovelsData = {}; // æ¸…ç©ºç°æœ‰æ•°æ®
            for (const novelName in novelsDetails) {
                state.allNovelsData[novelName] = {
                    isTxtProject: novelsDetails[novelName].isTxtProject,
                    // chapters æ•°æ®å°†åœ¨é€‰æ‹©å°è¯´æ—¶åŠ è½½ï¼Œè¿™é‡Œå¯ä»¥åˆå§‹åŒ–ä¸ºç©º
                    chapters: []
                };
            }

            if (shouldRender) {
                // ä¿å­˜åˆ é™¤å‰é€‰ä¸­çš„å°è¯´é¡¹ç›®åç§°
                const currentNovelBeforeDeletion = dom.novelSelector.value;

                dom.novelSelector.innerHTML = '<option value="">-- é€‰æ‹©å°è¯´é¡¹ç›® --</option>';
                Object.keys(state.allNovelsData).sort().forEach(novel => {
                    const option = document.createElement('option');
                    option.value = novel;
                    option.textContent = novel;
                    dom.novelSelector.appendChild(option);
                });

                // å°è¯•æ¢å¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€ï¼Œä½†è¦ç¡®ä¿å®ƒä»ç„¶å­˜åœ¨äºæ–°çš„åˆ—è¡¨ä¸­
                if (currentNovelBeforeDeletion && state.allNovelsData[currentNovelBeforeDeletion]) {
                    dom.novelSelector.value = currentNovelBeforeDeletion;
                    state.novelName = currentNovelBeforeDeletion; // ç¡®ä¿ state.novelName ä¹ŸåŒæ­¥
                } else {
                    // å¦‚æœä¹‹å‰é€‰ä¸­çš„å°è¯´å·²è¢«åˆ é™¤ï¼Œæˆ–æ²¡æœ‰é€‰ä¸­ä»»ä½•å°è¯´ï¼Œåˆ™é‡ç½®ä¸ºé»˜è®¤
                    dom.novelSelector.value = '';
                    state.novelName = ''; // ç¡®ä¿ state.novelName è¢«æ¸…ç©º
                }
            }
        } catch (e) { 
            setStatus(`åŠ è½½å°è¯´åˆ—è¡¨å¤±è´¥: ${e.message}`, 'error'); 
        }
    }
	
    async function handleTxtFileUpload(file) {
        if (!file) return;
        
        const novelName = file.name.replace(/\.txt$/i, '');
        setStatus(`æ­£åœ¨ä¸Šä¼ å¹¶åˆ†æå°è¯´: ${file.name}...`, 'info');
        
        // ç¦ç”¨UIé˜²æ­¢ç”¨æˆ·æ“ä½œ
        dom.novelSelector.disabled = true;
        dom.uploadTxtLabelBtn.disabled = true;

        const formData = new FormData();
        formData.append('file', file);

        try {
            // 1. ä¸Šä¼ æ–‡ä»¶ï¼Œå¹¶ç›´æ¥ä»åç«¯è·å–æ–°é¡¹ç›®çš„å®Œæ•´æ•°æ®ç»“æ„
            const newProjectData = await fetchFromServer('/api/upload_txt_novel', { 
                method: 'POST', 
                body: formData 
            });
            setStatus(newProjectData.message, 'success');

            // 2. æ›´æ–°å‰ç«¯ state
            //    a. å¢é‡æ›´æ–° allNovelsDataï¼ŒåŠ å…¥è¿™ä¸ªæ–°é¡¹ç›®
            //       åç«¯åº”è¯¥åœ¨ upload_txt_novel æˆåŠŸåï¼Œè¿”å›ç±»ä¼¼ list_novels ä¸­å•ä¸ªé¡¹ç›®çš„ç»“æ„
            //       ä¸ºäº†ç¡®ä¿ä¸‡æ— ä¸€å¤±ï¼Œæˆ‘ä»¬ç›´æ¥é‡æ–°åŠ è½½æ‰€æœ‰å°è¯´
            await loadNovels();

            // 3. æ›´æ–°UI
            //    a. é‡æ–°å¡«å……ä¸‹æ‹‰æ¡†ï¼ˆloadNovels å·²ç»åšäº†ï¼‰
            //    b. ä»¥ç¼–ç¨‹æ–¹å¼é€‰ä¸­æ–°ä¸Šä¼ çš„å°è¯´
            state.isProgrammaticChange = true; // ç«‹èµ·æ——å¸œï¼Œé˜²æ­¢ change äº‹ä»¶çš„å‰¯ä½œç”¨
            dom.novelSelector.value = novelName;
            
            // c. ã€æ ¸å¿ƒä¿®å¤ã€‘æ‰‹åŠ¨è°ƒç”¨ handleNovelSelection æ¥åŠ è½½æ–°é¡¹ç›®çš„å†…å®¹
            //    å› ä¸º isProgrammaticChange æ ‡å¿—ä¼šé˜»æ­¢ change äº‹ä»¶ç›‘å¬å™¨ä¸­çš„ handleNovelSelection æ‰§è¡Œ
            await handleNovelSelection(true); // ä¼ å…¥ä¸€ä¸ªå‚æ•°è¡¨ç¤ºè¿™æ˜¯ç”±ä¸Šä¼ è§¦å‘çš„

        } catch (error) {
            setStatus(`ä¸Šä¼ å¤±è´¥: ${error.message}`, 'error');
        } finally {
            // 4. æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½æ¢å¤UI
            dom.novelSelector.disabled = false;
            dom.uploadTxtLabelBtn.disabled = false;
        }
    }

	// å·®å¼‚ç‚¹ï¼šæä¾›å®Œæ•´çš„ã€åŒ…å«è¿‡æ»¤é€»è¾‘çš„ renderChapterList å‡½æ•°
	async function renderChapterList() {
		const listContainer = dom.chapterListEl;
		listContainer.innerHTML = '';
		state.lastCheckedIndex = -1;
		
        const novelName = state.novelName;
        const novelData = state.allNovelsData[novelName];
        
        // --- è¯Šæ–­æ¢é’ˆ 1 ---
        console.log(`[renderChapterList] Rendering for novel: ${novelName}`);
        if (novelData) {
            console.log(`[renderChapterList] Found novelData. isTxtProject is:`, novelData.isTxtProject);
        } else {
            console.warn(`[renderChapterList] No novelData found for ${novelName}!`);
        }
		
        const isTxtProject = novelData && novelData.isTxtProject === true;
		
		let originalChapters = [];

		if (novelData && novelData.chapters) {
            originalChapters = novelData.chapters.map((c, index) => ({ 
				path: isTxtProject ? c.id : `${novelName}/${sanitizeTitleForFilename(c.title)}.json`,
				name: c.title,
				originalIndex: index,
				processed: c.processed,
                spliced: c.spliced
			}));
		}

		const { status, start, end } = state.filter;
		let isFilterActive = status !== 'all' || (start && start.trim()) || (end && end.trim());
		let chaptersToRender = originalChapters;
		if (isFilterActive) {
			chaptersToRender = originalChapters.filter((chapter, index) => {
				const itemIndex = index + 1;
				if (status === 'unprocessed' && chapter.processed) return false;
                // é€»è¾‘ï¼šåªè¦è¿™ä¸€ç« æ²¡æœ‰ spliced æ ‡è®°ï¼Œå°±è¿‡æ»¤æ‰
                if (status === 'processed') {
                    // å¦‚æœç« èŠ‚æœªå¤„ç†ï¼Œæˆ–è€…ç« èŠ‚å·²ç”Ÿæˆè¯­éŸ³ï¼Œåˆ™è¿‡æ»¤æ‰
                    if (!chapter.processed || chapter.spliced) {
                        return false;
                    }
                }
                if (status === 'spliced' && !chapter.spliced) return false;
				const startRange = start ? parseInt(start, 10) : null;
				const endRange = end ? parseInt(end, 10) : null;
				if (startRange && itemIndex < startRange) return false;
				if (endRange && itemIndex > endRange) return false;
				return true;
			});
		}
		dom.filterBtn.classList.toggle('filter-btn-active', isFilterActive);

		if (chaptersToRender.length === 0) {
			dom.chapterListEl.innerHTML = '<p class="placeholder-text">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ç« èŠ‚</p>';
		} else {
            let displayCounter = 1;
			chaptersToRender.forEach(chapter => {
				const li = document.createElement('li');
				li.className = `selectable ${chapter.processed ? 'processed' : ''} ${chapter.spliced ? 'spliced' : ''}`;
				
				const txtChapterAttribute = isTxtProject ? 'data-txt-chapter="true"' : '';
                
                // *** æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨è¿™é‡Œä¿®æ­£ checkbox value çš„ç”Ÿæˆé€»è¾‘ ***
                let checkboxValue;
                if (chapter.processed) {
                    // å¦‚æœç« èŠ‚å·²å¤„ç†ï¼Œæ— è®ºå®ƒæ¥è‡ªå“ªé‡Œï¼Œå®ƒçš„ "èº«ä»½" éƒ½åº”è¯¥æ˜¯ä¸€ä¸ª .json æ–‡ä»¶ã€‚
                    // å®ƒçš„è·¯å¾„åº”è¯¥æ˜¯æ ‡å‡†æ ¼å¼ã€‚
                    checkboxValue = `${novelName}/${sanitizeTitleForFilename(chapter.name)}.json`;
                } else {
                    // å¦‚æœç« èŠ‚æœªå¤„ç†ï¼Œæ‰åŒºåˆ†å®ƒæ¥è‡ªå“ªé‡Œã€‚
                    // å¦‚æœæ˜¯ TXT é¡¹ç›®ï¼Œå®ƒçš„è·¯å¾„å°±æ˜¯å®ƒçš„ IDã€‚
                    // å¦‚æœæ˜¯åŸç”Ÿé¡¹ç›®ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é¢„å…ˆç”Ÿæˆè·¯å¾„ï¼Œä½†è¿™ä¸å…³é”®ã€‚
                    checkboxValue = isTxtProject ? chapter.path : `${novelName}/${sanitizeTitleForFilename(chapter.name)}.json`;
                }
                
                // ä¸ºäº†ä¸ "å¤„ç†é€‰ä¸­ç« èŠ‚" æŒ‰é’®å…¼å®¹ï¼Œæœªå¤„ç†çš„TXTç« èŠ‚éœ€è¦ä¿ç•™ data-txt-chapter å±æ€§
                // åªæœ‰å½“å®ƒæ˜¯æœªå¤„ç†çš„TXTé¡¹ç›®æ—¶ï¼Œæ‰æ·»åŠ è¿™ä¸ªå±æ€§
                const finalTxtAttribute = isTxtProject ? 'data-txt-chapter="true"' : '';

				li.innerHTML = `<label style="display:flex; align-items:center; width:100%; cursor:pointer;">
                                    <input type="checkbox" class="chapter-checkbox" value="${checkboxValue}" data-index="${chapter.originalIndex}" data-title="${chapter.name}" ${txtChapterAttribute}> 
                                    <span class="label">
                                        <span style="display: inline-block; width: 3em; color: #9aa0a6; text-align: right; margin-right: 0.5rem;">${displayCounter}.</span>
                                        ${chapter.name}
                                    </span>
                                </label>`;
				
				listContainer.appendChild(li);
                displayCounter++; // è®¡æ•°å™¨é€’å¢
			});
		}
		updateGlobalButtons();
	}
        
    async function processTxtChapters() {
        if (state.isTxtProcessing) {
            state.isTxtProcessingCancelled = true;
            setStatus('ä¸­æ­¢æŒ‡ä»¤å·²å‘å‡ºï¼Œæ­£åœ¨ç­‰å¾…å½“å‰ç« èŠ‚å¤„ç†å®Œæˆ...', 'warning');
            updateGlobalButtons();
            return;
        }

        const chapterCheckboxesToProcess = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox[data-txt-chapter]:checked'));
        if (chapterCheckboxesToProcess.length === 0) {
            alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªTXTé¡¹ç›®çš„ç« èŠ‚è¿›è¡Œå¤„ç†ã€‚');
            return;
        }
		
        if (!state.selectedLLM) {
            alert('é”™è¯¯ï¼šæœªèƒ½è·å–åˆ°æœ‰æ•ˆçš„å¤„ç†æ¨¡å‹ã€‚è¯·ç¡®è®¤æ¨¡å‹å·²é€‰æ‹©æˆ–åˆ·æ–°é¡µé¢é‡è¯•ã€‚');
            setStatus('å¤„ç†å¤±è´¥ï¼šæœªé€‰æ‹©å¤„ç†æ¨¡å‹ã€‚', 'error');
            return;
        }

        // --- æ–°å¢ï¼šç”¨æˆ·ç¡®è®¤é€»è¾‘ ---
        const chaptersToReprocess = chapterCheckboxesToProcess
            .filter(cb => cb.closest('li').classList.contains('processed'))
            .map(cb => cb.dataset.title);

        if (chaptersToReprocess.length > 0) {
            let confirmationMessage = '';
            const reprocessCount = chaptersToReprocess.length;
            const displayThreshold = 5;

            if (reprocessCount <= displayThreshold) {
                confirmationMessage = `ä»¥ä¸‹ç« èŠ‚å°†è¢«é‡æ–°å¤„ç†ï¼Œå¹¶åˆ é™¤å·²ç”Ÿæˆçš„è¯­éŸ³ï¼š\n\n- ${chaptersToReprocess.join('\n- ')}\n\næ‚¨ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`;
            } else {
                confirmationMessage = `æ‚¨é€‰ä¸­äº† ${reprocessCount} ä¸ªå·²è¢«å¤„ç†è¿‡çš„ç« èŠ‚ã€‚\n\nç»§ç»­æ“ä½œå°†æ°¸ä¹…åˆ é™¤è¿™äº›ç« èŠ‚å·²ç”Ÿæˆçš„æ‰€æœ‰è¯­éŸ³æ–‡ä»¶ã€‚\n\næ‚¨ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`;
            }

            if (!confirm(confirmationMessage)) {
                setStatus('æ“ä½œå·²å–æ¶ˆã€‚', 'info');
                return; // ç”¨æˆ·å–æ¶ˆï¼Œç»ˆæ­¢å‡½æ•°
            }
        }
        // --- ç”¨æˆ·ç¡®è®¤é€»è¾‘ç»“æŸ ---
        
        state.isTxtProcessing = true;
        state.isTxtProcessingCancelled = false;
        updateGlobalButtons();

        let processedCount = 0;
        const totalToProcess = chapterCheckboxesToProcess.length;
        
        try {
			await requestWakeLock(); // <-- æ–°å¢
            for (let i = 0; i < totalToProcess; i++) {
                if (state.isTxtProcessingCancelled) {
                    setStatus('å¤„ç†å·²ä¸­æ­¢ã€‚', 'warning');
                    break;
                }

                const checkbox = chapterCheckboxesToProcess[i];
                const chapterTitle = checkbox.dataset.title;
                const isReprocessing = chaptersToReprocess.includes(chapterTitle);

                setStatus(`[${i + 1}/${totalToProcess}] ${isReprocessing ? 'é‡æ–°' : ''}å¤„ç†ç« èŠ‚: ${chapterTitle}...`, 'info');

                try {
                    const payload = { 
                        novel_name: state.novelName, 
                        chapter_title: chapterTitle,
                        model_name: state.selectedLLM,
                        force_regenerate: isReprocessing // å‘åç«¯å‘é€ä¿¡å·
                    };
                    
                    await fetchFromServer('/api/process_single_chapter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    processedCount++;

                } catch (error) {
                    setStatus(`å¤„ç†ç« èŠ‚ "${chapterTitle}" å¤±è´¥: ${error.message}ã€‚å·²è·³è¿‡ã€‚`, 'error');
                    console.error(`[Process TXT] Error processing ${chapterTitle}:`, error);
                    continue;
                }
            }
        } finally {
			await releaseWakeLock(); // <-- æ–°å¢
            setStatus(`å¤„ç†ä»»åŠ¡ç»“æŸã€‚å…±æˆåŠŸå¤„ç† ${processedCount} / ${totalToProcess} ä¸ªç« èŠ‚ã€‚`, 'success');
            
            state.isTxtProcessing = false;
            state.isTxtProcessingCancelled = false;

            // 1. åˆ·æ–°å°è¯´é¡¹ç›®åˆ—è¡¨ï¼ˆå¯é€‰ï¼Œå¦‚æœä»…å¤„ç†ç« èŠ‚ï¼Œé€šå¸¸ä¸éœ€è¦é‡æ–°æ¸²æŸ“æ•´ä¸ªä¸‹æ‹‰æ¡†ï¼‰
            //    ä¼ é€’ false å‚æ•°ä»¥é¿å…ä¸å¿…è¦çš„ä¸‹æ‹‰æ¡†é‡æ–°æ¸²æŸ“ï¼Œå› ä¸ºå½“å‰å°è¯´é€šå¸¸æ²¡å˜
            await loadNovels(false);

            // 2. ç¡®ä¿ä¸‹æ‹‰æ¡†ä»ç„¶é€‰ä¸­å½“å‰å°è¯´
            dom.novelSelector.value = state.novelName;

            // --- æ ¸å¿ƒä¿®å¤å¼€å§‹ ---
            // 3. é‡æ–°åŠ è½½å½“å‰å°è¯´çš„è¯¦ç»†ç« èŠ‚æ•°æ®ï¼Œä»¥è·å–æœ€æ–°çš„â€œå·²å¤„ç†â€çŠ¶æ€
            if (state.novelName) { // ç¡®ä¿æœ‰å°è¯´é€‰ä¸­
                try {
                    setStatus(`æ­£åœ¨ä¸ºå°è¯´ã€Œ${state.novelName}ã€é‡æ–°åŠ è½½ç« èŠ‚åˆ—è¡¨...`, 'info');
                    const chapterData = await fetchFromServer(`/api/list_chapters?novel_name=${encodeURIComponent(state.novelName)}`);
                    // æ›´æ–° state ä¸­å½“å‰å°è¯´çš„ç« èŠ‚æ•°æ®
                    state.allNovelsData[state.novelName].chapters = chapterData.chapters || [];
                    setStatus('ç« èŠ‚åˆ—è¡¨å·²æ›´æ–°ã€‚', 'success');
                } catch (error) {
                    setStatus(`å¤„ç†ååŠ è½½ç« èŠ‚åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
                    state.allNovelsData[state.novelName].chapters = []; // é”™è¯¯æ—¶æ¸…ç©ºï¼Œé¿å…ä½¿ç”¨æ—§çš„é”™è¯¯æ•°æ®
                }
            }
            // --- æ ¸å¿ƒä¿®å¤ç»“æŸ ---

            // 4. æ ¹æ®ç°åœ¨æœ€æ–°çš„ç« èŠ‚æ•°æ®é‡æ–°æ¸²æŸ“ç« èŠ‚åˆ—è¡¨ UI
            await renderChapterList();

            // 5. æ¢å¤ä¹‹å‰å‹¾é€‰çš„ç« èŠ‚çŠ¶æ€ (è¿™ä¸€æ­¥ä»ç„¶éœ€è¦ï¼Œå› ä¸º renderChapterList ä¼šé‡å»ºDOM)
            const currentSelectedTitles = chapterCheckboxesToProcess.map(cb => cb.dataset.title);
            dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => {
                if (currentSelectedTitles.includes(cb.dataset.title)) {
                    cb.checked = true;
                }
            });

            // 6. æ›´æ–°å…¨å±€æŒ‰é’®çŠ¶æ€å¹¶åˆ·æ–°å†…å®¹ç¼–è¾‘å™¨åŒºåŸŸ
            updateGlobalButtons();
            handleChapterSelectionChange(); // è¿™ä¼šæ ¹æ®æ–°çš„ç« èŠ‚çŠ¶æ€æ¥æ˜¾ç¤ºå†…å®¹ç¼–è¾‘å™¨å†…å®¹
        }
    }

    async function loadCharacters() {
        const selectedChapterPaths = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked')).map(cb => cb.value);
        
        if (selectedChapterPaths.length === 0) {
            dom.characterListEl.innerHTML = '<p class="placeholder-text">è¯·åœ¨å·¦ä¾§é€‰æ‹©ç« èŠ‚</p>';
            state.selectedCharacter = null; 
            updateTimbreConflictHighlight(null); 
            return;
        }

        dom.characterListEl.innerHTML = '<p class="placeholder-text">æ­£åœ¨åŠ è½½è§’è‰²...</p>';
        
        let charactersToShow = [];

        if (selectedChapterPaths.length === 1 && state.novelData.length > 0) {
            // *** å¦‚æœåªæœ‰ä¸€ä¸ªç« èŠ‚è¢«é€‰ä¸­ä¸”å†…å®¹å·²åŠ è½½ï¼Œç›´æ¥ä» state.novelData è¯»å– ***
            charactersToShow = Array.from(new Set(state.novelData.map(item => item.speaker).filter(s => s)));
            
        } else {
            // *** å¦‚æœé€‰ä¸­å¤šä¸ªç« èŠ‚ï¼Œæˆ–å•ä¸ªç« èŠ‚ä½†å†…å®¹æœªåŠ è½½ï¼Œåˆ™è°ƒç”¨åç«¯æ¥å£ ***
            try {
                const chapterFiles = selectedChapterPaths.map(path => path.split('/').pop());
                const payload = { novel_name: state.novelName, chapter_files: chapterFiles };
                const data = await fetchFromServer('/api/get_characters_in_chapters', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                charactersToShow = data.characters;
            } catch (e) {
                setStatus(`åŠ è½½è§’è‰²å¤±è´¥: ${e.message}`, 'error');
                dom.characterListEl.innerHTML = `<p class="placeholder-text" style="color:var(--danger-color);">åŠ è½½è§’è‰²å¤±è´¥</p>`;
                return;
            }
        }
        
        renderCharacterList(charactersToShow);
    }

	async function renderCharacterList(characters) {
        dom.characterListEl.innerHTML = '';
        if (!characters || characters.length === 0) {
             dom.characterListEl.innerHTML = '<p class="placeholder-text">æ‰€é€‰ç« èŠ‚å†…æœªå‘ç°è§’è‰²</p>'; return;
        }
		
        // *** æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨æ›´ç®€å•ã€æ›´å¯é çš„æ’åºé€»è¾‘ ***
        characters.sort((a, b) => {
            // ç›´æ¥æ£€æŸ¥ state.characterMapping[è§’è‰²å] æ˜¯å¦ä¸ºä¸€ä¸ªâ€œçœŸå€¼â€
            // çœŸå€¼æ„å‘³ç€å®ƒä¸æ˜¯ null, undefined, '', 0, falseã€‚
            // è¿™è¦†ç›–äº†æ‰€æœ‰â€œæœªåˆ†é…â€æˆ–â€œè¢«æ¸…ç©ºâ€çš„æƒ…å†µã€‚
            const a_has_timbre = !!state.characterMapping[a];
            const b_has_timbre = !!state.characterMapping[b];

            // å¦‚æœä¸¤è€…çš„åˆ†é…çŠ¶æ€ä¸åŒ
            if (a_has_timbre !== b_has_timbre) {
                // å¦‚æœ a æ²¡æœ‰éŸ³è‰² (false)ï¼Œb æœ‰ (true)ï¼Œé‚£ä¹ˆ a åº”è¯¥æ’åœ¨å‰é¢ã€‚
                // !a_has_timbre (true) - !b_has_timbre (false) = 1 (åœ¨JSä¸­å¸ƒå°”å€¼ä¼šè½¬ä¸ºæ•°å­—)
                // è¿™ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚ç›´æ¥ç”¨ if åˆ¤æ–­æ›´æ¸…æ™°ã€‚
                if (a_has_timbre) {
                    return 1; // a æœ‰ï¼Œb æ²¡æœ‰ï¼Œb åœ¨å‰
                } else {
                    return -1; // a æ²¡æœ‰ï¼Œb æœ‰ï¼Œa åœ¨å‰
                }
            }
            
            // å¦‚æœä¸¤è€…çŠ¶æ€ç›¸åŒï¼ˆéƒ½æœ‰æˆ–éƒ½æ²¡æœ‰ï¼‰ï¼Œåˆ™æŒ‰å­—æ¯é¡ºåºæ’åº
            return a.localeCompare(b);
        });
        
        characters.forEach(char => {
            const li = document.createElement('li');
            li.className = 'selectable character-row';
            li.dataset.characterName = char;
            if (char === state.selectedCharacter) li.classList.add('selected');
            
            const currentTimbre = state.characterMapping[char] || '---';
            if (currentTimbre === '---') {
                li.style.borderLeft = '3px solid var(--danger-color)'; // ç”¨å·¦è¾¹æ¡†é«˜äº®æœªåˆ†é…é¡¹
            }
            			
			// æ£€æŸ¥è§’è‰²ç®€ä»‹çŠ¶æ€å¹¶åœ¨éœ€è¦æ—¶æ·»åŠ ç±»
			const profiles = state.allNovelsData[state.novelName]?.character_profiles || {};
			const characterProfile = profiles[char];
			if (characterProfile && (characterProfile.gender === 'æœªçŸ¥' || characterProfile.ageGroup === 'æœªçŸ¥' || !characterProfile.identity)) {
				if (char !== 'æ—ç™½') { // æ—ç™½ä¸éœ€è¦è¢«æ ‡è¯†
					li.classList.add('profile-incomplete');
				}
			}
									
			const isNarrator = char === 'æ—ç™½'; // å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œæ–¹ä¾¿å¤ç”¨
			const profileBtnDisabled = isNarrator ? 'disabled' : ''; // å¦‚æœæ˜¯æ—ç™½ï¼Œåˆ™æ·»åŠ  disabled å±æ€§
            const isPlayable = !!state.characterMapping[char];
            const playableClass = isPlayable ? 'playable' : '';
			li.innerHTML = `<button class="btn btn-profile" data-character-name="${char}" title="${isNarrator ? 'æ—ç™½æ— éœ€ç®€ä»‹' : `æŸ¥çœ‹'${char}'ç®€ä»‹`}" ${profileBtnDisabled}>i</button>
						  <span class="label">${char}</span>
						  <div class="character-actions">
							<span class="value">${currentTimbre}</span>
							<button class="audio-player-btn ${playableClass}" title="è¯•å¬éŸ³è‰² ${currentTimbre}" style="visibility: ${state.characterMapping[char] ? 'visible' : 'hidden'};">â–¶</button>
							<button class="btn btn-danger circular-btn btn-delete-timbre-assignment" title="åˆ é™¤å·²åˆ†é…éŸ³è‰²" data-character-name="${char}" style="visibility: ${state.characterMapping[char] ? 'visible' : 'hidden'};">X</button>
						  </div>`;
            dom.characterListEl.appendChild(li);
        });
        updateRelatedRolesPopovers(); // åœ¨è¿™é‡Œè°ƒç”¨ï¼Œç¡®ä¿ DOM å·²æ›´æ–°
    }
    
	function updateRelatedRolesPopovers() {
		const isAnyChapterSelected = state.selectedChapterPaths.length > 0;

		let activeChapterCharacters = new Set();
		if (isAnyChapterSelected) {
			dom.characterListEl.querySelectorAll('.character-row .label').forEach(labelEl => {
				activeChapterCharacters.add(labelEl.textContent);
			});
		}
		const activeChapterCharacterArray = Array.from(activeChapterCharacters);

		dom.timbreListEl.querySelectorAll('li').forEach(li => {
			const timbreName = li.querySelector('.label')?.textContent;
			if (!timbreName) return;

			const popoverContainer = li.querySelector('.popover-container.roles-popover');
			if (!popoverContainer) return;

			const allAssignedRoles = Object.entries(state.characterMapping)
								  .filter(([char, timb]) => timb === timbreName)
								  .map(([char]) => char);
            
            const relevantAssignedRoles = allAssignedRoles.filter(role => 
                activeChapterCharacterArray.includes(role)
            );

			const popoverContentUl = popoverContainer.querySelector('.popover-content ul');
            
            if (isAnyChapterSelected && relevantAssignedRoles.length > 0) {
                popoverContainer.style.display = 'block';
				popoverContentUl.innerHTML = relevantAssignedRoles.map(c => `<li>${c}</li>`).join('');
            } else {
                popoverContainer.style.display = 'none';
                popoverContentUl.innerHTML = '';
            }
		});
	}
    
	async function loadAndApplyConfig() {
		setStatus(`æ­£åœ¨ä¸º "${state.novelName}" åŠ è½½éŸ³è‰²é…ç½®...`);
		try {
            // *** æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨URLä¸­æ·»åŠ ä¸€ä¸ªç¼“å­˜ç ´åè€…å‚æ•° ***
            const cacheBuster = `&_t=${new Date().getTime()}`;
			const url = `/api/get_config?novel_name=${state.novelName}${cacheBuster}`;

			// ä½¿ç”¨æ–°çš„URLæ¥è·å–æ•°æ®
			state.characterMapping = await fetchFromServer(url);
			setStatus(`é…ç½®åŠ è½½æˆåŠŸ`, 'success');
		} catch(e) {
			state.characterMapping = {};
			setStatus(`æœªæ‰¾åˆ°å°è¯´ "${state.novelName}" çš„é…ç½®ï¼Œå·²ä½¿ç”¨ç©ºé…ç½®ã€‚`, 'warning');
		} finally {
			await loadCharacters();
		}
	}
    
	async function saveConfig() {
		if (!state.novelName) return;
		setStatus(`æ­£åœ¨ä¿å­˜é…ç½®åˆ° "${state.novelName}.json"...`);
		try {
			// The novel_name is now the sole identifier for the config
			const payload = { novel_name: state.novelName, config_data: state.characterMapping };
			const result = await fetchFromServer('/api/update_config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
			setStatus(result.message, 'success');
            updateRelatedRolesPopovers(); 
		} catch (e) { setStatus(`ä¿å­˜é…ç½®å¤±è´¥: ${e.message}`, 'error'); }
	}

    function showTimbreUploadModal(file) {
        state.fileToUpload = file;
        dom.newTimbreNameInput.value = file.name.split('.').slice(0, -1).join('.');
        dom.newTimbreTextInput.value = '';
        dom.timbreUploadModal.classList.add('active'); // ä½¿ç”¨ active ç±»
        dom.newTimbreNameInput.focus();
		dom.transcribeBtn.disabled = !file;
        dom.previewUploadBtn.disabled = !file;
    }
    function hideTimbreUploadModal() {
        stopAllAudio(); // ç¡®ä¿åœ¨å…³é—­æ—¶åœæ­¢ä»»ä½•æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
        dom.timbreUploadModal.classList.remove('active'); // ç§»é™¤ active ç±»
        state.fileToUpload = null;
        dom.previewUploadBtn.disabled = true; // å…³é—­åç¦ç”¨æŒ‰é’®
    }
	async function handleTimbreUpload() {
		if (!state.fileToUpload) return;
		const timbreName = dom.newTimbreNameInput.value.trim();
		const promptText = dom.newTimbreTextInput.value.trim();
		if (!timbreName || !promptText) {
			alert('éŸ³è‰²åç§°å’Œå‚è€ƒæ–‡æœ¬å‡ä¸èƒ½ä¸ºç©ºã€‚');
			return;
		}
		const normalize = document.getElementById('normalizeVolume').checked;
		const category = dom_timbres_manager.uploadCategorySelect.value; // è·å–åˆ†ç±»
		
		const formData = new FormData();
		formData.append('file', state.fileToUpload);
		formData.append('timbre_name', timbreName);
		formData.append('prompt_text', promptText);
		formData.append('normalize', normalize);
		formData.append('category_name', category); // å‘é€åˆ†ç±»

		setStatus(`æ­£åœ¨ä¸Šä¼ å¹¶å¤„ç†éŸ³è‰²: ${timbreName}... (æ­¤è¿‡ç¨‹å¯èƒ½éœ€è¦1-2åˆ†é’Ÿ)`, 'info');
		hideTimbreUploadModal();
		
		// UIåé¦ˆï¼šç¦ç”¨ä¸Šä¼ æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤æäº¤
		dom.uploadTimbreLabelBtn.disabled = true;
		dom.uploadTimbreLabelBtn.textContent = 'æ­£åœ¨å¤„ç†æ–°éŸ³è‰²...';

		try {
			const response = await fetch('/api/upload_timbre', {
				method: 'POST',
				body: formData
				// æ³¨æ„ï¼šä½¿ç”¨ FormData æ—¶ï¼Œæµè§ˆå™¨ä¼šè‡ªåŠ¨è®¾ç½® Content-Typeï¼Œä¸è¦æ‰‹åŠ¨è®¾ç½®
			});
			
			const result = await response.json();
			if (response.ok) {
				setStatus(result.message, 'success');
				await loadTimbres();
			} else {
				throw new Error(result.detail || 'ä¸Šä¼ å¤„ç†å¤±è´¥');
			}

		} catch (error) {
			setStatus(`ä¸Šä¼ å¤±è´¥: ${error.message}`, 'error');
		} finally {
			// æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½æ¢å¤ä¸Šä¼ æŒ‰é’®
			dom.uploadTimbreLabelBtn.disabled = false;
			dom.uploadTimbreLabelBtn.textContent = 'ä¸Šä¼ æ–°éŸ³è‰²';
		}
	}
    
	async function handleChapterSelectionChange() {
        state.selectedChapterPaths = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked')).map(cb => cb.value);
				
        updateGlobalButtons();

        // æŸ¥æ‰¾æ‰€æœ‰ç›¸å…³çš„ DOM å…ƒç´ 
        const editorView = dom.editorView;
        const batchView = dom.batchView;
        const editorControlsPanel = dom.editorControlsPanel; // <-- ä½¿ç”¨æ–°çš„ DOM å¼•ç”¨
        const contentTable = dom.contentTable;
        const rawTextView = document.getElementById('raw-text-view');
        const rawTextTitle = document.getElementById('raw-text-title');
        const rawTextContent = document.getElementById('raw-text-content');

        // é€šç”¨æ¸…ç†
        editorView.style.display = 'none';
        batchView.style.display = 'none';
        contentTable.style.display = 'none';
        rawTextView.style.display = 'none';
        editorControlsPanel.style.display = 'none';
        dom.editorTitleText.textContent = 'å†…å®¹ç¼–è¾‘å™¨';

        if (state.isProcessing || state.isTxtProcessing) {
            batchView.style.display = 'flex';
            dom.batchViewMessage.textContent = 'ä»»åŠ¡å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...';
            return;
        }
        
        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');

        if (selectedCheckboxes.length === 1) {
            editorView.style.display = 'block';
            const checkbox = selectedCheckboxes[0];
            const chapterTitle = checkbox.dataset.title;
            const isProcessed = checkbox.closest('li').classList.contains('processed');
            const isTxtChapter = checkbox.hasAttribute('data-txt-chapter');

            // --- æ ¸å¿ƒé€»è¾‘åˆ†æ”¯ ---
            if (isProcessed) {
                // æƒ…å†µ Aï¼šå·²å¤„ç†ç« èŠ‚ -> æ˜¾ç¤ºè¡¨æ ¼ç¼–è¾‘å™¨
                contentTable.style.display = 'table';
                editorControlsPanel.style.display = 'flex';
                const filepath = checkbox.value;
                await loadSingleChapterForEditing(filepath);
				await loadCharacters(); 
				updateProofreadModeDisplay();
            } else if (isTxtChapter) {
                // æƒ…å†µ Bï¼šæœªå¤„ç†çš„ TXT ç« èŠ‚ -> æ˜¾ç¤ºåŸæ–‡é¢„è§ˆ
                rawTextView.style.display = 'block';
                rawTextTitle.textContent = `åŸæ–‡é¢„è§ˆ: ${chapterTitle}`;
                rawTextContent.textContent = 'æ­£åœ¨åŠ è½½åŸæ–‡...';
                try {
                    const payload = {
                        novel_name: state.novelName,
                        chapter_title: chapterTitle,
                        preview_only: true
                    };
                    const result = await fetchFromServer('/api/process_single_chapter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (result.status === 'preview') {
						// ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å°†ä¸¤ä¸ªæˆ–æ›´å¤šçš„è¿ç»­æ¢è¡Œç¬¦ï¼Œæ›¿æ¢ä¸ºå•ä¸ªæ¢è¡Œç¬¦
						const formattedContent = result.content.replace(/(\r\n|\n|\r){2,}/g, '\n\n');
						rawTextContent.textContent = formattedContent;
                    } else {
                        throw new Error('åç«¯æœªè¿”å›é¢„è§ˆå†…å®¹ã€‚');
                    }
                } catch (error) {
                    rawTextContent.textContent = `åŠ è½½åŸæ–‡å¤±è´¥: ${error.message}`;
                }
				let charactersToShow = [];
				renderCharacterList(charactersToShow);
                
            } else {
                // æƒ…å†µ Cï¼šå…¶ä»–æƒ…å†µï¼ˆä¾‹å¦‚ï¼Œæ—§ç‰ˆé¡¹ç›®æœªå¤„ç†çš„ç« èŠ‚ï¼‰ï¼Œæ˜¾ç¤ºæç¤º
                batchView.style.display = 'flex';
                dom.batchViewMessage.textContent = 'è¯·å…ˆåœ¨å·¦ä¾§å¤„ç†æ­¤ç« èŠ‚ã€‚';
				let charactersToShow = [];
				renderCharacterList(charactersToShow);
            }
            // ---

        } else { // é€‰ä¸­ 0 ä¸ªæˆ–å¤šä¸ª
            batchView.style.display = 'flex';
            dom.batchViewMessage.textContent = selectedCheckboxes.length > 1 
                ? `å·²é€‰æ‹© ${selectedCheckboxes.length} ä¸ªç« èŠ‚ã€‚è¯·ä½¿ç”¨é¡¶éƒ¨å…¨å±€æŒ‰é’®è¿›è¡Œæ‰¹é‡æ“ä½œã€‚` 
                : `è¯·åœ¨å·¦ä¾§é€‰æ‹©ä¸€ä¸ªç« èŠ‚ä»¥æ˜¾ç¤ºå†…å®¹ã€‚`;
			await loadCharacters(); 
        }
        
	}
	
	async function loadSingleChapterForEditing(filepath) {
		setStatus(`æ­£åœ¨åŠ è½½ç« èŠ‚å†…å®¹...`);
		let chapterWasInitiallyModifiedForLineId = false; // æ–°å¢æ ‡å¿—
		
		state.isProofreadMode = false;
		state.proofreadMatches.clear();
		state.proofreadOriginalFragments = [];
		const toggleBtn = document.getElementById('toggleProofreadModeBtn');
		if (toggleBtn) toggleBtn.classList.remove('filter-btn-active');

		try {
			const cacheBuster = `&_t=${new Date().getTime()}`;
			const url = `/api/get_novel_content?filepath=${filepath}${cacheBuster}`;
			
			const chapterContent = await fetchFromServer(url);

            state.novelData = chapterContent.map((item, index) => {
				if (!item.line_id) { // æ£€æŸ¥æ˜¯å¦ç¼ºå°‘ line_id
                    item.line_id = generateUUID(); // è‡ªåŠ¨ç”Ÿæˆ line_id
                    item.originalIndex = index; // è®°å½•å®ƒåœ¨åŸå§‹ï¼ˆæœªä¿®æ”¹ï¼‰æ•°ç»„ä¸­çš„ç´¢å¼•
                    chapterWasInitiallyModifiedForLineId = true; // æ ‡è®°ä¸ºéœ€è¦é™é»˜ä¿å­˜
                } else if (item.originalIndex === undefined || item.originalIndex === -1) {
                    // å¦‚æœå·²ç»æœ‰ line_id ä½†æ²¡æœ‰ originalIndexï¼Œä¸ºäº†ä»¥é˜²ä¸‡ä¸€ï¼Œä¹Ÿç»™ä¸€ä¸ªï¼ˆé€šå¸¸ä¸éœ€è¦ï¼Œå› ä¸ºæœ‰ line_id çš„å·²ç»æ˜¯æ–°æ ¼å¼äº†ï¼‰
                    item.originalIndex = index; 
                }
                return { ...item }; // è¿”å›ä¸€ä¸ªå‰¯æœ¬ï¼Œç¡®ä¿ item æœ‰ line_id å’Œ originalIndex
            });
			
			let currentNovelName = state.novelName; 
			let currentChapterOriginalTitle = ''; // ä½¿ç”¨æ›´æ˜ç¡®çš„åç§°

			// ä» chapter-list é€‰ä¸­çš„ checkbox ä¸­è·å–åŸå§‹æ ‡é¢˜
			const selectedChapterCheckbox = dom.chapterListEl.querySelector('.chapter-checkbox:checked');
			if (selectedChapterCheckbox && selectedChapterCheckbox.dataset.title) {
				currentChapterOriginalTitle = selectedChapterCheckbox.dataset.title;
			} else {
				 // å¦‚æœä» DOM ä¸­è·å–ä¸åˆ°ï¼Œå°è¯•ä» state.allNovelsData ä¸­æŸ¥æ‰¾
				 const chapterFilenameWithJson = filepath.split('/').pop();
				 const chapterTitleFromFilename = chapterFilenameWithJson.replace(/\.json$/, '');
				 
				 if (state.allNovelsData[currentNovelName] && state.allNovelsData[currentNovelName].chapters) {
					 const foundChapter = state.allNovelsData[currentNovelName].chapters.find(chap => 
						 sanitizeForFilename(chap.title) === chapterTitleFromFilename || chap.title === chapterTitleFromFilename
					 );
					 if (foundChapter) {
						 currentChapterOriginalTitle = foundChapter.title;
					 }
				 }
			}

			if (!currentNovelName) {
				console.error("ERROR: state.novelName is undefined or empty when trying to load source text.", filepath);
				state.chapterSourceText = '';
				setStatus(`åŠ è½½ç« èŠ‚åŸæ–‡å¤±è´¥ï¼šå°è¯´é¡¹ç›®æœªé€‰æ‹©ã€‚`, 'error');
				return; 
			}
			
			if (!currentChapterOriginalTitle) {
				console.error("ERROR: æ— æ³•è·å–åˆ°ç« èŠ‚çš„åŸå§‹æ ‡é¢˜ï¼Œå¯èƒ½ç« èŠ‚åˆ—è¡¨æœªæ­£ç¡®åŠ è½½æˆ–é€‰ä¸­:", filepath);
				state.chapterSourceText = '';
				setStatus(`åŠ è½½ç« èŠ‚åŸæ–‡å¤±è´¥ï¼šæ— æ³•è·å–ç« èŠ‚åŸå§‹æ ‡é¢˜ã€‚`, 'error');
				return; 
			}

			try {
				// ä½¿ç”¨ encodeURIComponent ç¡®ä¿æ ‡é¢˜ä¸­çš„ç‰¹æ®Šå­—ç¬¦è¢«æ­£ç¡®ç¼–ç 
				const sourceTextResult = await fetchFromServer(`/api/get_chapter_source_text?novel_name=${encodeURIComponent(currentNovelName)}&chapter_title=${encodeURIComponent(currentChapterOriginalTitle)}`);
				state.chapterSourceText = sourceTextResult.content;
				state.proofreadMatches.clear(); 
				state.proofreadOriginalFragments = []; 
				setStatus('ç« èŠ‚åŸæ–‡åŠ è½½æˆåŠŸã€‚', 'success');
			} catch (sourceTextError) {
				state.chapterSourceText = ''; 
				state.proofreadMatches.clear(); 
				state.proofreadOriginalFragments = []; 
				setStatus(`åŠ è½½ç« èŠ‚åŸæ–‡å¤±è´¥: ${sourceTextError.message}ã€‚è¯·æ£€æŸ¥å°è¯´æºæ–‡ä»¶æ˜¯å¦å­˜åœ¨æˆ–ç« èŠ‚æ ‡é¢˜æ˜¯å¦åŒ¹é…ã€‚`, 'error'); 
			}

            if (chapterWasInitiallyModifiedForLineId) {
                setStatus('æ­£åœ¨æ›´æ–°ç« èŠ‚å”¯ä¸€IDå¹¶é™é»˜ä¿å­˜ (åŒæ—¶é‡å‘½åæ—§éŸ³é¢‘)...', 'info');
                try {
                    const payload = { filepath: filepath, content: state.novelData };
                    // è°ƒç”¨ saveChapter APIï¼Œåç«¯ä¼šè´Ÿè´£é‡å‘½å WAV æ–‡ä»¶
                    await fetchFromServer('/api/update_chapter_content', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    setStatus('ç« èŠ‚å”¯ä¸€IDå’Œæ—§éŸ³é¢‘å·²è‡ªåŠ¨ä¿å­˜å’Œé‡å‘½åã€‚', 'success');
                    state.isChapterDirty = false; // é™é»˜ä¿å­˜åï¼Œç« èŠ‚ä¸å†æ˜¯ dirty
                    dom.saveChapterBtn.disabled = true;
                } catch (saveError) {
                    setStatus(`é™é»˜ä¿å­˜ç« èŠ‚å”¯ä¸€IDæˆ–é‡å‘½åæ—§éŸ³é¢‘å¤±è´¥: ${saveError.message}`, 'error');
                }
            }

			await loadTimbres(); 

			state.generatedFiles = {};
			renderContentTable();
			await checkAllPlayableFiles(); // é‡æ–°æ£€æŸ¥æ’­æ”¾çŠ¶æ€ï¼Œä¼šè¯†åˆ«é‡å‘½ååçš„æ–‡ä»¶
            updateProofreadModeDisplay(); // åŠ è½½ååŒæ­¥æ˜¾ç¤º
		} catch (e) {
			setStatus(`åŠ è½½ç« èŠ‚å†…å®¹å¤±è´¥: ${e.message}`, 'error');
			state.novelData = [];
			renderContentTable();
		}
	}
	
    async function refreshEditorContent() {
        renderContentTable();
        
        // å¦‚æœæ ¡å¯¹æ¨¡å¼å¼€å¯ï¼Œé‡æ–°è®¡ç®—å¹¶æ¸²æŸ“æ ¡å¯¹ç»“æœ
        if (state.isProofreadMode) {
            setStatus('æ­£åœ¨é‡æ–°åŒ¹é…åŸæ–‡ä¸è¯­å¥...', 'info');
            await preProcessOriginalTextForProofreading(); 
            updateProofreadModeDisplay();
        }
        
        // é‡æ–°æ£€æŸ¥æ’­æ”¾çŠ¶æ€ (å¿…é¡»åœ¨ renderContentTable ä¹‹å)
        await checkAllPlayableFiles();
        
        setStatus('ç¼–è¾‘å™¨å†…å®¹å·²åˆ·æ–°ã€‚', 'info');
    }

	function renderContentTable() {
		const placeholder = dom.editorView.querySelector('.placeholder-text');

		if (state.novelData.length === 0) {
			dom.contentTable.style.display = 'none';
			placeholder.style.display = 'block';
			dom.editorControlsPanel.style.display = 'none'; 
            dom.editorTitleText.textContent = 'å†…å®¹ç¼–è¾‘å™¨';
			return;
		}
		dom.contentTable.style.display = 'table';
		placeholder.style.display = 'none';
		dom.editorControlsPanel.style.display = 'flex';
		dom.saveChapterBtn.disabled = true;
		
		const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
		const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
		dom.editorTitleText.textContent = `å†…å®¹ç¼–è¾‘å™¨: ${state.novelName} / ${currentChapterName}`;
		
        const defaultTtsModelId = state.globalConfig?.general?.default_tts_model || '';
		
        let availableCharactersSet = new Set(state.allAvailableCharacters);
		
		let ttsOptionsHtml = '';
		const ttsModels = state.globalConfig?.tts_models || {};
		const defaultTtsModel = state.globalConfig?.general?.default_tts_model || '';
		for (const modelId in ttsModels) {
			const model = ttsModels[modelId];
			const isSelected = modelId === defaultTtsModel ? 'selected' : '';
			ttsOptionsHtml += `<option value="${modelId}" ${isSelected}>${model.display_name || modelId}</option>`;
		}

        const toneOptions = ["å–œ", "æ€’", "å“€", "æƒ§", "åŒæ¶", "ä½è½", "æƒŠå–œ", "å¹³é™"];
        const toneOptionsHtml = toneOptions.map(tone => `<option value="${tone}">${tone}</option>`).join('');
		
		let tableHTML = '';
		state.novelData.forEach((item, index) => {
            if (item.speaker && !availableCharactersSet.has(item.speaker)) {
                availableCharactersSet.add(item.speaker);
            }
            
            // ç¡®ä¿æ—ç™½æ€»åœ¨æœ€å‰é¢
            const finalCharacterList = Array.from(availableCharactersSet).sort((a, b) => {
                if (a === 'æ—ç™½') return -1;
                if (b === 'æ—ç™½') return 1;
                return a.localeCompare(b);
            });
            // ä¸ºæ–°å¢è¡Œç”Ÿæˆ line_id
            if (!item.line_id) { // æ¸²æŸ“å‰å†æ¬¡ç¡®ä¿ line_id å­˜åœ¨ (é¢„é˜²æ€§)
                item.line_id = generateUUID();
                // å¦‚æœæ˜¯æ–°æ’å…¥çš„è¡Œï¼Œåº”è¯¥åœ¨æ’å…¥æ—¶å·²ç»è®¾ç½® dirty æ ‡å¿—
            }
			const timbreOverride = item.timbre_override;
			const characterTimbre = state.characterMapping[item.speaker];
			const assignedTimbre = timbreOverride || characterTimbre;
			const isAssigned = !!assignedTimbre;

			let timbreSelectHtml = '';
			const timbreOptions = state.allTimbres.map(t => 
				`<option value="${t}" ${t === assignedTimbre ? 'selected' : ''}>${t}</option>`
			).join('');

			if (isAssigned) {
				let finalOptions = timbreOptions;
				if (!state.allTimbres.includes(assignedTimbre)) {
					finalOptions += `<option value="${assignedTimbre}" selected disabled class="placeholder-option">${assignedTimbre} (å·²ä¸¢å¤±)</option>`;
				}
				timbreSelectHtml = `<select class="timbre-override-select" data-line-id="${item.line_id}" style="width: 100%;">${finalOptions}</select>`;
			} else {
				timbreSelectHtml = `<select class="timbre-override-select" data-line-id="${item.line_id}" style="width: 100%;"> 
										<option value="" disabled selected class="placeholder-option">-- è¯·é€‰æ‹©éŸ³è‰² --</option>
										${timbreOptions}
									</select>`;
			}
			
            let currentToneSelectHtml = `<select class="tone-select" data-line-id="${item.line_id}">`;
			
            let toneToUse = item.tone;
            let isDefaultTone = false;
            
            if (!toneOptions.includes(item.tone)) {
                // å¦‚æœ toneOptions ä¸­ä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨â€œå¹³é™â€ä½œä¸ºé»˜è®¤å€¼
                toneToUse = 'å¹³é™';
                isDefaultTone = true;
            }

            // 2. æ·»åŠ æ‰€æœ‰æ ‡å‡†é€‰é¡¹ï¼Œå¹¶é€‰ä¸­å®é™…ä½¿ç”¨çš„å€¼
            currentToneSelectHtml += toneOptions.map(tone => 
                `<option value="${tone}" ${tone === toneToUse ? 'selected' : ''}>${tone}</option>`
            ).join('');
			
            currentToneSelectHtml += `</select>`;

            const currentIntensity = item.intensity || 5;
            const intensityInputHtml = `<input type="number" class="intensity-input" data-line-id="${item.line_id}" min="1" max="10" value="${currentIntensity}" style="width: 50px; text-align: center;">`; 
			
            const currentTtsModelId = item.tts_model || defaultTtsModelId;
            const currentMode = item.inference_mode || state.globalConfig.tts_models[currentTtsModelId]?.default_mode || 'zero_shot';

			tableHTML += `<tr id="content-row-${item.line_id}"> 
				<td class="row-actions">
					<button class="btn btn-danger btn-delete-row" data-line-id="${item.line_id}" title="åˆ é™¤æ­¤è¡Œ">X</button>
					<button class="btn btn-insert-row" data-line-id="${item.line_id}" title="åœ¨æ­¤è¡Œä¸‹æ–¹æ’å…¥æ–°è¡Œ">+</button>
				</td>
				<td>${index + 1}</td>
				<td>
					<div class="character-select-group">
						<select class="speaker-select" data-line-id="${item.line_id}">
							${finalCharacterList.map(char => `<option value="${char}" ${char === item.speaker ? 'selected' : ''}>${char}</option>`).join('')}
						</select>
					</div>
				</td>
				<td>${timbreSelectHtml}</td>
				<td class="content-cell" contenteditable="true" data-line-id="${item.line_id}">${item.content}</td>
                <td>
					<div style="display: flex; flex-direction: column; gap: var(--spacing-xs);"> 
						<!-- ç¬¬ä¸€è¡Œï¼šæƒ…æ„Ÿç±»å‹ -->
                        <div style="display: flex; align-items: center; gap: var(--spacing-xs);">
							<label style="flex-shrink: 0; font-size: 0.8rem;">ç±»å‹:</label>
							${currentToneSelectHtml}
						</div>
                        <!-- ç¬¬äºŒè¡Œï¼šæƒé‡ -->
                        <div style="display: flex; align-items: center; gap: var(--spacing-xs);">
                            <label style="flex-shrink: 0; font-size: 0.8rem;">å¼ºåº¦:</label>
                            ${intensityInputHtml}
                        </div>
					</div>
				</td>
				<td style="width: 8%;">
					<button class="btn btn-sm btn-secondary btn-fine-tune" data-line-id="${item.line_id}" title="ç”ŸæˆéŸ³é¢‘æˆ–å¾®è°ƒéŸ³é¢‘">ç”Ÿæˆ</button>
					<button class="btn-play audio-player-btn disabled" title="æ’­æ”¾" disabled>â–¶</button>
				</td>
			</tr>
			<tr id="proofread-row-${item.line_id}" class="proofread-detail-row" style="display: none;">
				<td colspan="7"> <!-- è·¨è¶Šæ‰€æœ‰åˆ— -->
					<div class="proofread-content">
						<span class="proofread-label">åŸæ–‡æ ¡å¯¹:</span>
						<pre class="original-text-display"></pre>
					</div>
				</td>
			</tr>`;
			tableHTML += `<tr id="proofread-row-${item.line_id}" class="proofread-detail-row" style="display: none;">
				<td colspan="7">
					<div class="proofread-content-wrapper">
						<span class="proofread-label">åŸæ–‡æ ¡å¯¹:</span>
						<pre class="original-text-display"></pre>
					</div>
				</td>
			</tr>`;
		});
		dom.contentTableBody.innerHTML = tableHTML;
		
		if (state.isProofreadMode) {
			state.novelData.forEach(item => updateSingleProofreadDisplay(item.line_id));
		}
	}

	async function checkAllPlayableFiles() {
		const startTime = performance.now();
		console.log('DEBUG: checkAllPlayableFiles å¼€å§‹è¿è¡Œ...');
		if (state.novelData.length === 0 || state.selectedChapterPaths.length !== 1) return;
		setStatus('æ­£åœ¨æ£€æŸ¥å·²ç”Ÿæˆçš„æ–‡ä»¶...', 'info');

		const path = state.selectedChapterPaths[0];
		
        if (!path) {
            console.error("Path is undefined or empty for the selected chapter.");
            return; // å®‰å…¨é€€å‡º
        }
		const pathParts = path.replace('.json', '').split(/[/\\]/);
		const originalChapterTitle = pathParts[pathParts.length - 1];
		const currentChapterName = sanitizeTitleForFilename(originalChapterTitle);

		const expectedFileNamesMap = new Map(); // ä½¿ç”¨ Map å­˜å‚¨ line_id -> filename
		for (let i = 0; i < state.novelData.length; i++) {
			const item = state.novelData[i];
            if (!item.line_id) { // å¦‚æœç¼ºå°‘ line_idï¼Œè·³è¿‡æ­¤è¡Œ
                console.warn(`WARN: æ£€æŸ¥æ–‡ä»¶æ—¶å‘ç°ç¼ºå°‘ line_id çš„è¡Œï¼Œå¯èƒ½æ•°æ®æœªåŠ è½½æˆ–ä¿å­˜ã€‚è¡Œå·: ${i}`);
                continue; // è·³è¿‡æ­¤è¡Œï¼Œä¸æ£€æŸ¥éŸ³é¢‘æ–‡ä»¶
            }

            const speaker = item.speaker;
            const timbre = item.timbre_override || state.characterMapping[item.speaker];
            
            if (speaker && timbre) {
                const safeSpeaker = sanitizeForFilename(speaker);
                const safeTimbre = sanitizeForFilename(timbre);
                // ä½¿ç”¨ item.line_id ä½œä¸ºæ–‡ä»¶åçš„ä¸€éƒ¨åˆ†
                expectedFileNamesMap.set(item.line_id, `${item.line_id}-${safeSpeaker}-${safeTimbre}.wav`);
            }
		}

		state.generatedFiles = {}; // æ¸…ç©ºä¹‹å‰çš„çŠ¶æ€
		const allFileNamesToCheck = Array.from(expectedFileNamesMap.values());
		const BATCH_SIZE = 500; // æ¯æ‰¹æ¬¡å¤„ç†500æ¡
		const BATCH_DELAY_MS = 100; // æ¯æ‰¹æ¬¡ä¹‹é—´çš„å»¶è¿Ÿ

		let allExistingFilesSet = new Set();
		let totalChecked = 0;

		try {
			for (let i = 0; i < allFileNamesToCheck.length; i += BATCH_SIZE) {
				const batchFileNames = allFileNamesToCheck.slice(i, i + BATCH_SIZE);
				
				setStatus(`æ­£åœ¨æ£€æŸ¥æ–‡ä»¶... (${totalChecked}/${allFileNamesToCheck.length})`, 'info');

				const payload = {
					novel_name: state.novelName,
					chapter_name: currentChapterName,
					filenames: batchFileNames
				};
				const result = await fetchFromServer('/api/check_files_exist', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(payload)
				});

				if (result.existing_files) {
					result.existing_files.forEach(file => allExistingFilesSet.add(file));
				}
				totalChecked += batchFileNames.length;

				// æ‰¹æ¬¡ä¹‹é—´è¿›è¡Œå»¶è¿Ÿ
				if (i + BATCH_SIZE < allFileNamesToCheck.length) {
					await new Promise(resolve => setTimeout(resolve, BATCH_DELAY_MS));
				}
			}

			// æ›´æ–°UI
			for(let i = 0; i < state.novelData.length; i++) {
                const item = state.novelData[i];
                if (!item.line_id) continue; // ç¡®ä¿æœ‰ line_id æ‰èƒ½æ›´æ–° UI

				const currentRow = document.getElementById(`content-row-${item.line_id}`); // ä¿®æ”¹ ID é€‰æ‹©å™¨
				if (!currentRow) continue;
				
				const playBtn = currentRow.querySelector('.btn-play');
				
				const expectedFileName = expectedFileNamesMap.get(item.line_id); //  ä½¿ç”¨ line_id è·å–æ–‡ä»¶å
				const fileExists = expectedFileName && allExistingFilesSet.has(expectedFileName);

				if (playBtn) {
					playBtn.disabled = !fileExists;
					playBtn.classList.toggle('playable', fileExists);
				}
				if (fileExists) {
					state.generatedFiles[item.line_id] = expectedFileName; // ä½¿ç”¨ line_id ä½œä¸º key
				}
				if (fileExists) {
					playBtn.classList.remove('disabled');
				} else {
					playBtn.classList.add('disabled');
				}
			}
			setStatus(`æ£€æŸ¥å®Œæ¯•ï¼Œæ‰¾åˆ° ${allExistingFilesSet.size} ä¸ªåŒ¹é…æ–‡ä»¶ã€‚`, 'success');

		} catch (error) {
			setStatus(`æ£€æŸ¥æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, 'error');
			document.querySelectorAll('.btn-play').forEach(btn => {
				btn.disabled = true;
				btn.classList.remove('playable');
			});
		} finally {
			const endTime = performance.now();
			console.log(`DEBUG: checkAllPlayableFiles è¿è¡Œç»“æŸï¼Œæ€»è€—æ—¶: ${(endTime - startTime).toFixed(2)} æ¯«ç§’ã€‚`);
		}
	}
	
    // åˆ‡æ¢æ ¡å¯¹æ¨¡å¼
    async function toggleProofreadMode() {
        const enteringMode = !state.isProofreadMode;
        state.isProofreadMode = enteringMode;
        const toggleBtn = document.getElementById('toggleProofreadModeBtn');
        toggleBtn.classList.toggle('filter-btn-active', enteringMode);

        if (enteringMode) {
            // æ ¸å¿ƒï¼šæ¯æ¬¡å¼€å¯æ—¶é‡ç½®çŠ¶æ€
            state.chapterSourceTextConsumedIndex = 0; 
            
            if (state.chapterSourceText && state.novelData.length > 0) {
                 // å¦‚æœæ•°æ®å·²è¿‡æœŸï¼Œæˆ–é¦–æ¬¡å¼€å¯ï¼Œåˆ™è¿›è¡Œè®¡ç®—
                if (state.isProofreadDataStale || state.proofreadOriginalFragments.length === 0) {
                    await recalculateAndDisplayProofread(); //åœ¨æ­¤å¤„è§¦å‘è®¡ç®—
                }
            } else {
                setStatus('ç« èŠ‚åŸæ–‡æˆ–è¯­å¥ä¸ºç©ºï¼Œæ— æ³•å¼€å¯æ ¡å¯¹æ¨¡å¼ã€‚', 'warning');
                state.isProofreadMode = false; // æ— æ³•åŒ¹é…åˆ™å¼ºåˆ¶å…³é—­
                toggleBtn.classList.remove('filter-btn-active');
            }
        } else {
            // é€€å‡ºæ¨¡å¼æ—¶ï¼Œå¦‚æœæ•°æ®å·²è¿‡æœŸï¼Œä¸‹æ¬¡è¿›å…¥æ—¶ä¼šé‡æ–°è®¡ç®—
            // ä¿æŒ isProofreadDataStale çŠ¶æ€ä¸å˜
        }

        updateProofreadModeDisplay(); 
        setStatus(`æ ¡å¯¹æ¨¡å¼å·²${state.isProofreadMode ? 'å¼€å¯' : 'å…³é—­'}ã€‚`, 'info');
    }
	
    async function refreshTableStructure() {
        //renderContentTable();
        
        await checkAllPlayableFiles();
        
        // å¦‚æœæ ¡å¯¹æ¨¡å¼å¼€å¯ï¼Œç¡®ä¿æ–°åˆ›å»ºçš„è¡Œæ˜¾ç¤ºå‡ºæ¥ï¼Œä½†æ ¡å¯¹å†…å®¹ä¸åˆ·æ–°
        if (state.isProofreadMode) {
             updateProofreadModeDisplay();
        }
        
        setStatus('è¡¨æ ¼ç»“æ„å’Œæ’­æ”¾çŠ¶æ€å·²æ›´æ–°ã€‚', 'info');
    }
	
    async function recalculateAndDisplayProofread() {
        if (!state.isProofreadMode) return;
        
        setStatus('æ­£åœ¨å…¨å±€åŒ¹é…åŸæ–‡ä¸è¯­å¥ï¼Œè¯·ç¨å€™...', 'info');
        // é˜»å¡æ€§ç­‰å¾…ï¼Œå› ä¸ºè¿™æ˜¯ç”¨æˆ·ç‚¹å‡»è§¦å‘çš„ï¼Œéœ€è¦ç­‰å¾…ç»“æœ
        try {
            await preProcessOriginalTextForProofreading(); 
            updateProofreadModeDisplay();
            state.isProofreadDataStale = false;
            setStatus('æ ¡å¯¹ç»“æœå·²åˆ·æ–°ã€‚', 'success');
        } catch (e) {
             setStatus(`æ ¡å¯¹åˆ·æ–°å¤±è´¥: ${e.message}`, 'error');
        }
	}

    // æ›´æ–°æ‰€æœ‰è¡Œçš„æ ¡å¯¹æ˜¾ç¤º
    function updateProofreadModeDisplay() {
        state.novelData.forEach(item => {
            const proofreadRow = document.getElementById(`proofread-row-${item.line_id}`);
            if (proofreadRow) {
                proofreadRow.style.display = state.isProofreadMode ? 'table-row' : 'none';
                if (state.isProofreadMode) {
                    updateSingleProofreadDisplay(item.line_id);
                }
            }
        });
    }

    function isChinesePunctuation(char) {
        const chinesePunctuation = 'ã€‚ï¼Œã€ï¼›ï¼šï¼Ÿï¼â€”â€¦â€œâ€ã€Šã€‹â€˜â€™ï¼ˆï¼‰ã€ã€‘{}Â·';
        return chinesePunctuation.includes(char) || (char >= '\u3000' && char <= '\u303F') || (char >= '\uFF00' && char <= '\uFFEF');
    }

    // åˆ¤æ–­å­—ç¬¦æ˜¯å¦ä¸ºæ ‡ç‚¹ç¬¦å· (ä¸­è‹±æ–‡)
    function isPunctuation(char) {
        const englishPunctuation = ',.!?:;\'"-/\\`~@#$%^&*()_+={}[]|<>ã€€'; 
        return (char && (englishPunctuation.includes(char) || isChinesePunctuation(char))); 
    }

    // æ¸…ç†æ–‡æœ¬ï¼Œåªä¿ç•™ä¸­è‹±æ–‡å’Œæ•°å­—ï¼Œå¹¶è½¬å°å†™
    function cleanTextForMatching(text) {
        if (!text) return '';
        // ç§»é™¤æ‰€æœ‰éå­—æ¯ã€éæ•°å­—ã€éä¸­æ–‡çš„å­—ç¬¦ï¼Œç„¶åè½¬å°å†™
        // è¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼ä¿ç•™äº†ä¸­æ–‡å­—ç¬¦ \u4e00-\u9fa5
        return text.replace(/[^\p{L}\p{N}\u4e00-\u9fa5]/gu, '').toLowerCase(); 
    }
	
    function formatUnmatchedFragmentHtml(fragment, statementText) {
        if (!fragment || !fragment.text) return '';

        // ä½¿ç”¨ diffTexts å¯¹æœªåŒ¹é…çš„åŸæ–‡ç‰‡æ®µå’Œå½“å‰è¯­å¥è¿›è¡Œé€å­—æ¯”å¯¹
        const diffedContent = diffTexts(statementText, fragment.text);

        return (
            `<div style="display:flex; align-items:center; gap:var(--spacing-xs); margin-top:var(--spacing-xs);">` +
            `<span style="color:var(--danger-color); font-style:italic;">ï¼ˆå­˜åœ¨æœªå¤„ç†æ–‡å­—ï¼Œä¸åŸæ–‡æ¯”å¯¹ç»“æœå¦‚ä¸‹ï¼‰</span>` +
            `<button class="btn btn-secondary btn-view-fragment" ` +
            `data-start="${fragment.startIndex}" ` + // ç»å¯¹èµ·å§‹ç´¢å¼•
            `data-end="${fragment.endIndex}" ` +     // ç»å¯¹ç»“æŸç´¢å¼•
            `title="æŸ¥çœ‹åŸæ–‡å¹¶é«˜äº®æœªå¤„ç†æ–‡å­—ç‰‡æ®µ" style="height:24px; padding:0 8px; font-size:0.8rem;">` +
            `ğŸ”</button>` +
            `</div>` +
            `<span style="color:var(--danger-color);">${diffedContent}</span>` // ä½¿ç”¨ diffedContent
        );
    }
	
    // åœ¨åŸå§‹æ–‡æœ¬ä¸­æ‰¾åˆ°æ¸…ç†åå­ä¸²çš„æ‰€æœ‰åŒ¹é…ï¼Œè¿”å›ä¸€ä¸ª {startIndex, endIndex} æ•°ç»„
    function findCleanedSubstringIndex(originalText, cleanedOriginalText, cleanedSubstring) {
        if (!cleanedSubstring || !cleanedOriginalText) return [];
        
        let allMatches = [];
        let searchStartIndexInCleaned = 0;

        while (true) {
            // 1. åœ¨æ¸…ç†åçš„æ–‡æœ¬ä¸­æ‰¾åˆ°åŒ¹é…çš„èµ·å§‹ç´¢å¼•
            const matchStartIndexInCleaned = cleanedOriginalText.indexOf(cleanedSubstring, searchStartIndexInCleaned);

            if (matchStartIndexInCleaned === -1) break;

            // --- 2. å°†æ¸…ç†åçš„èµ·å§‹ç´¢å¼•æ˜ å°„å›åŸå§‹æ–‡æœ¬ ---
            let originalStart = -1;
            let originalEnd = -1;
            let cleanedPointer = 0; 
            
            // æ˜ å°„èµ·å§‹ç‚¹
            for (let i = 0; i < originalText.length; i++) {
                const charOriginal = originalText[i];
                if (cleanTextForMatching(charOriginal)) {
                    if (cleanedPointer === matchStartIndexInCleaned) {
                        originalStart = i;
                        break;
                    }
                    cleanedPointer++;
                }
            }

            // æ˜ å°„ç»“æŸç‚¹å’Œå‘åæ‰©å±• (ä¸ä¹‹å‰é€»è¾‘ç±»ä¼¼)
            if (originalStart !== -1) {
                originalEnd = originalStart;
                let tempCleanedStatementToConsume = cleanedSubstring;
                
                for (let i = originalStart; i < originalText.length && tempCleanedStatementToConsume.length > 0; i++) {
                    const charOriginal = originalText[i];
                    const cleanedCharOriginal = cleanTextForMatching(charOriginal);
                    
                    if (cleanedCharOriginal && cleanedCharOriginal === tempCleanedStatementToConsume[0]) {
                        tempCleanedStatementToConsume = tempCleanedStatementToConsume.substring(1);
                    }
                    originalEnd = i + 1;
                }
                
                // è¿™é‡Œçš„ç›®æ ‡æ˜¯è®©åŒ¹é…ç‰‡æ®µâ€œåå™¬â€å®ƒç›´æ¥çš„å°¾éƒ¨æ ‡ç‚¹ï¼Œè€Œä¸æ˜¯è®©è¿™äº›æ ‡ç‚¹å½¢æˆæ–°çš„ unmatched ç‰‡æ®µã€‚
                let tempEnd = originalEnd;
                while (tempEnd < originalText.length) {
                    const char = originalText[tempEnd];
                    if (isPunctuation(char) || char.trim() === '') {
                        tempEnd++;
                    } else {
                        break; // é‡åˆ°éæ ‡ç‚¹/éç©ºç™½å­—ç¬¦ï¼Œåœæ­¢æ‰©å±•
                    }
                }
                originalEnd = tempEnd; // æ›´æ–°æœ€ç»ˆçš„ originalEnd
                
                // è®°å½•åŒ¹é…å¹¶å‡†å¤‡ä¸‹ä¸€æ¬¡æœç´¢
                allMatches.push({ startIndex: originalStart, endIndex: originalEnd });
                
                // è®¾ç½®ä¸‹ä¸€æ¬¡æœç´¢çš„èµ·å§‹ç‚¹ï¼šåœ¨æ¸…ç†åæ–‡æœ¬ä¸­ä»å½“å‰åŒ¹é…ä¹‹åå¼€å§‹
                searchStartIndexInCleaned = matchStartIndexInCleaned + cleanedSubstring.length; 
            } else {
                break; // å‡ºç°æ„å¤–é”™è¯¯ï¼Œåœæ­¢æœç´¢
            }
        }
        return allMatches;
    }
	
	function runDynamicProgramming(matches) {
        if (matches.length === 0) return [];
        
        // 1. æŒ‰ç»“æŸä½ç½®æ’åº
        matches.sort((a, b) => a.endIndex - b.endIndex);
        
        // 2. DP æ•°ç»„å’Œè·¯å¾„è¿½è¸ª
        const DP = new Array(matches.length).fill(0);
        // Path æ•°ç»„å­˜å‚¨çš„æ˜¯è¾¾åˆ°å½“å‰DPå€¼æ‰€åŒ…å«çš„æ‰€æœ‰åŒ¹é…ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªåŒ¹é…å¯¹è±¡æ•°ç»„
        const Path = new Array(matches.length).fill(null).map(() => []); // åˆå§‹åŒ–ä¸ºæ•°ç»„ï¼Œé¿å…null.concaté—®é¢˜
        
        for (let i = 0; i < matches.length; i++) {
            const currentMatch = matches[i];
            
            // é€‰é¡¹ä¸€ï¼šä¸é€‰æ‹©å½“å‰åŒ¹é…
            let maxWeight = (i > 0) ? DP[i - 1] : 0;
            let bestPath = (i > 0) ? Path[i - 1] : [];
            
            // é€‰é¡¹äºŒï¼šé€‰æ‹©å½“å‰åŒ¹é…
			let j = -1; // ç”¨äºè®°å½•èƒ½å¤Ÿä¸å½“å‰åŒ¹é… `currentMatch` è¡”æ¥çš„æœ€ä½³å‰ä¸€ä¸ªåŒ¹é…çš„ç´¢å¼•
			for (let k = i - 1; k >= 0; k--) {
				const prevMatch = matches[k]; // ä¿®æ­£ï¼šå°† sequencedPotentialMatches[k] æ”¹ä¸º matches[k]
				
				// å…³é”®ä¿®æ­£ï¼šå¿…é¡»æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶
				// 1. åŸæ–‡ä½ç½®éé‡å ï¼šå‰ä¸€ä¸ªåŒ¹é…çš„ç»“æŸä½ç½®å¿…é¡»å°äºç­‰äºå½“å‰åŒ¹é…çš„èµ·å§‹ä½ç½®
				// 2. è¯­å¥é¡ºåºä¸å€’ç½®ï¼šå‰ä¸€ä¸ªåŒ¹é…çš„ novelDataIndex å¿…é¡»å°äºç­‰äºå½“å‰åŒ¹é…çš„ novelDataIndex
				if (prevMatch.endIndex <= currentMatch.startIndex &&  
					prevMatch.novelDataIndex <= currentMatch.novelDataIndex) 
				{
					j = k;
					break; // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ï¼Œå› ä¸ºæ˜¯æŒ‰ endIndex æ’åºï¼Œè¿™ä¸ª j æä¾›äº†æœ€ä¼˜çš„ prevDP
				}
			}

            let weightWithCurrent = currentMatch.weight;
            // æ„å»ºåŒ…å«å½“å‰åŒ¹é…çš„è·¯å¾„
            let pathWithCurrent = [{ 
                lineId: currentMatch.lineId, 
                startIndex: currentMatch.startIndex, 
                endIndex: currentMatch.endIndex,
                novelDataIndex: currentMatch.novelDataIndex // å¯ä»¥åœ¨è·¯å¾„ä¸­ä¿ç•™ï¼Œæ–¹ä¾¿è°ƒè¯•æˆ–åç»­å¤„ç†
            }];
            
            if (j !== -1) {
                // å¦‚æœå­˜åœ¨å‰ä¸€ä¸ªåŒ¹é…ï¼Œåˆ™å°†å‰ä¸€ä¸ªåŒ¹é…çš„è·¯å¾„ä¸å½“å‰åŒ¹é…è¿æ¥èµ·æ¥
                weightWithCurrent += DP[j];
                pathWithCurrent = Path[j].concat(pathWithCurrent); // å°†å‰ä¸€ä¸ªè·¯å¾„æ¥åœ¨å‰é¢
            }
            
            // æ¯”è¾ƒå¹¶é€‰æ‹©æœ€ä¼˜
            if (weightWithCurrent > maxWeight) {
                maxWeight = weightWithCurrent;
                bestPath = pathWithCurrent;
            }
            
            DP[i] = maxWeight;
            Path[i] = bestPath;
        }

        // 3. è¿”å›æœ€ç»ˆé€‰å®šçš„åŒ¹é…é›†ï¼ˆæŒ‰èµ·å§‹ä½ç½®æ’åºï¼‰
        const finalMatches = matches.length > 0 ? Path[matches.length - 1] : [];
        // å†æ¬¡ç¡®ä¿æœ€ç»ˆç»“æœæŒ‰èµ·å§‹ä½ç½®æ’åºï¼Œä»¥æ­£ç¡®ç”Ÿæˆç‰‡æ®µ
        return finalMatches.sort((a, b) => a.startIndex - b.startIndex);
    }
	
    function mergeAdjacentPunctuationFragments(fragments) {
        if (fragments.length === 0) return [];

        const mergedFragments = [];
        let previousFragment = null;

        for (let i = 0; i < fragments.length; i++) {
            const currentFragment = fragments[i];

            // æ£€æŸ¥å½“å‰ç‰‡æ®µæ˜¯å¦æ˜¯çº¯æ ‡ç‚¹æˆ–ç©ºç™½
            const isPurePunctuationOrWhitespace = currentFragment.type === 'unmatched' && 
                                                 currentFragment.text.split('').every(char => isPunctuation(char) || char.trim() === '');
            
            if (isPurePunctuationOrWhitespace && previousFragment) {
                // å¦‚æœæ˜¯çº¯æ ‡ç‚¹æˆ–ç©ºç™½ç‰‡æ®µï¼Œä¸”å‰é¢æœ‰ç‰‡æ®µï¼Œåˆ™å°è¯•åˆå¹¶
                
                // å°†å½“å‰çº¯æ ‡ç‚¹ç‰‡æ®µçš„æ–‡æœ¬å’ŒèŒƒå›´åˆå¹¶åˆ°å‰ä¸€ä¸ªç‰‡æ®µä¸­
                previousFragment.text += currentFragment.text;
                previousFragment.endIndex = currentFragment.endIndex;
                // æ³¨æ„ï¼šè¿™é‡Œä¸éœ€è¦æ”¹å˜ previousFragment çš„ type å’Œ lineIdï¼Œå› ä¸ºçº¯æ ‡ç‚¹ç‰‡æ®µçš„å½’å±åº”éšå…¶å‰çš„æ–‡æœ¬ã€‚
            } else {
                // å¦‚æœä¸æ˜¯çº¯æ ‡ç‚¹ç‰‡æ®µï¼Œæˆ–è€…å‰é¢æ²¡æœ‰ç‰‡æ®µï¼Œåˆ™å°†å½“å‰ç‰‡æ®µåŠ å…¥åˆå¹¶æ•°ç»„
                // åŒæ—¶æ›´æ–° previousFragment ä¸ºå½“å‰ç‰‡æ®µ
                mergedFragments.push(currentFragment);
                previousFragment = currentFragment;
            }
        }
        return mergedFragments;
    }
    
    async function preProcessOriginalTextForProofreading() {
        // é‡ç½®çŠ¶æ€
        state.proofreadMatches.clear();
        state.proofreadOriginalFragments = [];
        state.lineIdToDisplayFragmentsMap = new Map();

        if (!state.chapterSourceText || state.novelData.length === 0) return;

        const originalText = state.chapterSourceText;
        const cleanedOriginalText = cleanTextForMatching(originalText);
        
        // --- 1. é¢„è®¡ç®—æ‰€æœ‰æ½œåœ¨åŒ¹é… (Potential Matches) ---
        // å¢åŠ  novelDataIndex å­—æ®µï¼Œç”¨äºåŠ¨æ€è§„åˆ’ä¸­åˆ¤æ–­è¯­å¥é¡ºåº
        let potentialMatches = []; // { lineId, startIndex, endIndex, weight, novelDataIndex }
        
        // éå† novelData æ—¶è·å–ç´¢å¼•
        for (let novelDataIndex = 0; novelDataIndex < state.novelData.length; novelDataIndex++) { // ä¿®æ”¹æ­¤å¤„ï¼Œè·å–ç´¢å¼•
            const item = state.novelData[novelDataIndex];
            const currentStatement = item.content || '';
            const cleanedStatement = cleanTextForMatching(currentStatement);

            if (!cleanedStatement) continue;
            
            // æ‰¾åˆ°æ‰€æœ‰åŒ¹é…
            const allMatches = findCleanedSubstringIndex(originalText, cleanedOriginalText, cleanedStatement);
            
            for (const match of allMatches) {
                // æƒå€¼ï¼šåŒ¹é…åˆ°çš„æ¸…ç†åå­—ç¬¦æ•° (æœ€å¤§é™åº¦åˆ©ç”¨åŒ¹é…æˆåŠŸçš„å­—ç¬¦)
                const weight = cleanedStatement.length; 

                potentialMatches.push({
                    lineId: item.line_id,
                    startIndex: match.startIndex,
                    endIndex: match.endIndex,
                    weight: weight,
                    novelDataIndex: novelDataIndex // æ·»åŠ  novelDataIndex
                });
            }
            await new Promise(resolve => setTimeout(resolve, 1)); // é¿å…é˜»å¡UI
        }

        // --- 2. é¡ºåºçº¦æŸåŒ¹é…ï¼ˆæ›¿æ¢ä¸ºåŠ¨æ€è§„åˆ’å…¨å±€æœ€ä¼˜é€‰æ‹©ï¼‰---
        // ç›®æ ‡ï¼šç¡®ä¿åŒ¹é…ç»“æœä¸¥æ ¼æŒ‰ç…§ state.novelData çš„é¡ºåºæ’åˆ—ï¼Œä¸”ä½ç½®ä¸é‡å ã€‚
        // ä½¿ç”¨åŠ¨æ€è§„åˆ’ç®—æ³•ä»æ‰€æœ‰æ½œåœ¨åŒ¹é…ä¸­é€‰æ‹©æœ€ä¼˜çš„ã€éé‡å ä¸”è¯­å¥é¡ºåºæ­£ç¡®çš„åŒ¹é…é›†ã€‚
        const finalSelectedMatches = runDynamicProgramming(potentialMatches); // è°ƒç”¨åŠ¨æ€è§„åˆ’å‡½æ•°
        
        // --- 3. åŸæ–‡åˆ‡å‰²ä¸ç‰‡æ®µç”Ÿæˆï¼ˆä¿®å¤åŸæ–‡ç¼ºå¤±å’Œç´¢å¼•é”™è¯¯ï¼‰---
        
        // finalSelectedMatches å·²ç»æ˜¯æŒ‰è¯­å¥é¡ºåºï¼ˆå³ novelData é¡ºåºï¼‰ä¸”æŒ‰åŸæ–‡ä½ç½®é¡ºåºæ’åˆ—çš„
        const finalSortedMatches = finalSelectedMatches; 
        
        let currentOriginalPointerForFragment = 0; // ç”¨äºç‰‡æ®µç”Ÿæˆï¼Œå¿…é¡»ä»å¤´å¼€å§‹
        
        for (const match of finalSortedMatches) {	
            // *** ä¿®å¤é—®é¢˜ 1: ç§»é™¤ skipIndex é€»è¾‘ï¼Œä¿è¯æ‰€æœ‰æœªåŒ¹é…éƒ¨åˆ†éƒ½è¢«åˆ›å»ºä¸ºç‰‡æ®µ ***
            
            // 1. å¤„ç†æœªåŒ¹é…çš„å‰ç¼€ (å¤¹å¿ƒéƒ¨åˆ†)
            if (match.startIndex > currentOriginalPointerForFragment) { 
                state.proofreadOriginalFragments.push({
                    type: 'unmatched',
                    lineId: null,
                    // æˆªå–ä¸Šä¸€ä¸ªåŒ¹é…ç»“æŸç‚¹åˆ°å½“å‰åŒ¹é…èµ·å§‹ç‚¹ä¹‹é—´çš„æ‰€æœ‰æ–‡æœ¬
                    text: originalText.substring(currentOriginalPointerForFragment, match.startIndex), 
                    startIndex: currentOriginalPointerForFragment, 
                    endIndex: match.startIndex      
                });
            }
            
            // 2. å¤„ç†åŒ¹é…çš„ç‰‡æ®µ
            state.proofreadOriginalFragments.push({
                type: 'match',
                lineId: match.lineId,
                text: originalText.substring(match.startIndex, match.endIndex),
				startIndex: match.startIndex, 
				endIndex: match.endIndex
            });
            
            // æ›´æ–°åˆ‡å‰²æŒ‡é’ˆ
            currentOriginalPointerForFragment = match.endIndex;
        }

        // 3. å¤„ç†å‰©ä½™çš„æœªåŒ¹é…åç¼€
        if (currentOriginalPointerForFragment < originalText.length) {
            state.proofreadOriginalFragments.push({
                type: 'unmatched',
                lineId: null,
                text: originalText.substring(currentOriginalPointerForFragment),
				startIndex: currentOriginalPointerForFragment, 
				endIndex: originalText.length // åº”è¯¥æ˜¯åŸæ–‡çš„é•¿åº¦
            });
        }
		
        state.proofreadOriginalFragments = mergeAdjacentPunctuationFragments(state.proofreadOriginalFragments);
		
        // --- 4. ä¼˜åŒ–åçš„ç‰‡æ®µåˆ†é…é€»è¾‘ ---
        state.lineIdToDisplayFragmentsMap = new Map();
        state.novelData.forEach(item => {
            state.lineIdToDisplayFragmentsMap.set(item.line_id, []);
        });

        const novelDataLineIdToIndexMap = new Map(state.novelData.map((item, index) => [item.line_id, index]));
        const novelDataIndexToLineIdMap = new Map(state.novelData.map((item, index) => [index, item.line_id]));


        // ç¬¬ä¸€æ¬¡éå†ï¼šä¼˜å…ˆåˆ†é… 'match' å’Œ 'preceding_unmatched'
        // 'following_unmatched' å’Œ 'isolated_unmatched' æš‚æ—¶ä¸åˆ†é…
        const unassignedFragmentsQueue = []; // é˜Ÿåˆ—ï¼Œå­˜æ”¾å¾…å¤„ç†çš„ unmatched ç‰‡æ®µ

        for (let i = 0; i < state.proofreadOriginalFragments.length; i++) {
            const currentFragment = state.proofreadOriginalFragments[i];

            if (currentFragment.type === 'match') {
                const lineId = currentFragment.lineId;
                if (state.lineIdToDisplayFragmentsMap.has(lineId)) {
                    state.lineIdToDisplayFragmentsMap.get(lineId).push({
                        fragment: currentFragment,
                        ownershipType: 'match'
                    });
                }
            } else if (currentFragment.type === 'unmatched') {
                let assignedToPrecedingMatch = false;
                let precedingMatch = null;
                // æŸ¥æ‰¾å½“å‰ unmatched ç‰‡æ®µä¹‹å‰æœ€è¿‘çš„ match ç‰‡æ®µ
                for (let j = finalSortedMatches.length - 1; j >= 0; j--) {
                    if (finalSortedMatches[j].endIndex <= currentFragment.startIndex) {
                        precedingMatch = finalSortedMatches[j];
                        break;
                    }
                }

                if (precedingMatch) {
                    const precedingMatchNovelDataIndex = novelDataLineIdToIndexMap.get(precedingMatch.lineId);
                    // æ£€æŸ¥æ­¤ unmatched ç‰‡æ®µæ˜¯å¦ä½äºå‰ä¸€ä¸ªåŒ¹é…è¯­å¥å’Œä¸‹ä¸€ä¸ªåŒ¹é…è¯­å¥ä¹‹é—´
                    // æˆ–è€…æ˜¯å¦åœ¨å°è¯´æœ«å°¾
                    let succeedingMatch = null;
                    for (let j = 0; j < finalSortedMatches.length; j++) {
                        if (finalSortedMatches[j].startIndex >= currentFragment.endIndex) {
                            succeedingMatch = finalSortedMatches[j];
                            break;
                        }
                    }

                    if (succeedingMatch) {
                        const succeedingMatchNovelDataIndex = novelDataLineIdToIndexMap.get(succeedingMatch.lineId);
                        if (succeedingMatchNovelDataIndex === precedingMatchNovelDataIndex + 1) {
                            // è¿™æ˜¯ä¸€ä¸ªå¤¹åœ¨ä¸¤ä¸ªè¿ç»­åŒ¹é…è¯­å¥ä¹‹é—´çš„ unmatched ç‰‡æ®µ
                            // æ­¤æ—¶å®ƒåº”è¯¥å½’å±äºâ€œä¸‹ä¸€å¥â€ (å³ succeedingMatch å¯¹åº”çš„è¯­å¥)ï¼Œä½œä¸ºå…¶ preceding_unmatched
                            const assignedLineId = succeedingMatch.lineId;
                            if (state.lineIdToDisplayFragmentsMap.has(assignedLineId)) {
                                state.lineIdToDisplayFragmentsMap.get(assignedLineId).push({
                                    fragment: currentFragment,
                                    ownershipType: 'preceding_unmatched'
                                });
                                assignedToPrecedingMatch = true; // æ ‡è®°å·²åˆ†é…ï¼Œä¸éœ€è¦å†æ·»åŠ åˆ°é˜Ÿåˆ—
                            }
                        }
                        // else { å¦åˆ™ï¼Œå®ƒå¯èƒ½æ˜¯ä¸¤ä¸ªä¸è¿ç»­åŒ¹é…è¯­å¥ä¹‹é—´çš„ï¼Œæˆ–æ›´å¤æ‚çš„ï¼Œæš‚æ—¶æ”¾å…¥é˜Ÿåˆ— }
                    }
                    // else { å¦‚æœæ²¡æœ‰ succeedingMatchï¼Œè¯´æ˜åœ¨å°è¯´æœ«å°¾ï¼Œä¹Ÿæš‚æ—¶æ”¾å…¥é˜Ÿåˆ— }
                }

                if (!assignedToPrecedingMatch) {
                    // æ²¡æœ‰è¢«ä½œä¸º 'preceding_unmatched' åˆ†é…ï¼Œæ”¾å…¥é˜Ÿåˆ—ç­‰å¾…ç¬¬äºŒæ¬¡åˆ†é…
                    unassignedFragmentsQueue.push(currentFragment);
                }
            }
        }

        // ç¬¬äºŒæ¬¡éå†ï¼šå¤„ç†é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰ unassignedFragmentsï¼Œå°è¯•æ‰¾åˆ°å…¶æœ€ç»ˆå½’å±
        // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šå¦‚æœèƒ½è¢«ã€ä¸‹ä¸€æ¡æœªåŒ¹é…çš„è¯­å¥ã€‘å€Ÿç”¨ï¼Œå°±ç»™ä¸‹ä¸€æ¡ï¼Œå¦åˆ™ç»™å‰ä¸€æ¡åŒ¹é…è¯­å¥
        // å…³é”®ç‚¹ï¼šè¦åˆ¤æ–­â€œä¸‹ä¸€æ¡æœªåŒ¹é…çš„è¯­å¥â€æ˜¯å¦å­˜åœ¨ï¼Œå¹¶ä¸”å…¶è‡ªèº«æ²¡æœ‰ match ç‰‡æ®µ
        
        // éå† novelDataï¼Œä¸ºæ¯ä¸ªæ²¡æœ‰ match ç‰‡æ®µçš„è¯­å¥å¯»æ‰¾ unclaimedFragments
        for (let novelDataIndex = 0; novelDataIndex < state.novelData.length; novelDataIndex++) {
            const currentLineId = novelDataIndexToLineIdMap.get(novelDataIndex);
            const currentLineFragments = state.lineIdToDisplayFragmentsMap.get(currentLineId);
            
            // æ£€æŸ¥å½“å‰è¯­å¥æ˜¯å¦å·²ç»æœ‰ 'match' ç‰‡æ®µ
            const hasMatchFragment = currentLineFragments.some(f => f.ownershipType === 'match');

            if (!hasMatchFragment) {
                // å¦‚æœå½“å‰è¯­å¥æ²¡æœ‰è‡ªå·±çš„ 'match' ç‰‡æ®µï¼Œå°è¯•ä»é˜Ÿåˆ—ä¸­å¯»æ‰¾æœ€è¿‘çš„ unmatched ç‰‡æ®µ
                let bestUnmatchedFragmentIndex = -1;
                let minDistance = Infinity;

                // å¯»æ‰¾è·ç¦»å½“å‰è¯­å¥æœ€è¿‘çš„ã€ä¸”æœªè¢«åˆ†é…çš„ unmatched ç‰‡æ®µ
                // è¿™é‡Œæˆ‘ä»¬ç®€åŒ–ä¸€ä¸‹ï¼Œç›´æ¥çœ‹é˜Ÿåˆ—é‡Œçš„ç¬¬ä¸€ä¸ªæˆ–æœ€è¿‘çš„
                if (unassignedFragmentsQueue.length > 0) {
                     // æŸ¥æ‰¾è·ç¦»å½“å‰è¯­å¥å†…å®¹èµ·å§‹ä½ç½®æœ€è¿‘çš„ unmatched ç‰‡æ®µ
                    const currentStatementStartPos = finalSortedMatches.find(m => m.lineId === currentLineId)?.startIndex || -1;
                    
                    if (currentStatementStartPos !== -1) { // å¦‚æœå½“å‰è¯­å¥æœ‰åŒ¹é…ç‚¹ï¼Œä»¥åŒ¹é…ç‚¹ä¸ºåŸºå‡†
                        for (let k = 0; k < unassignedFragmentsQueue.length; k++) {
                            const unfrag = unassignedFragmentsQueue[k];
                            const distance = Math.abs(unfrag.startIndex - currentStatementStartPos);
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestUnmatchedFragmentIndex = k;
                            }
                        }
                    } else { // å¦‚æœå½“å‰è¯­å¥æ²¡æœ‰åŒ¹é…ç‚¹ï¼Œåˆ™ä»¥å…¶åœ¨ novelData ä¸­çš„å‰åä½ç½®æ¥åˆ¤æ–­
                        // å¯»æ‰¾å…¶å‰åæœ€è¿‘çš„åŒ¹é…è¯­å¥çš„ end/start æ¥ç²—ç•¥ä¼°ç®—ä½ç½®
                        let closestPrecedingMatchEnd = -1;
                        for (let k = novelDataIndex - 1; k >= 0; k--) {
                            const prevMatch = finalSortedMatches.find(m => m.lineId === novelDataIndexToLineIdMap.get(k));
                            if (prevMatch) {
                                closestPrecedingMatchEnd = prevMatch.endIndex;
                                break;
                            }
                        }
                        let closestSucceedingMatchStart = originalText.length;
                        for (let k = novelDataIndex + 1; k < state.novelData.length; k++) {
                            const nextMatch = finalSortedMatches.find(m => m.lineId === novelDataIndexToLineIdMap.get(k));
                            if (nextMatch) {
                                closestSucceedingMatchStart = nextMatch.startIndex;
                                break;
                            }
                        }
                        
                        // å¯»æ‰¾ä½äºè¿™ä¸ªç²—ç•¥åŒºé—´å†…çš„ unassignedFragmentsQueue 
                        for (let k = 0; k < unassignedFragmentsQueue.length; k++) {
                            const unfrag = unassignedFragmentsQueue[k];
                            if (unfrag.startIndex >= closestPrecedingMatchEnd && unfrag.endIndex <= closestSucceedingMatchStart) {
                                // æ‰¾åˆ°ä¸€ä¸ªåœ¨æ­¤â€œé€»è¾‘åŒºåŸŸâ€å†…çš„ç‰‡æ®µï¼Œå°†å…¶åˆ†é…
                                bestUnmatchedFragmentIndex = k;
                                break; // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå³å¯
                            }
                        }
                    }
                }


                if (bestUnmatchedFragmentIndex !== -1) {
                    const claimedFragment = unassignedFragmentsQueue.splice(bestUnmatchedFragmentIndex, 1)[0];
                    currentLineFragments.push({
                        fragment: claimedFragment,
                        ownershipType: 'unmatched_for_this_line' // æ–°å¢ä¸€ä¸ªç±»å‹æ¥è¡¨ç¤ºè¿™ç§ä¸“å±åˆ†é…
                    });
                }
            }
        }
        
        // æœ€åï¼Œå°†æ‰€æœ‰å‰©ä½™åœ¨ unassignedFragmentsQueue ä¸­çš„ç‰‡æ®µï¼Œåˆ†é…ç»™å®ƒä»¬æœ€è¿‘çš„åŒ¹é…è¯­å¥
        // å¹¶ä¸”æ£€æŸ¥ï¼Œå¦‚æœä¸€ä¸ªç‰‡æ®µå¤„äºå°è¯´å¼€å¤´æˆ–ç»“å°¾ï¼Œå®ƒåº”è¯¥è¢«åˆ†é…ç»™ç¬¬ä¸€å¥æˆ–æœ€åä¸€å¥ã€‚
        for (const unassignedFragment of unassignedFragmentsQueue) {
            let assignedLineId = null;
            let ownershipType = 'isolated_unmatched'; // é»˜è®¤å€¼

            // å¯»æ‰¾æœ€è¿‘çš„åŒ¹é…ç‰‡æ®µæ¥å†³å®šå½’å±
            let closestMatch = null;
            let minDistance = Infinity;

            for (const match of finalSortedMatches) {
                const distance = Math.min(
                    Math.abs(match.startIndex - unassignedFragment.endIndex), // åŒ¹é…åœ¨å
                    Math.abs(match.endIndex - unassignedFragment.startIndex)  // åŒ¹é…åœ¨å‰
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closestMatch = match;
                }
            }

            if (closestMatch) {
                assignedLineId = closestMatch.lineId;
                // åˆ¤æ–­æ˜¯ 'preceding_unmatched' è¿˜æ˜¯ 'following_unmatched'
                if (unassignedFragment.endIndex <= closestMatch.startIndex) {
                    ownershipType = 'preceding_unmatched';
                } else {
                    ownershipType = 'following_unmatched';
                }
            } else if (state.novelData.length > 0) {
                // å¦‚æœæ²¡æœ‰ä»»ä½•åŒ¹é…ç‰‡æ®µï¼Œåˆ™åˆ†é…ç»™ç¬¬ä¸€å¥
                assignedLineId = state.novelData[0].line_id;
                ownershipType = 'isolated_unmatched';
            }

            if (assignedLineId && state.lineIdToDisplayFragmentsMap.has(assignedLineId)) {
                state.lineIdToDisplayFragmentsMap.get(assignedLineId).push({
                    fragment: unassignedFragment,
                    ownershipType: ownershipType
                });
            } else if (state.novelData.length > 0) { // å¦‚æœå®åœ¨æ‰¾ä¸åˆ°åŒ¹é…ï¼Œä½†æœ‰è¯­å¥ï¼Œå°±ç»™ç¬¬ä¸€å¥
                 state.lineIdToDisplayFragmentsMap.get(state.novelData[0].line_id).push({
                    fragment: unassignedFragment,
                    ownershipType: 'isolated_unmatched'
                });
            }
        }

        // ç¡®ä¿æ¯ä¸ªè¯­å¥å†…éƒ¨çš„ç‰‡æ®µéƒ½æŒ‰å…¶åœ¨åŸæ–‡ä¸­çš„èµ·å§‹ä½ç½®æ’åºï¼Œä»¥ä¾¿æ­£ç¡®æ˜¾ç¤º
        state.lineIdToDisplayFragmentsMap.forEach(fragments => {
            fragments.sort((a, b) => a.fragment.startIndex - b.fragment.startIndex);
        });
    }

    function updateSingleProofreadDisplay(lineId) {
        const item = state.novelData.find(d => d.line_id === lineId);
        const proofreadRow = document.getElementById(`proofread-row-${lineId}`);
        if (!item || !proofreadRow) return;

        const originalTextDisplay = proofreadRow.querySelector('.original-text-display');
        if (!originalTextDisplay) return;

        if (!state.chapterSourceText || !state.isProofreadMode) {
            originalTextDisplay.innerHTML = ''; // éæ ¡å¯¹æ¨¡å¼ä¸‹æ¸…ç©º
            return;
        }
        if (!state.lineIdToDisplayFragmentsMap || state.lineIdToDisplayFragmentsMap.size === 0) {
            originalTextDisplay.innerHTML = '<span style="color:var(--danger-color);">æ ¡å¯¹åŸæ–‡æ•°æ®æœªå‡†å¤‡å¥½æˆ–æ­£åœ¨è®¡ç®—...</span>';
            return;
        }

        const currentStatement = item.content || '';
        let finalDisplayParts = [];

        // è·å–å½“å‰ lineId å¯¹åº”çš„å·²åˆ†é…ç‰‡æ®µ
        const assignedFragments = state.lineIdToDisplayFragmentsMap.get(lineId);
        
        // ================== æ ¸å¿ƒé€»è¾‘ï¼šåˆ¤æ–­å½“å‰è¯­å¥æ˜¯å¦æœ‰ç›´æ¥åŒ¹é… ==================
        const hasDirectMatchFragment = assignedFragments?.some(f => f.ownershipType === 'match');
        // ========================================================================

        if (assignedFragments && assignedFragments.length > 0) {
            assignedFragments.forEach(({ fragment: actualFragment, ownershipType }) => { // <-- **è¿™é‡Œä½¿ç”¨è§£æ„**
                if (ownershipType === 'match') {
                    // åŒ¹é…ç‰‡æ®µæ€»æ˜¯è¿›è¡Œæ¯”å¯¹
                    finalDisplayParts.push(diffTexts(currentStatement, actualFragment.text));
                } 
                else if (['preceding_unmatched', 'following_unmatched', 'isolated_unmatched', 'unmatched_for_this_line'].includes(ownershipType)) {
                    // å¦‚æœå½“å‰è¯­å¥æœ‰ç›´æ¥åŒ¹é…ç‰‡æ®µï¼Œåˆ™ä¸å¯¹è¿™ä¸ª unmatched ç‰‡æ®µè¿›è¡Œ diffTexts æ¯”å¯¹ï¼Œç›´æ¥æ˜¾ç¤ºåŸæ–‡
                    if (hasDirectMatchFragment) {
                        finalDisplayParts.push(
                            `<div style="display:flex; align-items:center; gap:var(--spacing-xs); margin-top:var(--spacing-xs);">` +
                            `<span style="color:var(--danger-color); font-style:italic;">ï¼ˆå­˜åœ¨æœªå¤„ç†æ–‡å­—ï¼ŒåŸæ–‡å¯¹æ¯”ç»“æœå¦‚ä¸‹ï¼‰</span>` + // é€šç”¨æç¤º
                            `<button class="btn btn-secondary btn-view-fragment" ` + 
                            `data-start="${actualFragment.startIndex}" ` + 
                            `data-end="${actualFragment.endIndex}" ` +     
                            `title="æŸ¥çœ‹åŸæ–‡å¹¶é«˜äº®æœªå¤„ç†æ–‡å­—ç‰‡æ®µ" style="height:24px; padding:0 8px; font-size:0.8rem;">` +
                            `ğŸ”</button>` +
                            `</div>` +
                            `<span style="color:var(--danger-color);">${actualFragment.text}</span>` // ç›´æ¥æ˜¾ç¤ºåŸæ–‡ï¼Œä¸æ¯”å¯¹
                        );
                    } else {
                        // å¦‚æœå½“å‰è¯­å¥æ²¡æœ‰ç›´æ¥åŒ¹é…ç‰‡æ®µï¼Œåˆ™è°ƒç”¨ formatUnmatchedFragmentHtml è¿›è¡Œæ¯”å¯¹æ˜¾ç¤º
                        finalDisplayParts.push(formatUnmatchedFragmentHtml(actualFragment, currentStatement));
                    }
                }
            });
        } else {
            // å½“å‰è¯­å¥æ²¡æœ‰åˆ†é…åˆ°ä»»ä½•ç‰‡æ®µï¼ˆå³ï¼Œå®ƒæ²¡æœ‰è‡ªå·±çš„ 'match' ç‰‡æ®µï¼‰
            // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ˜¯ä¸“é—¨ä¸ºäº†æ¯”å¯¹è€Œå€Ÿç”¨ä¸Šä¸€å¥çš„ unmatched ç‰‡æ®µï¼Œæ‰€ä»¥è¿™é‡Œåº”è¯¥å§‹ç»ˆè°ƒç”¨ formatUnmatchedFragmentHtml
            let foundBorrowedFragments = false;
            const currentIndex = state.novelData.findIndex(d => d.line_id === lineId);

            if (currentIndex > 0) {
                const prevItem = state.novelData[currentIndex - 1];
                const prevFragments = state.lineIdToDisplayFragmentsMap.get(prevItem.line_id);

                if (prevFragments) {
                    const borrowedFragments = prevFragments.filter(f => f.ownershipType === 'following_unmatched');

                    if (borrowedFragments.length > 0) {
                        foundBorrowedFragments = true;
                        finalDisplayParts.push(`<div style="color:var(--warning-color); font-size:0.85em; margin-bottom:var(--spacing-xs); font-style:italic;">æ­¤è¯­å¥æœªåŒ¹é…åŸæ–‡ã€‚æ­£ä¸ä¸Šä¸€å¥æœ«å°¾çš„æœªå¤„ç†åŸæ–‡è¿›è¡Œæ¯”å¯¹ï¼š</div>`);
                        
                        borrowedFragments.forEach(fragment => { // <-- **è¿™é‡Œä¸ä½¿ç”¨è§£æ„**
                            // è¿™é‡Œå§‹ç»ˆè°ƒç”¨ formatUnmatchedFragmentHtml è¿›è¡Œæ¯”å¯¹ï¼Œå› ä¸ºå½“å‰è¯­å¥æ²¡æœ‰åŒ¹é…
                            finalDisplayParts.push(formatUnmatchedFragmentHtml(fragment, currentStatement));
                        });
                    }
                }
            }

            if (!foundBorrowedFragments) {
                finalDisplayParts.push(`<span style="color:var(--warning-color);">æ­¤è¯­å¥åœ¨åŸæ–‡ä¸­æœªæ‰¾åˆ°åŒ¹é…æˆ–å…³è”ç‰‡æ®µã€‚</span>`);
            }
        }
        
        originalTextDisplay.innerHTML = finalDisplayParts.join('');
    }
	
    function diffTexts(statement, originalSnippet) {
        if (!statement && !originalSnippet) return '';
        if (!originalSnippet.trim() && statement.trim()) return `<span style="color:var(--danger-color);">ï¼ˆåŸæ–‡ç‰‡æ®µä¸ºç©ºï¼‰</span>`;
        if (originalSnippet.trim() && !statement.trim()) return `<span style="color:var(--danger-color);">${originalSnippet}</span>`;
        if (!originalSnippet.trim() && !statement.trim()) return `<span>ï¼ˆç©ºç™½å†…å®¹ï¼‰</span>`;


        let output = [];
        let i = 0; // index for originalSnippet
        let j = 0; // index for statement

        while (i < originalSnippet.length || j < statement.length) {
            const originalChar = originalSnippet[i];
            const statementChar = statement[j];

            const cleanedOriginalChar = cleanTextForMatching(originalChar);
            const cleanedStatementChar = cleanTextForMatching(statementChar);

            // æƒ…å†µ 1: åŸå§‹å’Œè¯­å¥éƒ½è¿˜æœ‰å­—ç¬¦
            if (i < originalSnippet.length && j < statement.length) {
                if (cleanedOriginalChar === cleanedStatementChar && cleanedOriginalChar !== '') {
                    // éæ ‡ç‚¹å­—ç¬¦åŒ¹é…
                    output.push(`<span style="color: var(--success-color);">${originalChar}</span>`);
                    i++;
                    j++;
                } else if (isPunctuation(originalChar) && isPunctuation(statementChar)) {
                    // æ ‡ç‚¹ç¬¦å·ï¼Œå³ä½¿ä¸å®Œå…¨ç›¸åŒï¼Œä¹Ÿè§†ä¸ºåŒ¹é…ï¼ˆå®½å®¹å¤„ç†ï¼‰
                    output.push(`<span style="color: var(--success-color);">${originalChar}</span>`);
                    i++;
                    j++;
                } else {
                    // ä¸åŒ¹é…ï¼Œä½¿ç”¨åŸç”Ÿ indexOf ç­–ç•¥åˆ¤æ–­å¢åˆ æ”¹
                    const nextOriginalMatchIndex = originalSnippet.indexOf(statementChar, i + 1); 
                    const nextStatementMatchIndex = statement.indexOf(originalChar, j + 1);

                    if (nextOriginalMatchIndex !== -1 && (nextStatementMatchIndex === -1 || (nextOriginalMatchIndex - i <= nextStatementMatchIndex - j))) {
                        // åŸæ–‡ä¸­å¤šä½™æˆ–ä¿®æ”¹ï¼ˆçº¢è‰²ï¼‰
                        output.push(`<span style="color: var(--danger-color);">${originalChar}</span>`);
                        i++;
                    } else if (nextStatementMatchIndex !== -1 && (nextOriginalMatchIndex === -1 || (nextStatementMatchIndex - j < nextOriginalMatchIndex - i))) {
                        // è¯­å¥ä¸­å¤šä½™ï¼ˆåœ¨åŸæ–‡æ˜¾ç¤ºä¸­ä¸ä½“ç°ï¼Œåªæ¨è¿›è¯­å¥æŒ‡é’ˆï¼‰
                        j++;
                    } else {
                        // å­—ç¬¦ä¸åŒ¹é…ï¼Œä¸”æ²¡æœ‰æ˜æ˜¾çš„ä¸‹ä¸€ä¸ªåŒ¹é…ç‚¹ï¼Œéƒ½è§†ä¸ºä¿®æ”¹ï¼ŒåŸæ–‡æ ‡è®°çº¢è‰²
                        output.push(`<span style="color: var(--danger-color);">${originalChar}</span>`);
                        i++;
                        j++; // æ¨è¿›è¯­å¥æŒ‡é’ˆ
                    }
                }
            } else if (i < originalSnippet.length) {
                // è¯­å¥å·²ç”¨å°½ï¼ŒåŸæ–‡è¿˜æœ‰ï¼Œåˆ™åŸæ–‡å‰©ä½™éƒ¨åˆ†éƒ½æ˜¯å¤šä½™/ä¿®æ”¹ï¼ˆçº¢è‰²ï¼‰
                output.push(`<span style="color: var(--danger-color);">${originalSnippet.substring(i)}</span>`);
                i = originalSnippet.length; // å¿«é€Ÿç»“æŸ
            } else if (j < statement.length) {
                // åŸæ–‡å·²ç”¨å°½ï¼Œè¯­å¥è¿˜æœ‰ï¼Œåˆ™è¯­å¥å‰©ä½™éƒ¨åˆ†æ˜¯å¤šä½™ï¼ˆåœ¨åŸæ–‡æ˜¾ç¤ºä¸­ä¸ä½“ç°ï¼‰
                j = statement.length; // å¿«é€Ÿç»“æŸ
            }
        }
        
        const finalOutput = output.join('');
        if (finalOutput.trim() === '' && originalSnippet.trim() !== '') {
             return `<span style="color: var(--danger-color);">${originalSnippet}</span>`; // å¦‚æœæ¯”å¯¹åè¾“å‡ºä¸ºç©ºï¼Œä½†åŸæ–‡ä¸ä¸ºç©º
        }
        return finalOutput;
    }
	
    async function viewOriginalFragment(startIndex, endIndex) {
        // 1. æ˜¾ç¤ºæ¨¡æ€æ¡†
        dom.sourceTextModal.classList.add('active');
        dom.sourceTextModalTitle.textContent = `ç« èŠ‚åŸæ–‡ (ç‰‡æ®µå®šä½: ${startIndex} - ${endIndex})`;
        dom.sourceTextModalBody.innerHTML = '<p class="placeholder-text">æ­£åœ¨åŠ è½½åŸæ–‡...</p>';

        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
        if (selectedCheckboxes.length !== 1) {
            dom.sourceTextModalBody.textContent = 'è¯·åœ¨å·¦ä¾§é€‰æ‹©ä¸€ä¸ªç« èŠ‚ã€‚';
            return;
        }

        const checkbox = selectedCheckboxes[0];
        const chapterTitle = checkbox.dataset.title;

        try {
            // 2. åŠ è½½å®Œæ•´çš„ç« èŠ‚åŸæ–‡ï¼ˆå¦‚æœ state.chapterSourceText å·²ç»æ˜¯å®Œæ•´çš„ï¼Œå°±ä¸ç”¨å†è¯·æ±‚ï¼‰
            const novelName = state.novelName;
            const result = await fetchFromServer(`/api/get_chapter_source_text?novel_name=${encodeURIComponent(novelName)}&chapter_title=${encodeURIComponent(chapterTitle)}`);
            const fullSourceText = result.content;
            
            // 3. æ„å»ºé«˜äº® HTML
            let html = '';
            
            // å‰ç¼€æ–‡æœ¬ (startIndex ä¹‹å‰)
            html += `<span style="color: var(--text-color-secondary);">${fullSourceText.substring(0, startIndex)}</span>`;
            
            // é«˜äº®ç‰‡æ®µ (startIndex åˆ° endIndex)
            html += `<span style="background-color: var(--warning-light-color); color: var(--danger-color); font-weight: bold; padding: 2px;">${fullSourceText.substring(startIndex, endIndex)}</span>`;
            
            // åç¼€æ–‡æœ¬ (endIndex ä¹‹å)
            html += `<span style="color: var(--text-color-secondary);">${fullSourceText.substring(endIndex)}</span>`;
            
            // 4. æ˜¾ç¤ºå†…å®¹å¹¶æ»šåŠ¨åˆ°é«˜äº®ä½ç½®
            dom.sourceTextModalBody.innerHTML = `<pre style="white-space: pre-wrap; margin: 0;">${html}</pre>`;
            
            // ä¸ºäº†å®šä½ï¼Œæˆ‘ä»¬æ‰¾åˆ°é«˜äº®ç‰‡æ®µåœ¨ DOM ä¸­çš„ä½ç½®å¹¶æ»šåŠ¨
            const highlightedSpan = dom.sourceTextModalBody.querySelector('span[style*="background-color"]');
            if (highlightedSpan) {
                // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM æ¸²æŸ“åå†æ»šåŠ¨
                requestAnimationFrame(() => {
                    highlightedSpan.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                });
            }

        } catch (error) {
            dom.sourceTextModalBody.textContent = `åŠ è½½åŸæ–‡å¤±è´¥: ${error.message}`;
            setStatus(`åŠ è½½åŸæ–‡å¤±è´¥: ${error.message}`, 'error');
        }
    }
	
    dom.contentTableBody.addEventListener('click', (e) => {
        const btn = e.target.closest('.btn-view-fragment');
        if (btn) {
            const startIndex = parseInt(btn.dataset.start, 10);
            const endIndex = parseInt(btn.dataset.end, 10);
            if (!isNaN(startIndex) && !isNaN(endIndex)) {
                e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°çˆ¶å…ƒç´ 
                viewOriginalFragment(startIndex, endIndex);
            }
        }
    });
	
    // --- äº‹ä»¶ç›‘å¬å™¨ç»‘å®š ---
    document.getElementById('toggleProofreadModeBtn').addEventListener('click', toggleProofreadMode);
        
    async function loadTimbreDetails(name) {
        if (state.timbreDetails[name]) return Promise.resolve(state.timbreDetails[name]);
        try {
            const encodedName = encodeURIComponent(name);
            const [audioResponse, textResponse] = await Promise.all([
                fetch(`/wav/${encodedName}/1.wav`),
                fetch(`/wav/${encodedName}/1.txt`)
            ]);
            if (!audioResponse.ok || !textResponse.ok) throw new Error(`éŸ³è‰²'${name}'çš„æ–‡ä»¶ä¸å®Œæ•´`);
            const promptAudio = await toBase64(await audioResponse.blob());
            const promptText = await textResponse.text();
            const details = { promptAudio, promptText };
            state.timbreDetails[name] = details;
            return details;
        } catch (e) {
            setStatus(`åŠ è½½éŸ³è‰²'${name}'è¯¦æƒ…å¤±è´¥: ${e.message}`, 'error');
            throw e;
        }
    }

    // 2. generateSpeech(payload)
    async function generateSpeech(payload) {
        // *** æ ¸å¿ƒä¿®æ”¹ 1: å®ç°é‡è¯•é€»è¾‘ ***
        const MAX_RETRIES = 3; // 1æ¬¡åˆæ¬¡å°è¯• + 2æ¬¡é‡è¯•
        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                // é™¤äº† prompt_audio å’Œ prompt_textï¼Œè¿™ä¸¤ä¸ªå­—æ®µç”±æœåŠ¡ç«¯å¤„ç†ã€‚
                const result = await fetchFromServer('/api/tts_v2', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (result.status === 'success') {
                    // å¦‚æœæˆåŠŸï¼Œç«‹å³è¿”å›æ–‡ä»¶å
                    return result.file_name;
                } else {
                    // å¦‚æœAPIè¿”å›äº†ä¸€ä¸ªå·²çŸ¥çš„é”™è¯¯çŠ¶æ€ï¼Œä¹Ÿè§†ä¸ºå¤±è´¥
                    throw new Error(result.message || 'API returned a non-success status.');
                }
            } catch (error) {
                const errorMessage = `ç”Ÿæˆå¤±è´¥ (è¡Œ: ${payload.row_index + 1}, å°è¯•: ${attempt}/${MAX_RETRIES}): ${error.message}`;
                setStatus(errorMessage, 'error');
                console.error(errorMessage, error);

                if (attempt === MAX_RETRIES) {
                    // å¦‚æœè¿™æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œåˆ™æ”¾å¼ƒå¹¶è¿”å› null
                    setStatus(`å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè·³è¿‡æ­¤è¡Œã€‚`, 'warning');
                    return null;
                }
                
                // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´å†é‡è¯•
                await new Promise(resolve => setTimeout(resolve, 2000)); // ç­‰å¾…2ç§’
            }
        }
        return null; // ç†è®ºä¸Šä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œï¼Œä½†ä½œä¸ºå®‰å…¨ä¿éšœ
    }
	
	async function processAllAndSplice() {
		if (state.isProcessing) {
			state.isProcessingCancelled = true;
			setStatus('ä¸­æ­¢æŒ‡ä»¤å·²å‘å‡ºï¼Œæ­£åœ¨ç­‰å¾…å½“å‰ä»»åŠ¡å®Œæˆ...', 'warning');
            updateGlobalButtons();
			return;
		}

		const chaptersToProcess = state.selectedChapterPaths.filter(path => path.includes('.json'));
		if (chaptersToProcess.length === 0) {
			setStatus("æ²¡æœ‰å·²å¤„ç†çš„ç« èŠ‚è¢«é€‰ä¸­ï¼Œæ— æ³•ç”Ÿæˆã€‚", "warning");
			return;
		}

		state.isProcessing = true;
		state.isProcessingCancelled = false;
		updateGlobalButtons();
		dom.globalProgress.style.display = 'block';
		dom.globalProgressBar.style.width = '0%';
		
		const totalChapters = chaptersToProcess.length;
		let chaptersProcessed = 0;
        let successfullySplicedChapters = [];

		try {
			await requestWakeLock(); // <-- æ–°å¢
			for (const chapterPath of chaptersToProcess) {
				if (state.isProcessingCancelled) { setStatus(`å¤„ç†å·²ä¸­æ­¢...`, 'warning'); break; }
				
				const pathParts = chapterPath.replace('.json', '').split(/[/\\]/);
				const currentNovelName = pathParts[0];
				const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
				
				setStatus(`[${chaptersProcessed + 1}/${totalChapters}] åŠ è½½ç« èŠ‚: ${currentChapterName}...`);
				
                // --- åœ¨æ‰¹é‡ç”Ÿæˆæ—¶ï¼ŒåŠ è½½ç« èŠ‚å¹¶è‡ªåŠ¨ç”Ÿæˆ/ä¿å­˜ line_id ---
                let currentChapterData = await fetchFromServer(`/api/get_novel_content?filepath=${encodeURIComponent(chapterPath)}&_t=${new Date().getTime()}`);
                let chapterWasModifiedForLineId = false;

                currentChapterData = currentChapterData.map(item => {
                    if (!item.line_id) {
                        item.line_id = generateUUID();
                        chapterWasModifiedForLineId = true;
                    }
                    return item;
                });

                if (chapterWasModifiedForLineId) {
                    setStatus(`[${chaptersProcessed + 1}/${totalChapters}] é™é»˜ä¿å­˜ç« èŠ‚ '${currentChapterName}' çš„å”¯ä¸€ID...`, 'info');
                    try {
                        const payload = { filepath: chapterPath, content: currentChapterData };
                        await fetchFromServer('/api/update_chapter_content', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        setStatus(`ç« èŠ‚ '${currentChapterName}' å”¯ä¸€IDå·²ä¿å­˜ã€‚`, 'success');
                    } catch (saveError) {
                        setStatus(`é™é»˜ä¿å­˜ç« èŠ‚ '${currentChapterName}' å”¯ä¸€IDå¤±è´¥: ${saveError.message}`, 'error');
                        // å¦‚æœé™é»˜ä¿å­˜å¤±è´¥ï¼Œæˆ‘ä»¬ä»ç„¶å°è¯•ç»§ç»­ç”Ÿæˆï¼Œä½†å¯èƒ½ä¼šå¯¼è‡´ line_id ä¸æŒä¹…
                        // è¿™æ˜¯ä¸€ä¸ªæƒè¡¡ï¼Œä¸ºäº†ä¸ä¸­æ–­æ‰¹é‡ä»»åŠ¡ï¼Œä½†ä¼šè­¦å‘Šç”¨æˆ·
                    }
                }

				const filesToSplice = [];
				const totalRows = currentChapterData.length; 
                let chapterGenerationOk = true; // æœ¬ç« èŠ‚ç”ŸæˆçŠ¶æ€æ ‡å¿—

				for (let i = 0; i < totalRows; i++) {
					if (state.isProcessingCancelled) { setStatus(`å¤„ç†å·²ä¸­æ­¢...`, 'warning'); break; }
					
					const progress = ((chaptersProcessed / totalChapters) + ((i + 1) / totalRows) / totalChapters) * 100 * 0.9;
					dom.globalProgressBar.style.width = `${progress}%`;
					setStatus(`[${chaptersProcessed + 1}/${totalChapters}] ${currentChapterName}: å¤„ç†ä¸­ ${i + 1}/${totalRows}...`);

					const item = currentChapterData[i];
                    if (!item.line_id) { // å†æ¬¡æ£€æŸ¥ line_idï¼Œä»¥é˜²ä¸‡ä¸€
                        setStatus(`é”™è¯¯: ç« èŠ‚ '${currentChapterName}' ç¬¬ ${i+1} è¡Œç¼ºå°‘ line_idï¼Œå·²è·³è¿‡ã€‚`, 'error');
                        chapterGenerationOk = false;
                        break;
                    }
                    
                    // --- æ ¸å¿ƒæ™ºèƒ½åˆ¤æ–­é€»è¾‘ ---
                    // 1. ä¼˜å…ˆä½¿ç”¨è¡Œå†…æŒ‡å®šçš„ `timbre_override` éŸ³è‰²
                    let timbre_to_use = item.timbre_override;

                    // 2. å¦‚æœæ²¡æœ‰è¡Œå†…æŒ‡å®šï¼Œåˆ™å›é€€åˆ°ä½¿ç”¨è§’è‰²çš„å…¨å±€é…ç½®éŸ³è‰²
                    if (!timbre_to_use) {
                        timbre_to_use = state.characterMapping[item.speaker];
                    }

                    // 3. å¦‚æœä¸¤ç§æ–¹å¼éƒ½æ‰¾ä¸åˆ°éŸ³è‰²ï¼Œåˆ™æ ‡è®°æœ¬ç« ä¸ºå¤±è´¥å¹¶ä¸­æ–­
					if (!timbre_to_use) { 
                        setStatus(`é”™è¯¯: è§’è‰²'${item.speaker}'åœ¨ç¬¬ ${i+1} è¡Œæœªåˆ†é…ä»»ä½•éŸ³è‰²ï¼Œå·²è·³è¿‡æœ¬ç« èŠ‚ã€‚`, 'error');
                        chapterGenerationOk = false;
                        break; 
                    }
                    
                    // --- åç»­æ‰€æœ‰é€»è¾‘ï¼Œéƒ½ä½¿ç”¨ timbre_to_use ---
                    const currentTimbre = timbre_to_use;
					const expectedFileName = `${item.line_id}-${sanitizeForFilename(item.speaker)}-${sanitizeForFilename(currentTimbre)}.wav`; 
					const expectedFilePath = `/output/${currentNovelName}/wavs/${currentChapterName}/${expectedFileName}`;
					
					if (await checkFileExists(expectedFilePath)) {
						filesToSplice.push(expectedFileName);
					} else {
						const payload = {
							novel_name: currentNovelName, 
                            chapter_name: currentChapterName, 
                            line_identifier: item.line_id,
							speaker: item.speaker, 
                            timbre: currentTimbre, 
                            tts_text: item.content,
							inference_mode: item.inference_mode || 'zero_shot', 
							instruct_text: item.instruct_text || ''          
						};
						
                        const generatedFile = await generateSpeech(payload);
						
                        if (generatedFile) {
                            filesToSplice.push(generatedFile);
                        } else {
                            setStatus(`ç« èŠ‚ "${currentChapterName}" ç¬¬ ${i + 1} è¡Œç”Ÿæˆå¤±è´¥ï¼Œå·²è·³è¿‡æœ¬ç« èŠ‚çš„åç»­å¤„ç†ã€‚`, 'error');
                            chapterGenerationOk = false;
                            break;
                        }
					}
				}
				if (state.isProcessingCancelled) break;

                // æ‹¼æ¥å‰çš„å®Œæ•´æ€§æ£€æŸ¥é€»è¾‘ä¿æŒä¸å˜
				if (chapterGenerationOk) {
                    setStatus(`[${chaptersProcessed + 1}/${totalChapters}] ${currentChapterName}: æ‰€æœ‰éŸ³é¢‘å·²å°±ç»ªï¼Œæ­£åœ¨æ‹¼æ¥...`);
                    const splicePayload = { 
                        novel_name: currentNovelName, 
                        chapter_name: currentChapterName, 
                        wav_files: filesToSplice
                    };
                    const result = await fetchFromServer('/api/splice_audio', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(splicePayload) });
                    if (result.status !== 'success') throw new Error(result.message || "æ‹¼æ¥å¤±è´¥");
                    
                    setStatus(`[${chaptersProcessed + 1}/${totalChapters}] ç« èŠ‚ "${currentChapterName}" å¤„ç†å®Œæˆ!`, 'success');
                    chaptersProcessed++;
                    successfullySplicedChapters.push(currentChapterName);
                } else {
                    console.warn(`Skipping splice for ${currentChapterName} due to generation failures or cancellation.`);
                }
			}
		} catch(error) {
			setStatus(`æ‰¹é‡å¤„ç†å¤±è´¥: ${error.message}`, 'error');
		} finally {
			await releaseWakeLock();
            // finally å—ä¸­çš„å…¶ä»–ä»£ç ä¿æŒä¸å˜...
			state.isProcessing = false;
			state.isProcessingCancelled = false;
			
            // æ— è®ºå¤„ç†æ˜¯å¦æˆåŠŸæˆ–è¢«å–æ¶ˆï¼Œéƒ½ç»Ÿä¸€è®¾ç½®ç»“æŸçŠ¶æ€
            setStatus('å¤„ç†ç»“æŸ', 'info');

            const currentNovelName = dom.novelSelector.value; // ä¿å­˜å½“å‰é€‰ä¸­çš„å°è¯´åç§°

            // 1. é‡æ–°åŠ è½½å°è¯´é¡¹ç›®åˆ—è¡¨ã€‚è¿™å°†æ¸…ç©ºå¹¶é‡å»º state.allNovelsData çš„é¡¶å±‚ç»“æ„ã€‚
            await loadNovels(false); // ä¼ å…¥ falseï¼Œé¿å…ä¸å¿…è¦çš„ä¸‹æ‹‰æ¡† DOM é‡æ–°æ¸²æŸ“

            // 2. å¦‚æœå½“å‰æœ‰å°è¯´è¢«é€‰ä¸­ï¼Œåˆ™æ˜ç¡®é‡æ–°åŠ è½½è¯¥å°è¯´çš„è¯¦ç»†ç« èŠ‚æ•°æ®ã€‚
            //    è¿™ä¼šå¡«å…… state.allNovelsData[currentNovelName].chaptersã€‚
            if (currentNovelName && state.allNovelsData[currentNovelName]) {
                try {
                    setStatus(`æ­£åœ¨ä¸ºå°è¯´ã€Œ${currentNovelName}ã€é‡æ–°åŠ è½½ç« èŠ‚åˆ—è¡¨...`, 'info');
                    const chapterData = await fetchFromServer(`/api/list_chapters?novel_name=${encodeURIComponent(currentNovelName)}`);
                    state.allNovelsData[currentNovelName].chapters = chapterData.chapters || [];
                    setStatus('ç« èŠ‚åˆ—è¡¨å·²æ›´æ–°ã€‚', 'success');
                } catch (error) {
                    setStatus(`å¤„ç†ååŠ è½½ç« èŠ‚åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
                    state.allNovelsData[currentNovelName].chapters = []; // é”™è¯¯æ—¶æ¸…ç©ºï¼Œé¿å…ä½¿ç”¨æ—§çš„é”™è¯¯æ•°æ®
                }
                // ç¡®ä¿é€‰æ‹©å™¨ä»ç„¶æŒ‡å‘å½“å‰å°è¯´ï¼Œå› ä¸º loadNovels(false) å¯èƒ½ä¼šé‡ç½®å®ƒ
                dom.novelSelector.value = currentNovelName;
                state.novelName = currentNovelName; // ç¡®ä¿ state.novelName ä¹ŸåŒæ­¥
            } else {
                // å¦‚æœæ²¡æœ‰é€‰ä¸­ä»»ä½•å°è¯´ï¼ˆä¾‹å¦‚ï¼Œå”¯ä¸€çš„é¡¹ç›®è¢«åˆ é™¤ï¼‰ï¼Œåˆ™æ¸…ç©ºé€‰æ‹©å™¨å’Œ state.novelName
                dom.novelSelector.value = '';
                state.novelName = '';
            }

            // 3. æ ¹æ®ç°åœ¨æœ€æ–°çš„ç« èŠ‚æ•°æ®ï¼ˆå·²é‡æ–°å¡«å……ï¼‰é‡æ–°æ¸²æŸ“ç« èŠ‚åˆ—è¡¨ UI
            await renderChapterList();

            // 4. æ¢å¤ä¹‹å‰å‹¾é€‰çš„ç« èŠ‚çŠ¶æ€ (å¦‚æœå®ƒä»¬åœ¨æ–°åˆ—è¡¨ä¸­ä»ç„¶å­˜åœ¨)
            dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => {
                const cbNovel = cb.value.split('/')[0];
                // ç¡®ä¿åªæœ‰å½“å‰å°è¯´çš„ç« èŠ‚æ‰ä¼šè¢«é‡æ–°å‹¾é€‰
                if (cbNovel === currentNovelName && state.selectedChapterPaths.includes(cb.value)) {
                    cb.checked = true;
                }
            });

            // 5. æ›´æ–°å…¨å±€æŒ‰é’®çŠ¶æ€å¹¶åˆ·æ–°å†…å®¹ç¼–è¾‘å™¨åŒºåŸŸ
            updateGlobalButtons();
            handleChapterSelectionChange(); // è¿™ä¼šåˆ·æ–°ç¼–è¾‘å™¨å†…å®¹ï¼Œæ˜¾ç¤ºå·²å¤„ç†/å·²æ‹¼æ¥ç« èŠ‚çš„æœ€æ–°çŠ¶æ€

            // 6. å»¶è¿Ÿéšè—å…¨å±€è¿›åº¦æ¡
            setTimeout(() => { dom.globalProgress.style.display = 'none'; }, 5000);
		}
	}
	
    // 4. showProfileModal(characterName)
    async function showProfileModal(characterName) {
        dom.profileModalTitle.textContent = `è§’è‰²ç®€ä»‹: ${characterName}`;
        dom.profileModalBody.innerHTML = '<p class="placeholder-text">æ­£åœ¨åŠ è½½...</p>';
        dom.profileModal.classList.add('active'); // ä½¿ç”¨ active ç±»
        try {
            const encodedCharName = encodeURIComponent(characterName);
            const data = await fetchFromServer(`/api/get_character_profile?novel_name=${state.novelName}&character_name=${encodedCharName}`);
            let html = '<dl>';
            html += `<dt>æ€§åˆ«</dt><dd>${data.gender || 'æœªçŸ¥'}</dd>`;
            html += `<dt>å¹´é¾„æ®µ</dt><dd>${data.ageGroup || 'æœªçŸ¥'}</dd>`;
            html += `<dt>èº«ä»½</dt><dd>${data.identity || 'æœªçŸ¥'}</dd>`;
            html += '</dl>';
            dom.profileModalBody.innerHTML = html;
        } catch (error) {
            dom.profileModalBody.textContent = `åŠ è½½ç®€ä»‹å¤±è´¥: ${error.message}`;
        }
    }

    // 5. qualityOptions object
    const qualityOptions = {
        mp3: ['128k', '192k', '256k', '320k'],
        wav: ['æ— æŸ (PCM 16-bit)'],
        m4a: ['128k', '192k', '256k'],
        ogg: ['q5 (çº¦160k)', 'q7 (çº¦224k)', 'q9 (çº¦320k)']
    };

    // 6. updateQualityOptions()
	function updateQualityOptions() {
		const format = dom.exportFormat.value;
		const qualities = qualityOptions[format];
		dom.exportQuality.innerHTML = '';
		qualities.forEach(q => {
			const option = document.createElement('option');
			const value = (format === 'ogg') ? q.split(' ')[0] : (format === 'wav' ? 'pcm_s16le' : q);
			option.value = value;
			option.textContent = q;
			dom.exportQuality.appendChild(option);
		});
		dom.exportQuality.disabled = (format === 'wav');

		// --- æ ¸å¿ƒä¿®å¤ ---
		// ä» state.globalConfig.audio_export è¯»å–æ•°æ®ï¼Œè€Œä¸æ˜¯æ—§çš„ state.exportSettings
		// åŒæ—¶å¢åŠ å¥å£®æ€§æ£€æŸ¥ï¼Œé˜²æ­¢ state.globalConfig è¿˜æœªåŠ è½½æ—¶å‡ºé”™
		const audioExportConfig = state.globalConfig?.audio_export;
		if (audioExportConfig && audioExportConfig.format === format) {
			dom.exportQuality.value = audioExportConfig.quality;
		} else {
			// å¦‚æœæ ¼å¼ä¸åŒ¹é…æˆ–é…ç½®ä¸å­˜åœ¨ï¼Œé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
			dom.exportQuality.selectedIndex = 0;
		}
	}
	
	
	function updateGlobalButtons() {
		const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
		const selectedCount = selectedCheckboxes.length;
		
		 // --- æŒ‰é’®çŠ¶æ€çš„ç»Ÿä¸€æ§åˆ¶ ---

		 // A. ç­›é€‰å‡ºä¸åŒç±»å‹çš„é€‰ä¸­é¡¹
		 const processableTxtCheckboxes = Array.from(selectedCheckboxes).filter(cb => {
			 return cb.hasAttribute('data-txt-chapter');
		 });
		 const processableTxtCount = processableTxtCheckboxes.length;
		 
		 const processableJsonCheckboxes = Array.from(selectedCheckboxes).filter(cb => cb.value.includes('.json'));
		 const processableJsonCount = processableJsonCheckboxes.length;
		 
		 // B. æ§åˆ¶ â€œå¤„ç†æ–‡æœ¬â€ æŒ‰é’®
		 if (state.isTxtProcessing) {
			 dom.processTxtBtn.textContent = 'åœæ­¢å¤„ç†';
			 dom.processTxtBtn.classList.add('btn-danger');
			 dom.processTxtBtn.disabled = state.isTxtProcessingCancelled; 
			 if (state.isTxtProcessingCancelled) {
				 dom.processTxtBtn.textContent = 'æ­£åœ¨åœæ­¢...';
			 }
		 } else {
			 dom.processTxtBtn.textContent = `å¤„ç†æ–‡æœ¬ (${processableTxtCount})`;
			 dom.processTxtBtn.classList.remove('btn-danger');
			 dom.processTxtBtn.disabled = processableTxtCount === 0 || state.isProcessing;
		 }
		
		// C. æ§åˆ¶ â€œç”Ÿæˆå£°éŸ³â€ æŒ‰é’®
		if (state.isProcessing) {
			dom.processAllBtn.textContent = 'åœæ­¢ç”Ÿæˆ';
			dom.processAllBtn.classList.remove('btn-primary');
			dom.processAllBtn.classList.add('btn-danger');
			dom.processAllBtn.disabled = state.isProcessingCancelled; 
			 if (state.isProcessingCancelled) {
				 dom.processAllBtn.textContent = 'æ­£åœ¨åœæ­¢...';
			 }
		} else {
			dom.processAllBtn.textContent = `ç”Ÿæˆè¯­éŸ³ (${processableJsonCount})`;
			dom.processAllBtn.classList.remove('btn-danger');
			dom.processAllBtn.classList.add('btn-primary');
			dom.processAllBtn.disabled = processableJsonCount === 0 || state.isTxtProcessing;
		}

		 // D. æ§åˆ¶ â€œä¸‹è½½å£°éŸ³â€ æŒ‰é’®
		 let hasSplicedChapter = false;
		 if (state.novelName && state.allNovelsData[state.novelName] && !state.isProcessing && !state.isTxtProcessing) {
			 const novelChapters = state.allNovelsData[state.novelName].chapters;
			 for (const checkbox of selectedCheckboxes) {
				 const chapterTitle = checkbox.dataset.title;
				 const chapterData = novelChapters.find(c => c.title === chapterTitle);
				 if (chapterData && chapterData.spliced) {
					 hasSplicedChapter = true;
					 break;
				 }
			 }
		 }
		 dom.downloadSpliceBtn.disabled = state.isProcessing || state.isTxtProcessing || !hasSplicedChapter;
		 
		 // E. æ§åˆ¶ â€œæ’­æ”¾å£°éŸ³â€ æŒ‰é’®
		let canPlayChapter = false;
		if (selectedCount === 1) {
			const checkbox = selectedCheckboxes[0];
			if (checkbox.closest('li').classList.contains('spliced')) {
				canPlayChapter = true;
			}
		}
		dom.chapterPlayStopBtn.disabled = !canPlayChapter;

        dom.viewSourceBtn.disabled = selectedCount !== 1;


		 // F. å…¨å±€å¤„ç†çŠ¶æ€ä¸‹çš„ç¦ç”¨é€»è¾‘
		 if (state.isProcessing || state.isTxtProcessing) {
			 dom.novelSelector.disabled = true;
			 dom.chapterListEl.querySelectorAll('input').forEach(cb => cb.disabled = true);
		 } else {
			 dom.novelSelector.disabled = false;
			 dom.chapterListEl.querySelectorAll('input').forEach(cb => cb.disabled = false);
		 }
	}
	
	// --- å…¨æ–°çš„éŸ³è‰²åº“ä¸ç®¡ç†å™¨é€»è¾‘æ¨¡å— ---
	let timbreData = { categories: {}, unassigned: [] };

	async function loadTimbres() {
		try {
			timbreData = await fetchFromServer('/api/timbres/data');
            // å…ˆå°†æ‰€æœ‰æœªåˆ†ç±»éŸ³è‰²åŠ å…¥
            state.allTimbres = [...timbreData.unassigned];
            // éå†æ‰€æœ‰åˆ†ç±»ï¼Œå°†å…¶ä¸‹çš„éŸ³è‰²ä¹ŸåŠ å…¥
            for (const categoryName in timbreData.categories) {
                state.allTimbres.push(...timbreData.categories[categoryName]);
            }
			
			const filter = document.getElementById('categoryFilter');
			const currentFilterValue = filter.value;
			filter.innerHTML = `
				<option value="all">-å…¨éƒ¨-</option>
				<option value="unassigned">æœªåˆ†ç±»</option>
			`;
			const sortedCategories = Object.keys(timbreData.categories).sort();
			sortedCategories.forEach(cat => {
				const option = document.createElement('option');
				option.value = option.textContent = cat;
				filter.appendChild(option);
			});

			if (Array.from(filter.options).some(opt => opt.value === currentFilterValue)) {
				filter.value = currentFilterValue;
			} else {
				filter.value = 'all';
			}
			
			renderTimbreList();
		} catch(e) {
			setStatus(`åŠ è½½éŸ³è‰²å¤±è´¥: ${e.message}`, 'error');
			timbreData = { categories: {}, unassigned: [] };
            state.allTimbres = []; // é”™è¯¯æ—¶ä¹Ÿæ¸…ç©ºï¼Œä¿æŒçŠ¶æ€ä¸€è‡´
            state.timbreDetails = {};
			renderTimbreList();
		}
	}

	function renderTimbreList() {
		dom.timbreListEl.innerHTML = '';
		if (!timbreData) return;

		const filterValue = document.getElementById('categoryFilter').value;
		const { categories, unassigned } = timbreData;
		let timbresToRender = [];

		if (filterValue === 'all') {
			timbresToRender = [...unassigned];
			Object.values(categories).forEach(arr => timbresToRender.push(...arr));
		} else if (filterValue === 'unassigned') {
			timbresToRender = [...unassigned];
		} else if (categories[filterValue]) {
			timbresToRender = [...categories[filterValue]];
		}

		if (timbresToRender.length === 0) {
			dom.timbreListEl.innerHTML = '<p class="placeholder-text">æ­¤åˆ†ç±»/éŸ³è‰²åº“ä¸‹æ²¡æœ‰éŸ³è‰²</p>';
			return;
		}

		timbresToRender.sort().forEach(t => {
			const li = document.createElement('li');
			li.innerHTML = `<span class="label">${t}</span>
						  <div class="timbre-actions">
                            <div class="popover-container roles-popover" style="display: none; position: relative;">
                                <button class="btn-show-roles" title="æŸ¥çœ‹å·²åˆ†é…è§’è‰²">â˜°</button>
                                <div class="popover-content" style="right: 105%; top: 50%; transform: translateY(-50%);">
                                    <strong>å·²åˆ†é…ç»™:</strong>
                                    <ul></ul>
                                </div>
                            </div>
							<button class="btn btn-assign" data-timbre-name="${t}">åˆ†é…</button>
							<button class="audio-player-btn playable" data-timbre-name="${t}" title="è¯•å¬ ${t}">â–¶</button>
						  </div>`;
			dom.timbreListEl.appendChild(li);
		});
		updateRelatedRolesPopovers();
		
        // ---åœ¨éŸ³è‰²åˆ—è¡¨æ¸²æŸ“åï¼Œå¦‚æœé€‰ä¸­äº†è§’è‰²ï¼Œåˆ™é‡æ–°åº”ç”¨å†²çªé«˜äº® ---
        if (state.selectedCharacter) {
            updateTimbreConflictHighlight(state.selectedCharacter);
        }
	}
    
	// === 5. EVENT LISTENERS ===	
	
    // --- èŒƒå›´é€‰æ‹©æŒ‰é’®é€»è¾‘ ---
    dom.rangeSelectBtn.addEventListener('click', () => {
        // åˆ‡æ¢æ¨¡å¼çŠ¶æ€
        state.isRangeSelectMode = !state.isRangeSelectMode;
        
        // é‡ç½®èµ·ç‚¹
        state.rangeStartCheckbox = null;
        // æ¸…é™¤æ‰€æœ‰å¯èƒ½çš„ä¸´æ—¶æ ·å¼
        dom.chapterListEl.querySelectorAll('li').forEach(li => li.classList.remove('range-start-item'));

        // æ›´æ–° UI çŠ¶æ€
        if (state.isRangeSelectMode) {
            dom.rangeSelectBtn.classList.add('btn-active-mode');
            dom.chapterListEl.classList.add('range-selection-active');
            setStatus('èŒƒå›´é€‰æ‹©æ¨¡å¼å·²å¼€å¯ï¼šè¯·ç‚¹å‡»ã€èµ·å§‹ã€‘ç« èŠ‚ã€‚å†æ¬¡ç‚¹å‡»æŒ‰é’®å¯å–æ¶ˆã€‚', 'info');
        } else {
            dom.rangeSelectBtn.classList.remove('btn-active-mode');
            dom.chapterListEl.classList.remove('range-selection-active');
            setStatus('èŒƒå›´é€‰æ‹©æ¨¡å¼å·²å…³é—­ã€‚', 'info');
        }
    });

	const dom_timbres_manager = {
		openBtn: document.getElementById('manageTimbresBtn'),
		modal: document.getElementById('timbresManageModal'),
		closeBtn: document.getElementById('closeTimbresManageBtn'),
		categoryList: document.getElementById('manager-category-list'),
		newCatInput: document.getElementById('managerNewCategoryInput'),
		addCatBtn: document.getElementById('managerAddCategoryBtn'),
		timbresTitle: document.getElementById('manager-timbres-title'),
		timbresList: document.getElementById('manager-timbres-list'),
		uploadCategorySelect: document.getElementById('uploadTimbreCategory'),
		categoryFilter: document.getElementById('categoryFilter')
	};
	let managerState = { selectedCategory: 'unassigned' };
		
	// ç­›é€‰ä¸»åˆ—è¡¨
	dom_timbres_manager.categoryFilter.addEventListener('change', renderTimbreList);

	dom_timbres_manager.openBtn.addEventListener('click', async () => {
		dom_timbres_manager.modal.classList.add('active'); // ä½¿ç”¨ active ç±»
		managerState.selectedCategory = 'unassigned';
		try {
			timbreData = await fetchFromServer('/api/timbres/data');
			renderTimbresManager();
		} catch(e) { setStatus(`åŠ è½½éŸ³è‰²æ•°æ®å¤±è´¥: ${e.message}`, 'error'); }
	});

	dom_timbres_manager.closeBtn.addEventListener('click', () => {
        stopAllAudio(); // åœ¨å…³é—­æ¨¡æ€æ¡†å‰åœæ­¢æ‰€æœ‰éŸ³é¢‘
		dom_timbres_manager.modal.classList.remove('active'); // ç§»é™¤ active ç±»
		loadTimbres();
	});
	
    dom_timbres_manager.modal.addEventListener('click', (e) => {
        if (e.target === dom_timbres_manager.modal) {
            stopAllAudio(); // ç¡®ä¿åœæ­¢æ’­æ”¾éŸ³é¢‘
            dom_timbres_manager.modal.classList.remove('active'); // ç§»é™¤ active ç±»æ¥å…³é—­æ¨¡æ€æ¡†
            loadTimbres(); // é‡æ–°åŠ è½½éŸ³è‰²åˆ—è¡¨ï¼Œä»¥é˜²åˆ†ç±»æœ‰å˜åŒ–
        }
    });

	dom_timbres_manager.categoryList.addEventListener('click', async (e) => { 
		const li = e.target.closest('li');
		if (!li) return;
		
		if (e.target.matches('.btn-delete-category')) {
			e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ° li çš„é€‰ä¸­é€»è¾‘
			const categoryToDelete = e.target.dataset.categoryName;
			if (categoryToDelete === 'unassigned') {
				alert('â€œæœªåˆ†ç±»â€ä¸èƒ½è¢«åˆ é™¤ã€‚');
				return;
			}
			if (confirm(`æ‚¨ç¡®å®šè¦åˆ é™¤åˆ†ç±»ã€Œ${categoryToDelete}ã€å—ï¼Ÿ\nè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰éŸ³è‰²å°†å›åˆ°â€œæœªåˆ†ç±»â€çŠ¶æ€ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
				try {
					setStatus(`æ­£åœ¨åˆ é™¤åˆ†ç±»ã€Œ${categoryToDelete}ã€...`, 'info');
					await fetchFromServer(`/api/timbres/categories/${encodeURIComponent(categoryToDelete)}`, {
						method: 'DELETE'
					});
					setStatus(`åˆ†ç±»ã€Œ${categoryToDelete}ã€å·²åˆ é™¤ã€‚`, 'success');
					// é‡æ–°åŠ è½½éŸ³è‰²æ•°æ®å¹¶æ¸²æŸ“ç®¡ç†å™¨
					timbreData = await fetchFromServer('/api/timbres/data');
					managerState.selectedCategory = 'unassigned'; // åˆ é™¤åé»˜è®¤é€‰ä¸­æœªåˆ†ç±»
					renderTimbresManager();
				} catch (error) {
					setStatus(`åˆ é™¤åˆ†ç±»å¤±è´¥: ${error.message}`, 'error');
					alert(`åˆ é™¤åˆ†ç±»å¤±è´¥: ${error.message}`);
				}
			}
			return; // é˜»æ­¢å…¶ä»– li ç‚¹å‡»é€»è¾‘
		}
		
		if (li && li.dataset.categoryName) {
			managerState.selectedCategory = li.dataset.categoryName;
			renderTimbresManager();
		}
	});

	dom_timbres_manager.addCatBtn.addEventListener('click', managerCreateCategory);
	dom_timbres_manager.newCatInput.addEventListener('keypress', (e) => {
		if (e.key === 'Enter') managerCreateCategory();
	});

	dom_timbres_manager.timbresList.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.matches('.btn-move-timbre')) { // ä½¿ç”¨æ›´ç²¾ç¡®çš„é€‰æ‹©å™¨ï¼ŒåªåŒ¹é…â€œç§»åŠ¨åˆ°â€æŒ‰é’®
            const timbreName = target.dataset.timbreName;
            const popover = target.nextElementSibling;
            let menuHtml = '<ul>';
            menuHtml += `<li><button class="category-move-btn" data-timbre="${timbreName}" data-category="">-- æœªåˆ†ç±» --</button></li>`;
            Object.keys(timbreData.categories).sort().forEach(cat => {
                if (cat !== managerState.selectedCategory) {
                    menuHtml += `<li><button class="category-move-btn" data-timbre="${timbreName}" data-category="${cat}">${cat}</button></li>`;
                }
            });
            menuHtml += '</ul>';
            popover.innerHTML = menuHtml;
        }
        else if (target.matches('.category-move-btn')) {
            const timbreName = target.dataset.timbre;
            const categoryName = target.dataset.category;
            try {
                const result = await fetchFromServer('/api/timbres/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timbre_name: timbreName, category_name: categoryName })
                });
                timbreData = result.data;
                renderTimbresManager();
            } catch(e) { alert(`ç§»åŠ¨å¤±è´¥: ${e.message}`); }
        }
        else if (target.matches('.btn-delete-timbre')) {
            const timbreName = target.dataset.timbreName;
            if (!confirm(`æ‚¨ç¡®å®šè¦æ°¸ä¹…åˆ é™¤éŸ³è‰²ã€Œ${timbreName}ã€å—ï¼Ÿ`)) return;
            try {
                await fetchFromServer(`/api/delete_timbre?timbre_name=${encodeURIComponent(timbreName)}`, { method: 'DELETE' });
                // åˆ é™¤åï¼Œéœ€è¦æ›´æ–°æœ¬åœ°çš„ timbreData å¹¶é‡æ–°æ¸²æŸ“
                if (managerState.selectedCategory === 'unassigned') {
                    timbreData.unassigned = timbreData.unassigned.filter(t => t !== timbreName);
                } else {
                    timbreData.categories[managerState.selectedCategory] = timbreData.categories[managerState.selectedCategory].filter(t => t !== timbreName);
                }
                renderTimbresManager();
                setStatus('éŸ³è‰²åˆ é™¤æˆåŠŸï¼', 'success');
            } catch (error) { 
                setStatus(`åˆ é™¤éŸ³è‰²å¤±è´¥: ${error.message}`, 'error'); 
            }
        }
        // *** æ ¸å¿ƒä¿®æ”¹ï¼šä¸ºæ’­æ”¾æŒ‰é’®æ·»åŠ é€»è¾‘ ***
        else if (target.matches('.audio-player-btn')) {
            const timbreName = target.dataset.timbreName;
            if (timbreName) {
                toggleSimpleAudio(target, `/wav/${timbreName}/1.wav`);
            } else {
                setStatus('é”™è¯¯ï¼šæœªèƒ½è·å–éŸ³è‰²åç§°è¿›è¡Œæ’­æ”¾ã€‚', 'error');
            }
        }
    });
	
	dom.uploadTimbreLabelBtn.addEventListener('click', async () => {
		try {
			const data = await fetchFromServer('/api/timbres/data');
			const select = dom_timbres_manager.uploadCategorySelect;
			select.innerHTML = '<option value="">-- ä¸å½’ç±» --</option>';
			Object.keys(data.categories).sort().forEach(cat => {
				const option = document.createElement('option');
				option.value = option.textContent = cat;
				select.appendChild(option);
			});
		} catch (e) { console.error("åŠ è½½åˆ†ç±»å¤±è´¥:", e); }
		dom.timbreFile.click();
	});

	// --- æ¢å¤çš„ã€åªå¤„ç†åˆ†é…å’Œæ’­æ”¾çš„ timbreListEl äº‹ä»¶ç›‘å¬å™¨ ---
	dom.timbreListEl.addEventListener('click', async (e) => {
		const target = e.target;
		if (target.matches('.btn-assign')) {
			if (!state.selectedCharacter) { alert('è¯·å…ˆåœ¨è§’è‰²åˆ—è¡¨ä¸­ç‚¹å‡»é€‰ä¸­ä¸€ä¸ªè§’è‰²ï¼'); return; }
			const timbreName = target.dataset.timbreName;
			state.characterMapping[state.selectedCharacter] = timbreName;
			await loadCharacters();
			if (state.selectedChapterPaths.length === 1 && dom.contentTable.style.display === 'table') {
				renderContentTable();
				await checkAllPlayableFiles();
			}
            updateRelatedRolesPopovers();
			setStatus(`å·²å°†éŸ³è‰² '${timbreName}' åˆ†é…ç»™è§’è‰² '${state.selectedCharacter}'`, 'success');
			await saveConfig(); // <--- è‡ªåŠ¨ä¿å­˜
		}
		else if (target.matches('.audio-player-btn')) { 
			toggleSimpleAudio(target, `/wav/${target.dataset.timbreName}/1.wav`);
		}
	});
	

	// ã€æ ¸å¿ƒè¡¥å……ã€‘æ¸²æŸ“ç®¡ç†å™¨UIçš„å®Œæ•´å‡½æ•°
	function renderTimbresManager() {
		const { categories, unassigned } = timbreData;
		
		// 1. æ¸²æŸ“å·¦ä¾§åˆ†ç±»åˆ—è¡¨
		let catListHtml = `<ul class="info-list">`;
		// â€œæœªåˆ†ç±»â€é¡¹
		catListHtml += `<li class="selectable ${managerState.selectedCategory === 'unassigned' ? 'selected' : ''}" data-category-name="unassigned">
							<span class="label">æœªåˆ†ç±»</span>
							<span class="value">${unassigned.length}</span>
						</li>`;
		// å…¶ä»–åˆ†ç±»é¡¹
		Object.keys(categories).sort().forEach(catName => {
			catListHtml += `<li class="selectable ${managerState.selectedCategory === catName ? 'selected' : ''}" data-category-name="${catName}">
								<span class="label">${catName}</span>
								<span class="value">${categories[catName].length}</span>
								<div class="category-actions" style="margin-left: auto;">
									<button class="btn btn-danger circular-btn btn-delete-category" data-category-name="${catName}" title="åˆ é™¤æ­¤åˆ†ç±»">X</button>
								</div>
							</li>`;
		});
		catListHtml += `</ul>`;
		dom_timbres_manager.categoryList.innerHTML = catListHtml;

		// 2. æ¸²æŸ“å³ä¾§éŸ³è‰²åˆ—è¡¨
		dom_timbres_manager.timbresTitle.textContent = managerState.selectedCategory === 'unassigned' ? 'æœªåˆ†ç±»éŸ³è‰²' : `åˆ†ç±»: ${managerState.selectedCategory}`;
		let timbresToShow = managerState.selectedCategory === 'unassigned' ? unassigned : categories[managerState.selectedCategory];
		
		if (!timbresToShow || timbresToShow.length === 0) {
			dom_timbres_manager.timbresList.innerHTML = '<p class="placeholder-text">æ­¤åˆ†ç±»ä¸‹æ²¡æœ‰éŸ³è‰²</p>';
			return;
		}

		let timbreListHtml = '';
		timbresToShow.forEach(timbreName => {
			timbreListHtml += `<li>
								<span class="label">${timbreName}</span>
								<div class="timbre-actions">
									<div class="popover-container">
										<button class="btn btn-move-timbre" data-timbre-name="${timbreName}">ç§»åŠ¨åˆ°</button>
										<div class="popover-content category-menu"></div>
									</div>
                                    <button class="audio-player-btn playable" data-timbre-name="${timbreName}" title="è¯•å¬ ${timbreName}">â–¶</button>
									<button class="btn btn-danger circular-btn btn-delete-timbre" data-timbre-name="${timbreName}" title="åˆ é™¤éŸ³è‰²">X</button>
								</div>
							   </li>`;
		});
		dom_timbres_manager.timbresList.innerHTML = timbreListHtml;
        updateRelatedRolesPopovers(); //
	}

	// åˆ›å»ºæ–°åˆ†ç±»
	async function managerCreateCategory() {
		const newName = dom_timbres_manager.newCatInput.value.trim();
		if (!newName) return;
		try {
			const result = await fetchFromServer('/api/timbres/categories', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ category_name: newName })
			});
			timbreData = result.data; // ä½¿ç”¨åç«¯è¿”å›çš„æœ€æ–°æ•°æ®
			managerState.selectedCategory = newName; // é€‰ä¸­æ–°åˆ›å»ºçš„åˆ†ç±»
			renderTimbresManager();
			dom_timbres_manager.newCatInput.value = '';
		} catch (e) { alert(`åˆ›å»ºå¤±è´¥: ${e.message}`); }
	}

    // --- State for the modal ---
    let charManageState = { allChars: [], selectedChars: [] };

    // --- Helper functions for the modal ---	
    function renderCharManageList() {
        const listEl = dom.charManageList;
        const searchTerm = dom.charSearchInput.value.toLowerCase();
        listEl.innerHTML = '';
        
        const filteredChars = charManageState.allChars.filter(c => c.toLowerCase().includes(searchTerm));

        filteredChars.forEach(char => {
            const isChecked = charManageState.selectedChars.includes(char);
            const li = document.createElement('li');
            // +++ æ–°å¢ï¼šä¸º li æ·»åŠ  data-character-name å±æ€§ +++
            li.dataset.characterName = char; 
            li.style.display = 'flex';
            li.style.alignItems = 'center';
            li.style.padding = '0.4rem';
            li.style.gap = '0.5rem';
            li.innerHTML = `
                <input type="checkbox" class="char-manage-cb" value="${char}" ${isChecked ? 'checked' : ''} style="flex-shrink: 0;">
                <span class="char-name-display" style="flex-grow: 1; cursor: text;">${char}</span>
                <input type="text" class="char-name-edit" value="${char}" style="flex-grow: 1; display: none;">
                <div class="char-rename-actions" style="display: none; flex-shrink: 0;">
                    <button class="btn btn-primary btn-save-rename" style="font-size: 0.75rem; padding: 0.1rem 0.4rem;">ä¿å­˜</button>
                    <button class="btn btn-cancel-rename" style="font-size: 0.75rem; padding: 0.1rem 0.4rem;">å–æ¶ˆ</button>
                </div>
                <button class="btn btn-edit-rename" style="flex-shrink: 0; font-size: 0.75rem; padding: 0.1rem 0.4rem;">ç¼–è¾‘</button>
            `;
            listEl.appendChild(li);
        });
    }

    function updateMergeControls() {
        const selected = charManageState.selectedChars;
        dom.charsToMerge.innerHTML = selected.map(c => `<span class="badge" style="background: #e8f0fe; padding: 2px 6px; border-radius: 4px; margin: 2px;">${c}</span>`).join(' ');
        
        const selectEl = dom.targetCharSelect;
        selectEl.innerHTML = '';
        if (selected.length > 0) {
            selected.forEach(c => {
                const option = document.createElement('option');
                option.value = option.textContent = c;
                selectEl.appendChild(option);
            });
            selectEl.disabled = false;
        } else {
            selectEl.disabled = true;
        }

        dom.confirmMergeBtn.disabled = selected.length < 2;
    }

    // --- Event Listeners for the modal ---
    dom.manageCharactersBtn.addEventListener('click', async () => {
        if (!state.novelName) return;

        setStatus('æ­£åœ¨è·å–æ‰€æœ‰è§’è‰²åˆ—è¡¨...', 'info');
        dom.charManageModal.classList.add('active'); // ä½¿ç”¨ active ç±»
        dom.charManageList.innerHTML = '<p class="placeholder-text">åŠ è½½ä¸­...</p>';
        
        charManageState = { allChars: [], selectedChars: [] }; // Reset state
        updateMergeControls();

        try {
            // *** æ ¸å¿ƒä¿®æ”¹ 1: åœ¨æ‰“å¼€æ—¶ï¼Œå…ˆå¼ºåˆ¶åˆ·æ–°ä¸€æ¬¡å°è¯´æ•°æ® ***
            // è¿™èƒ½ç¡®ä¿ state.allNovelsData åŒ…å«æœ€æ–°çš„ processed å’Œ spliced çŠ¶æ€
            await loadNovels();
            // åœ¨ä¸‹æ‹‰æ¡†ä¸­é‡æ–°é€‰ä¸­å½“å‰å°è¯´ï¼Œä»¥é˜²åˆ—è¡¨é¡ºåºå˜åŒ–
            dom.novelSelector.value = state.novelName;
            
            const novelData = state.allNovelsData[state.novelName];

            if (!novelData || !novelData.chapters) {
                throw new Error("æ— æ³•è·å–å½“å‰å°è¯´çš„ç« èŠ‚æ•°æ®ã€‚");
            }
		
			const selectedChapterFiles = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked'))
				.filter(cb => cb.value.endsWith('.json')) // ç¡®ä¿æ˜¯å·²å¤„ç†çš„ç« èŠ‚
				.map(cb => cb.value.split(/[/\\]/).pop()); // åªå–æ–‡ä»¶åéƒ¨åˆ†

			if (selectedChapterFiles.length === 0) {
				 dom.charManageList.innerHTML = '<p class="placeholder-text">è¯·å…ˆåœ¨å·¦ä¾§è‡³å°‘é€‰æ‹©ä¸€ä¸ªã€å·²å¤„ç†ã€‘çš„ç« èŠ‚ã€‚</p>';
				 setStatus('è¯·å…ˆé€‰æ‹©å·²å¤„ç†çš„ç« èŠ‚ä»¥ç®¡ç†è§’è‰²ã€‚', 'warning');
				 return;
			}
            
			console.log(`[Char Manage] Requesting characters from ${selectedChapterFiles.length} selected files.`);

            const payload = { novel_name: state.novelName, chapter_files: selectedChapterFiles  };
            const data = await fetchFromServer('/api/get_characters_in_chapters', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            
            if (!data.characters || data.characters.length === 0) {
                dom.charManageList.innerHTML = '<p class="placeholder-text">åœ¨å·²å¤„ç†çš„ç« èŠ‚ä¸­æœªå‘ç°ä»»ä½•è§’è‰²åã€‚</p>';
            } else {
                charManageState.allChars = (data.characters || []).filter(c => c !== 'æ—ç™½').sort();
                renderCharManageList();
            }
            
            setStatus('è§’è‰²åˆ—è¡¨åŠ è½½å®Œæ¯•ã€‚', 'success');

        } catch (error) {
            dom.charManageList.innerHTML = `<p class="placeholder-text" style="color:var(--danger-color);">åŠ è½½è§’è‰²å¤±è´¥: ${error.message}</p>`;
            setStatus(`åŠ è½½è§’è‰²å¤±è´¥: ${error.message}`, 'error');
        }
    });
    
    dom.charSearchInput.addEventListener('input', renderCharManageList);

    dom.charManageList.addEventListener('change', e => {
        if (e.target.matches('.char-manage-cb')) {
            const charName = e.target.value;
            if (e.target.checked) {
                if (!charManageState.selectedChars.includes(charName)) {
                    charManageState.selectedChars.push(charName);
                }
            } else {
                charManageState.selectedChars = charManageState.selectedChars.filter(c => c !== charName);
            }
            updateMergeControls();
        }
    });

    dom.charManageList.addEventListener('click', async (e) => {
        const target = e.target;
        const li = target.closest('li');
        if (!li) return;

        const oldName = li.dataset.characterName;
        const nameDisplay = li.querySelector('.char-name-display');
        const nameEditInput = li.querySelector('.char-name-edit');
        const renameActions = li.querySelector('.char-rename-actions');
        const editBtn = li.querySelector('.btn-edit-rename');

        // --- ç‚¹å‡»â€œç¼–è¾‘â€æŒ‰é’® ---
        if (target.matches('.btn-edit-rename')) {
            // è¿›å…¥ç¼–è¾‘æ¨¡å¼
            nameDisplay.style.display = 'none';
            editBtn.style.display = 'none';
            nameEditInput.style.display = 'block';
            renameActions.style.display = 'flex';
            nameEditInput.focus();
            nameEditInput.select();
        }

        // --- ç‚¹å‡»â€œå–æ¶ˆâ€æŒ‰é’® ---
        if (target.matches('.btn-cancel-rename')) {
            // é€€å‡ºç¼–è¾‘æ¨¡å¼
            nameDisplay.style.display = 'block';
            editBtn.style.display = 'block';
            nameEditInput.style.display = 'none';
            renameActions.style.display = 'none';
            nameEditInput.value = oldName; // æ¢å¤åŸå§‹å€¼
        }

        // --- ç‚¹å‡»â€œä¿å­˜â€æŒ‰é’® ---
        if (target.matches('.btn-save-rename')) {
            const newName = nameEditInput.value.trim();
            if (!newName || newName === oldName) {
                // å¦‚æœåå­—æ²¡å˜æˆ–ä¸ºç©ºï¼Œåˆ™è§†ä¸ºå–æ¶ˆ
                renameActions.querySelector('.btn-cancel-rename').click();
                return;
            }

            if (!confirm(`ç¡®å®šè¦å°†è§’è‰²ã€Œ${oldName}ã€é‡å‘½åä¸ºã€Œ${newName}ã€å—ï¼Ÿ\næ­¤æ“ä½œå°†ä¿®æ”¹æ‰€æœ‰é€‰å®šç« èŠ‚ã€‚`)) {
                return;
            }

            setStatus('æ­£åœ¨é‡å‘½åè§’è‰²...', 'info');
            target.disabled = true;
            target.textContent = 'ä¿å­˜ä¸­...';
            
            try {
                const selectedChapterFiles = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked'))
                    .filter(cb => cb.value.endsWith('.json'))
                    .map(cb => cb.value.split(/[/\\]/).pop());

                if (selectedChapterFiles.length === 0) {
                    alert('æ‰§è¡Œé‡å‘½åæ“ä½œå‰ï¼Œå¿…é¡»åœ¨å·¦ä¾§åˆ—è¡¨ä¸­è‡³å°‘é€‰æ‹©ä¸€ä¸ªã€å·²å¤„ç†ã€‘çš„ç« èŠ‚ã€‚');
                    return;
                }

                const payload = {
                    novel_name: state.novelName,
                    old_name: oldName,
                    new_name: newName,
                    chapter_files: selectedChapterFiles
                };

                const result = await fetchFromServer('/api/rename_character', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                setStatus(result.message, 'success');

                // --- å…³é”®ï¼šåˆ·æ–°UI ---
                // 1. æ›´æ–° charManageState ä¸­çš„ allChars æ•°ç»„
                const charIndex = charManageState.allChars.indexOf(oldName);
                if (charIndex > -1) {
                    charManageState.allChars[charIndex] = newName;
                    charManageState.allChars.sort(); // é‡æ–°æ’åº
                }
                // 2. é‡æ–°æ¸²æŸ“è§’è‰²ç®¡ç†åˆ—è¡¨
                renderCharManageList();
                // 3. åˆ·æ–°ä¸»ç•Œé¢çš„è§’è‰²åˆ—è¡¨
                await loadCharacters();
                // 4. å¦‚æœç¼–è¾‘å™¨å¼€ç€ï¼Œä¹Ÿåˆ·æ–°å®ƒ
                if (state.selectedChapterPaths.length === 1 && dom.editorView.style.display === 'block') {
                    await loadSingleChapterForEditing(state.selectedChapterPaths[0]);
                }

            } catch (error) {
                setStatus(`é‡å‘½åå¤±è´¥: ${error.message}`, 'error');
                alert(`é‡å‘½åå¤±è´¥: ${error.message}`);
                // å¤±è´¥æ—¶ä¹Ÿè¦æ¢å¤UI
                target.disabled = false;
                target.textContent = 'ä¿å­˜';
            }
        }
    });
	
    dom.confirmMergeBtn.addEventListener('click', async () => {
        const targetName = dom.targetCharSelect.value;
        const sourceNames = charManageState.selectedChars.filter(c => c !== targetName);

        if (!targetName || sourceNames.length === 0) {
            alert('è¯·ç¡®ä¿å·²é€‰æ‹©ä¸»è§’è‰²ï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªå…¶ä»–è§’è‰²è¦è¢«åˆå¹¶ã€‚');
            return;
        }
        
        if (!confirm(`ç¡®å®šè¦å°† ${sourceNames.join(', ')} åˆå¹¶åˆ° ${targetName} å—ï¼Ÿ\næ­¤æ“ä½œå°†ä¿®æ”¹æ‰€æœ‰ç« èŠ‚æ–‡ä»¶ï¼Œä¸”ä¸å¯æ’¤é”€ã€‚`)) {
            return;
        }

        setStatus('æ­£åœ¨æ‰§è¡Œåˆå¹¶æ“ä½œ...', 'info');
        dom.confirmMergeBtn.disabled = true;
        dom.confirmMergeBtn.textContent = 'åˆå¹¶ä¸­...';

        try {
			const selectedChapterFiles = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked'))
				.filter(cb => cb.value.endsWith('.json'))
				.map(cb => cb.value.split(/[/\\]/).pop());

			if (selectedChapterFiles.length === 0) {
				alert('æ‰§è¡Œåˆå¹¶å‰ï¼Œå¿…é¡»åœ¨å·¦ä¾§åˆ—è¡¨ä¸­è‡³å°‘é€‰æ‹©ä¸€ä¸ªç« èŠ‚ã€‚');
				return;
			}
			
            const payload = {
                novel_name: state.novelName,
                target_name: targetName,
                source_names: sourceNames,
				chapter_files: selectedChapterFiles
            };
            const result = await fetchFromServer('/api/merge_characters', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            setStatus(result.message, 'success');
			dom.charManageModal.classList.remove('active'); // ç§»é™¤ active ç±»

            // å…³é”®ï¼šåˆ·æ–°æ‰€æœ‰ç›¸å…³UI
            await loadNovels();
            renderChapterList();
            await loadAndApplyConfig(); // åŠ è½½æ›´æ–°åçš„éŸ³è‰²é…ç½®
            await loadCharacters();     // åˆ·æ–°è§’è‰²åˆ—è¡¨
            // å¦‚æœç¼–è¾‘å™¨å¼€ç€ï¼Œä¹Ÿåˆ·æ–°å®ƒ
            if (state.selectedChapterPaths.length === 1 && dom.editorView.style.display === 'block') {
                await loadSingleChapterForEditing(state.selectedChapterPaths[0]);
            }

        } catch (error) {
            setStatus(`åˆå¹¶å¤±è´¥: ${error.message}`, 'error');
            alert(`åˆå¹¶å¤±è´¥: ${error.message}`);
        } finally {
            dom.confirmMergeBtn.disabled = false;
            dom.confirmMergeBtn.textContent = 'ç¡®è®¤åˆå¹¶';
        }
    });

    dom.viewSourceBtn.addEventListener('click', async () => {
        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
        if (selectedCheckboxes.length !== 1) return;

        const checkbox = selectedCheckboxes[0];
        const chapterTitle = checkbox.dataset.title;

        // æ˜¾ç¤ºæ¨¡æ€æ¡†å¹¶è®¾ç½®åŠ è½½çŠ¶æ€
        dom.sourceTextModal.classList.add('active'); // ä½¿ç”¨ active ç±»
        dom.sourceTextModalTitle.textContent = `åŸæ–‡: ${chapterTitle}`;
        dom.sourceTextModalBody.innerHTML = '<p class="placeholder-text">æ­£åœ¨åŠ è½½...</p>';

        try {
            const novelName = state.novelName;
            // è°ƒç”¨æ–°çš„åç«¯API
            const result = await fetchFromServer(`/api/get_chapter_source_text?novel_name=${encodeURIComponent(novelName)}&chapter_title=${encodeURIComponent(chapterTitle)}`);
            
            // å°†è¿”å›çš„çº¯æ–‡æœ¬å†…å®¹æ”¾å…¥æ¨¡æ€æ¡†
            dom.sourceTextModalBody.textContent = result.content;

        } catch (error) {
            dom.sourceTextModalBody.textContent = `åŠ è½½åŸæ–‡å¤±è´¥: ${error.message}`;
            setStatus(`åŠ è½½åŸæ–‡å¤±è´¥: ${error.message}`, 'error');
        }
    });

    // +++ æ–°å¢ï¼šå…³é—­åŸæ–‡æ¨¡æ€æ¡†çš„äº‹ä»¶ç›‘å¬ +++
    dom.sourceTextModalCloseBtn.addEventListener('click', () => {
        dom.sourceTextModal.classList.remove('active'); // ç§»é™¤ active ç±»
    });
    dom.sourceTextModal.addEventListener('click', (e) => {
        if (e.target === dom.sourceTextModal) {
			dom.sourceTextModal.classList.remove('active'); // ç§»é™¤ active ç±»
        }
    });
	
    dom.closeCharManageBtn.addEventListener('click', () => {
        dom.charManageModal.classList.remove('active'); // ç§»é™¤ active ç±»
    });
	
	dom.addCharManageBtn.addEventListener('click', async () => {
		const newCharName = dom.newCharManageNameInput.value.trim();
		if (!newCharName) {
			alert('è§’è‰²åä¸èƒ½ä¸ºç©ºã€‚');
			return;
		}

		setStatus(`æ­£åœ¨æ·»åŠ æ–°è§’è‰²: ${newCharName}...`, 'info');
		dom.addCharManageBtn.disabled = true;
		dom.addCharManageBtn.textContent = 'æ·»åŠ ä¸­...';

		try {
			const payload = {
				novel_name: state.novelName,
				character_name: newCharName
			};
			const result = await fetchFromServer('/api/add_character_to_novel', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			});

			if (result.status === 'success') {
				setStatus(`è§’è‰² '${newCharName}' æ·»åŠ æˆåŠŸï¼`, 'success');
				dom.newCharManageNameInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†

				// åˆ·æ–°æ‰€æœ‰è§’è‰²åˆ—è¡¨ï¼š
				// 1. æ›´æ–° state.allAvailableCharacters (ç”¨äºå†…å®¹ç¼–è¾‘å™¨ä¸‹æ‹‰æ¡†)
				await loadAllCharactersForDropdown(); 
				// 2. åˆ·æ–°è§’è‰²ç®¡ç†åˆ—è¡¨ (å½“å‰æ¨¡æ€æ¡†å†…çš„åˆ—è¡¨)
				charManageState.allChars.push(newCharName);
				charManageState.allChars.sort();
				renderCharManageList();
				// 3. åˆ·æ–°ä¸»ç•Œé¢çš„è§’è‰²-éŸ³è‰²é…ç½®åˆ—è¡¨ (ç¬¬äºŒåˆ—)
				await loadCharacters(); 
				// 4. å¦‚æœå†…å®¹ç¼–è¾‘å™¨æ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°å®ƒ
				if (state.selectedChapterPaths.length === 1 && dom.editorView.style.display === 'block') {
					await loadSingleChapterForEditing(state.selectedChapterPaths[0]);
				}

			} else {
				throw new Error(result.message || 'æ·»åŠ è§’è‰²å¤±è´¥ã€‚');
			}
		} catch (error) {
			setStatus(`æ·»åŠ è§’è‰²å¤±è´¥: ${error.message}`, 'error');
			alert(`æ·»åŠ è§’è‰²å¤±è´¥: ${error.message}`);
		} finally {
			dom.addCharManageBtn.disabled = false;
			dom.addCharManageBtn.textContent = 'æ–°å¢';
		}
	});
	
    // *** æ ¸å¿ƒä¿®æ”¹ 5: æ·»åŠ æ‰“å¼€å’Œå¤„ç†â€œå¤šäººåŒå£°â€æ¨¡æ€æ¡†çš„å‡½æ•° ***
    function openChoralModal(rowIndex) {
        dom.fineTuneModal.classList.remove('active');
		
        dom.choralModal.classList.add('active');
        const listEl = dom.choralTimbreList;
        listEl.innerHTML = ''; // æ¸…ç©ºæ—§åˆ—è¡¨
		
		const speaker = state.novelData[rowIndex] ? state.novelData[rowIndex].speaker : null;
		const timbre = speaker ? state.characterMapping[speaker] : null;

		// å¢åŠ å¥å£®æ€§æ£€æŸ¥ï¼Œå¦‚æœæ— æ³•è·å–è§’è‰²æˆ–éŸ³è‰²ä¿¡æ¯ï¼Œåˆ™ä¸ç»§ç»­æ‰§è¡Œ
		if (!speaker || !timbre) {
			alert(`æ— æ³•ä¸ºç¬¬ ${rowIndex + 1} è¡Œæ‰§è¡Œæ­¤æ“ä½œï¼Œå› ä¸ºç¼ºå°‘è§’è‰²æˆ–éŸ³è‰²é…ç½®ã€‚`);
			dom.choralModal.classList.remove('active'); // å…³é—­æ¨¡æ€æ¡†
			return;
		}

        // ç”¨ state.allTimbres å¡«å……åˆ—è¡¨
        state.allTimbres.forEach(timbre => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.style.padding = '0.4rem';
            label.style.cursor = 'pointer';
            label.innerHTML = `<input type="checkbox" class="choral-timbre-cb" value="${timbre}"> ${timbre}`;
            listEl.appendChild(label);
        });

        // ä¸ºâ€œç¡®è®¤â€æŒ‰é’®ç»‘å®šä¸€æ¬¡æ€§äº‹ä»¶ç›‘å¬å™¨
        const handleConfirm = async () => {
            const selectedTimbres = Array.from(listEl.querySelectorAll('.choral-timbre-cb:checked')).map(cb => cb.value);
            
            if (selectedTimbres.length < 2) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸¤ä¸ªéŸ³è‰²ä»¥äº§ç”Ÿå¤šäººåŒå£°æ•ˆæœã€‚');
                return;
            }

            // å…³é—­æ¨¡æ€æ¡†å¹¶å¼€å§‹å¤„ç†
            dom.choralModal.classList.remove('active');
            dom.fineTuneModal.classList.add('active'); // <--- é‡æ–°æ˜¾ç¤ºå¾®è°ƒæ¨¡æ€æ¡†
            setStatus(`æ­£åœ¨ç”Ÿæˆ ${selectedTimbres.length} äººåŒå£°æ•ˆæœ...`, 'info');

            const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
            const currentChapterName = pathParts.length > 1 ? pathParts[1] : pathParts[0];
			
			// ç¡®ä¿ä»æ­£ç¡®çš„å½“å‰è¡Œå’Œå¾®è°ƒæ¨¡æ€æ¡†ä¸­è·å–å‚æ•°
			const itemForGenerating = state.novelData[rowIndex]; 
			const ttsModelForGenerating = dom.fineTuneTtsModelSelect.value; // ä»å¾®è°ƒæ¨¡æ€æ¡†è·å–å½“å‰é€‰ä¸­çš„ TTS æ¨¡å‹

			const payload = {
				novel_name: state.novelName,
				chapter_name: currentChapterName,
                line_identifier: itemForGenerating.line_id,
				tts_text: itemForGenerating.content, // ä» itemForGenerating è·å–å†…å®¹
				selected_timbres: selectedTimbres,
				original_speaker: itemForGenerating.speaker,   
				original_timbre: (itemForGenerating.timbre_override || state.characterMapping[itemForGenerating.speaker]),      
				tts_model: ttsModelForGenerating // ä½¿ç”¨ä»å¾®è°ƒæ¨¡æ€æ¡†è·å–çš„ TTS æ¨¡å‹
			};

            try {
                const result = await fetchFromServer('/api/generate_choral_effect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                // æ›´æ–°å‰ç«¯çŠ¶æ€ï¼Œä»¥ä¾¿èƒ½æ’­æ”¾è¿™ä¸ªæ–°ç”Ÿæˆçš„æ–‡ä»¶
                state.generatedFiles[itemForGenerating.line_id] = result.file_name;
                
				// æ›´æ–°ä¸»å†…å®¹ç¼–è¾‘å™¨è¡¨æ ¼è¡Œçš„æ’­æ”¾æŒ‰é’®
				const mainTableRow = document.getElementById(`content-row-${itemForGenerating.line_id}`); 
                if (mainTableRow) {
					const mainTablePlayBtn = mainTableRow.querySelector('.btn-play');
                    if (mainTablePlayBtn) {
                        mainTablePlayBtn.disabled = false;
                        mainTablePlayBtn.classList.add('playable');
                    }
                }
                
                // æ›´æ–°å¾®è°ƒæ¨¡æ€æ¡†å†…çš„æ’­æ”¾å’Œç‰¹æ•ˆæŒ‰é’®
                dom.fineTunePlayBtn.disabled = false;
                dom.fineTuneEffectsBtn.disabled = false;

                setStatus(result.message, 'success');
                // è‡ªåŠ¨æ’­æ”¾
                playAudio(`/output/${state.novelName}/wavs/${currentChapterName}/${result.file_name}`);

            } catch (error) {
                setStatus(`å¤šäººåŒå£°æ•ˆæœç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
            }finally {
                // è§£ç»‘äº‹ä»¶ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ï¼Œæ— è®ºæˆåŠŸå¤±è´¥éƒ½åœ¨è¿™é‡Œè§£ç»‘
                dom.confirmChoralBtn.removeEventListener('click', handleConfirm);
                dom.cancelChoralBtn.removeEventListener('click', handleCancel); 
            }
			
        };
        
        dom.confirmChoralBtn.addEventListener('click', handleConfirm);

        // ä¸ºâ€œå–æ¶ˆâ€æŒ‰é’®ä¹Ÿç»‘å®šä¸€æ¬¡æ€§äº‹ä»¶
        const handleCancel = () => {
            dom.choralModal.classList.remove('active');
            dom.fineTuneModal.classList.add('active'); // <--- é‡æ–°æ˜¾ç¤ºå¾®è°ƒæ¨¡æ€æ¡†
            // è§£ç»‘ä¸¤ä¸ªäº‹ä»¶
            dom.confirmChoralBtn.removeEventListener('click', handleConfirm);
            dom.cancelChoralBtn.removeEventListener('click', handleCancel);
        };
        dom.cancelChoralBtn.addEventListener('click', handleCancel);
    }
	
    async function showCharacterDialogues(characterName) {
        // è·å–å½“å‰é€‰ä¸­çš„æ‰€æœ‰ç« èŠ‚æ ‡é¢˜
        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
        const chapterTitles = Array.from(selectedCheckboxes).map(cb => cb.dataset.title);
        
        // æ˜¾ç¤ºæ¨¡æ€æ¡†å¹¶è®¾ç½®åˆå§‹çŠ¶æ€
        dom.dialogueModal.classList.add('active'); // ä½¿ç”¨ active ç±»
        dom.dialogueModalTitle.textContent = `è§’è‰²ã€Œ${characterName}ã€åœ¨é€‰ä¸­ç« èŠ‚ä¸­çš„ç›¸å…³å¥å­`;
        dom.dialogueModalBody.innerHTML = '<p class="placeholder-text">æ­£åœ¨æœç´¢åŸæ–‡...</p>';

        if (chapterTitles.length === 0) {
            dom.dialogueModalBody.innerHTML = '<p class="placeholder-text">è¯·å…ˆåœ¨ç¬¬ä¸€åˆ—ä¸­è‡³å°‘é€‰æ‹©ä¸€ä¸ªç« èŠ‚ã€‚</p>';
            return;
        }

        try {
            // æ„é€ è¯·æ±‚ä½“
            const payload = {
                novel_name: state.novelName,
                character_name: characterName,
                chapter_titles: chapterTitles
            };

            // è°ƒç”¨æ–°çš„åç«¯API
            const result = await fetchFromServer('/api/search_character_sentences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const sentences = result.sentences || [];

            // æ¸²æŸ“æœ€ç»ˆç»“æœ
            if (sentences.length === 0) {
                dom.dialogueModalBody.innerHTML = `<p class="placeholder-text">åœ¨é€‰ä¸­çš„ ${chapterTitles.length} ä¸ªç« èŠ‚ä¸­æœªæ‰¾åˆ°åŒ…å«ã€Œ${characterName}ã€çš„å¥å­ã€‚</p>`;
            } else {
                let html = '<ul>';
                sentences.forEach(sentence => {
                    // é«˜äº®è§’è‰²å
                    const highlightedContent = sentence.content.replace(
                        new RegExp(characterName, 'g'),
                        `<strong style="color: var(--primary-color);">${characterName}</strong>`
                    );
                    html += `<li>
                               <span class="dialogue-source">æ¥è‡ªç« èŠ‚: ${sentence.source}</span>
                               ${highlightedContent}
                             </li>`;
                });
                html += '</ul>';

                if (sentences.length >= 20) {
                    html += `<p style="text-align: center; margin-top: 1rem; color: var(--text-color-secondary);">ï¼ˆä»…æ˜¾ç¤ºå‰ ${sentences.length} æ¡ç›¸å…³å¥å­ï¼‰</p>`;
                }
                dom.dialogueModalBody.innerHTML = html;
            }

        } catch (error) {
            dom.dialogueModalBody.innerHTML = `<p class="placeholder-text" style="color: var(--danger-color);">æœç´¢æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}</p>`;
        }
    }
	
	async function handleNovelSelection(isUploadTriggered = false) { // å¢åŠ ä¸€ä¸ªé»˜è®¤å‚æ•°
        // å¦‚æœæ˜¯ç”±ä¸Šä¼ è§¦å‘çš„ï¼Œæˆ‘ä»¬è·³è¿‡ change äº‹ä»¶çš„æ‹¦æˆªé€»è¾‘
        if (!isUploadTriggered && state.isProgrammaticChange) {
            state.isProgrammaticChange = false;
            return;
        }
        state.filter = {
            status: 'all', // é»˜è®¤æ˜¾ç¤ºå…¨éƒ¨ç« èŠ‚
            start: null,   // æ¸…ç©ºèµ·å§‹èŒƒå›´
            end: null      // æ¸…ç©ºç»“æŸèŒƒå›´
        };
        document.querySelector('input[name="filterStatus"][value="all"]').checked = true;
        dom.rangeStartInput.value = '';
        dom.rangeEndInput.value = '';
        // å¦‚æœæ˜¯æ­£å¸¸çš„ç”¨æˆ·ç‚¹å‡»ï¼Œæˆ–è€…ä¸Šä¼ åæ‰‹åŠ¨è°ƒç”¨ï¼Œåˆ™é‡ç½®æ——å¸œ
        state.isProgrammaticChange = false;

		state.novelName = dom.novelSelector.value;
        dom.deleteNovelBtn.disabled = !state.novelName;
        dom.manageCharactersBtn.disabled = !state.novelName;
        dom.manageReplaceDictBtn.disabled = !state.novelName; 
        dom.detectTimbreConflictsBtn.disabled = !state.novelName;
		dom.autoAssignTimbreBtn.disabled = !state.novelName || state.isProcessing || state.isTxtProcessing;
		dom.novelTxtFile.value = '';
		
		dom.chapterListEl.innerHTML = '<p class="placeholder-text">è¯·å…ˆé€‰æ‹©ä¸€æœ¬å°è¯´</p>';
		dom.characterListEl.innerHTML = '<p class="placeholder-text">é€‰æ‹©ç« èŠ‚åæ˜¾ç¤º</p>';

		if (state.novelName) {
			await loadAllCharactersForDropdown(); // åŠ è½½æ‰€æœ‰è§’è‰²ä»¥å¡«å……ä¸‹æ‹‰åˆ—è¡¨
            try {
                setStatus(`æ­£åœ¨åŠ è½½å°è¯´ã€Œ${state.novelName}ã€çš„ç« èŠ‚åˆ—è¡¨...`, 'info');
                const chapterData = await fetchFromServer(`/api/list_chapters?novel_name=${encodeURIComponent(state.novelName)}`);
                state.allNovelsData[state.novelName].chapters = chapterData.chapters || [];
                setStatus('ç« èŠ‚åˆ—è¡¨åŠ è½½æˆåŠŸã€‚', 'success');
            } catch (error) {
                setStatus(`åŠ è½½ç« èŠ‚åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
                state.allNovelsData[state.novelName].chapters = [];
            }
			await renderChapterList(); 
			await loadAndApplyConfig(); // åŠ è½½éŸ³è‰²é…ç½®
            if (state.novelName) {
                try {
                    setStatus(`æ­£åœ¨åŠ è½½å°è¯´ã€Œ${state.novelName}ã€çš„ç« èŠ‚åˆ†å¸ƒæ•°æ®...`, 'info');
                    const chapterPresenceData = await fetchFromServer(`/api/get_chapter_presence_data?novel_name=${encodeURIComponent(state.novelName)}`);
                    state.chapterCharacterMap = chapterPresenceData.data.chapter_character_map || {};
                    state.chapterOrderList = chapterPresenceData.data.chapter_order_list || [];
                    setStatus('ç« èŠ‚åˆ†å¸ƒæ•°æ®åŠ è½½æˆåŠŸã€‚', 'success');
                } catch (error) {
                    setStatus(`åŠ è½½ç« èŠ‚åˆ†å¸ƒæ•°æ®å¤±è´¥: ${error.message}`, 'error');
                    state.chapterCharacterMap = {};
                    state.chapterOrderList = [];
                }
            } else {
                state.chapterCharacterMap = {};
                state.chapterOrderList = [];
            }
            // æ¸…ç©ºéŸ³è‰²å†²çªç¼“å­˜ï¼Œå› ä¸ºå°è¯´å·²åˆ‡æ¢
            state.timbreConflictCache = {};
			
			// åŠ è½½è§’è‰²ç®€ä»‹
			const profilesPath = `/projects/${state.novelName}/character_profiles.json`;
			try {
				const profilesResponse = await fetch(profilesPath);
				if (profilesResponse.ok) {
					const profiles = await profilesResponse.json();
					// ç¡®ä¿ state.allNovelsData[state.novelName] ç»“æ„å­˜åœ¨
					if (!state.allNovelsData[state.novelName]) {
						state.allNovelsData[state.novelName] = {};
					}
					state.allNovelsData[state.novelName].character_profiles = profiles;
					setStatus('è§’è‰²ç®€ä»‹åŠ è½½æˆåŠŸã€‚', 'success');
				} else if (profilesResponse.status === 404) {
					state.allNovelsData[state.novelName].character_profiles = {}; // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œä½¿ç”¨ç©ºå¯¹è±¡
					setStatus('è§’è‰²ç®€ä»‹æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œå·²ä½¿ç”¨ç©ºç®€ä»‹ã€‚', 'warning');
				} else {
					throw new Error(`åŠ è½½è§’è‰²ç®€ä»‹å¤±è´¥: ${profilesResponse.statusText}`);
				}
			} catch (error) {
				setStatus(`åŠ è½½è§’è‰²ç®€ä»‹å¤±è´¥: ${error.message}`, 'error');
				state.allNovelsData[state.novelName].character_profiles = {};
			}
		} else {
			await renderChapterList(); 
		}
		
		handleChapterSelectionChange();
	}
	
    async function loadAllCharactersForDropdown() {
        if (!state.novelName) {
            state.allAvailableCharacters = [];
            return;
        }
        try {
            const profilesPath = `/projects/${state.novelName}/character_profiles.json`;
            const timbresPath = `/projects/${state.novelName}/character_timbres.json`;

			const cacheBuster = `?_t=${new Date().getTime()}`;

			const [profilesResponse, timbresResponse] = await Promise.all([
				fetch(profilesPath + cacheBuster), // æ·»åŠ  cacheBuster
				fetch(timbresPath + cacheBuster)   // æ·»åŠ  cacheBuster
			]);

            let profiles = {};
            if (profilesResponse.ok) {
                profiles = await profilesResponse.json();
            } else if (profilesResponse.status === 404) {
                // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸æƒ…å†µï¼Œä½¿ç”¨ç©ºå¯¹è±¡
                profiles = {};
            } else {
                throw new Error(`åŠ è½½è§’è‰²ç®€ä»‹å¤±è´¥: ${profilesResponse.statusText}`);
            }

            let timbres = {};
            if (timbresResponse.ok) {
                timbres = await timbresResponse.json();
            } else if (timbresResponse.status === 404) {
                // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸æƒ…å†µï¼Œä½¿ç”¨ç©ºå¯¹è±¡
                timbres = {};
            } else {
                throw new Error(`åŠ è½½éŸ³è‰²é…ç½®å¤±è´¥: ${timbresResponse.statusText}`);
            }

            // åˆå¹¶æ‰€æœ‰è§’è‰²åï¼Œå»é‡ï¼Œå¹¶æ’åº
            let allChars = new Set(['æ—ç™½']); // ç¡®ä¿æ—ç™½æ€»åœ¨
            Object.keys(profiles).forEach(char => allChars.add(char));
            Object.keys(timbres).forEach(char => allChars.add(char));

            state.allAvailableCharacters = Array.from(allChars).sort((a, b) => {
                if (a === 'æ—ç™½') return -1;
                if (b === 'æ—ç™½') return 1;
                return a.localeCompare(b);
            });
            // console.log("åŠ è½½æ‰€æœ‰å¯ç”¨è§’è‰²ï¼š", state.allAvailableCharacters); // è°ƒè¯•ç”¨
        } catch (e) {
            setStatus(`åŠ è½½è§’è‰²åˆ—è¡¨å¤±è´¥: ${e.message}`, 'error');
            state.allAvailableCharacters = ['æ—ç™½']; // å¤±è´¥æ—¶è‡³å°‘ä¿ç•™æ—ç™½
        }
    }
    
	// --- New Global Settings Logic ---
	function renderGlobalSettingsModal() {
		const config = state.globalConfig;
		// å¢åŠ å¯¹ tts_models çš„æ£€æŸ¥ï¼Œç¡®ä¿æ•°æ®å®Œæ•´æ€§
		if (!config || !config.general || !config.models || !config.tts_models || !config.audio_export) {
			console.error("Incomplete global config loaded. Cannot render settings modal.", config);
            alert("å…¨å±€é…ç½®æ–‡ä»¶ä¸å®Œæ•´ï¼Œæ— æ³•æ‰“å¼€è®¾ç½®ã€‚è¯·æ£€æŸ¥æœåŠ¡å™¨ç«¯çš„ config.json æˆ–é‡å¯æœåŠ¡ã€‚");
			return;
		}

		// --- Tab: General Settings ---
		const defaultModelSelect = dom.settingsDefaultModel;
		defaultModelSelect.innerHTML = '';
		Object.keys(config.models).forEach(modelId => {
			const model = config.models[modelId];
            if (!model) return; // å®‰å…¨æ£€æŸ¥
			const option = document.createElement('option');
			option.value = modelId;
			option.textContent = model.display_name || modelId;
			defaultModelSelect.appendChild(option);
		});
		defaultModelSelect.value = config.general.default_model;
		
		const defaultTtsModelSelect = dom.settingsDefaultTtsModel;
		defaultTtsModelSelect.innerHTML = '';
		const ttsModels = config.tts_models || {};
		for (const modelId in ttsModels) {
            const model = ttsModels[modelId];
            if (!model) continue; // å®‰å…¨æ£€æŸ¥
			const option = document.createElement('option');
			option.value = modelId;
			option.textContent = model.display_name || modelId;
			defaultTtsModelSelect.appendChild(option);
		}
		defaultTtsModelSelect.value = config.general.default_tts_model;
		
		const proxy = config.general.proxy;
		dom.settingsProxyEnabled.checked = proxy.enabled;
		dom.proxyDetailsGroup.style.display = proxy.enabled ? 'block' : 'none';
		dom.settingsProxyProtocol.value = proxy.protocol;
		dom.settingsProxyAddress.value = proxy.address;
		dom.settingsProxyPort.value = proxy.port;

		// --- Tab: LLM Model Settings (ä¿®æ­£) ---
		const llmForm = dom.llmSettingsForm;
		llmForm.innerHTML = '';
		for (const modelId in config.models) {
            const model = config.models[modelId];
            if (!model) continue; // å®‰å…¨æ£€æŸ¥

			const fieldset = document.createElement('fieldset');
			fieldset.style = "border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;";
			fieldset.innerHTML = `
				<legend style="font-weight: 500;">${model.display_name || modelId}</legend>
				<div class="input-group">
					<label for="modelname-${modelId}">Model Name</label>
					<input type="text" id="modelname-${modelId}" data-model-id="${modelId}" data-key="model_name" value="${model.model_name || ''}" placeholder="e.g., gemini-1.5-flash">
				</div>
				<div class="input-group">
					<label for="apikey-${modelId}">API Key</label>
					<input type="password" id="apikey-${modelId}" data-model-id="${modelId}" data-key="api_key" value="${model.api_key || ''}" placeholder="è¯·è¾“å…¥API Key">
				</div>
				<div class="input-group">
					<label for="maxchars-${modelId}">æœ€å¤§å­—ç¬¦æ•° (ç”¨äºåˆ†å—)</label>
					<input type="number" id="maxchars-${modelId}" data-model-id="${modelId}" data-key="max_chars" value="${model.max_chars || 1000}">
				</div>
				<div class="config-group inline-group">
					<label for="useproxy-${modelId}">ä½¿ç”¨ä»£ç†æœåŠ¡å™¨</label>
					<input type="checkbox" id="useproxy-${modelId}" data-model-id="${modelId}" data-key="use_proxy" ${model.use_proxy ? 'checked' : ''} style="width: auto; height: auto;">
				</div>
			`;
			llmForm.appendChild(fieldset);
		}

		// --- Tab: TTS Model Settings (ä¿®æ­£) ---
        const ttsForm = dom.ttsSettingsForm;
        ttsForm.innerHTML = '';
        for (const modelId in config.tts_models) { 
            const model = config.tts_models[modelId];
            if (!model) continue; // å®‰å…¨æ£€æŸ¥

            const fieldset = document.createElement('fieldset');
            fieldset.style = "border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; margin-bottom: 1rem;";
            
            const defaultMode = model.default_mode || 'zero_shot';
            fieldset.innerHTML = `
                <legend style="font-weight: 500;">${model.display_name || modelId}</legend>
                <div class="input-group">
                    <label for="tts-displayname-${modelId}">æ˜¾ç¤ºåç§°</label>
                    <input type="text" id="tts-displayname-${modelId}" data-model-id="${modelId}" data-key="display_name" value="${model.display_name || ''}">
                </div>
                <div class="input-group">
                    <label for="tts-endpoint-${modelId}">æœåŠ¡åœ°å€</label>
                    <input type="text" id="tts-endpoint-${modelId}" data-model-id="${modelId}" data-key="endpoint" value="${model.endpoint || ''}" placeholder="http://127.0.0.1:5010/api/tts">
                </div>
                <div class="input-group">
                    <label for="tts-defaultmode-${modelId}">é»˜è®¤æ¨¡å¼</label>
                    <select id="tts-defaultmode-${modelId}" data-model-id="${modelId}" data-key="default_mode">
                        <option value="zero_shot" ${defaultMode === 'zero_shot' ? 'selected' : ''}>æ­£å¸¸</option>
                        <option value="cross_lingual" ${defaultMode === 'cross_lingual' ? 'selected' : ''}>ç²¾ç»†</option>
                    </select>
                </div>
            `;
            ttsForm.appendChild(fieldset);
        }
		
		// --- Tab: Audio Export ---
		dom.exportFormat.value = config.audio_export.format;
		updateQualityOptions();
		dom.exportQuality.value = config.audio_export.quality;
	}

	async function saveAllSettings() {
		const newConfig = JSON.parse(JSON.stringify(state.globalConfig));

		// General settings
		newConfig.general.default_model = dom.settingsDefaultModel.value;
		newConfig.general.default_tts_model = dom.settingsDefaultTtsModel.value;
		newConfig.general.proxy.enabled = dom.settingsProxyEnabled.checked;
		newConfig.general.proxy.protocol = dom.settingsProxyProtocol.value;
		newConfig.general.proxy.address = dom.settingsProxyAddress.value;
		newConfig.general.proxy.port = dom.settingsProxyPort.value;

		// Model settings
		dom.llmSettingsForm.querySelectorAll('input').forEach(input => {
			const modelId = input.dataset.modelId;
			const key = input.dataset.key;
			if (!modelId || !key) return;

			let value;
			if (input.type === 'checkbox') {
				value = input.checked;
			} else if (input.type === 'number') {
				value = parseInt(input.value, 10) || 0;
			} else {
				value = input.value;
			}
			newConfig.models[modelId][key] = value;
		});
		
		// TTS Model settings
		if (!newConfig.tts_models) newConfig.tts_models = {};
		dom.ttsSettingsForm.querySelectorAll('input, select').forEach(input => {
			const modelId = input.dataset.modelId;
			const key = input.dataset.key;
			if (!modelId || !key) return;

			if (!newConfig.tts_models[modelId]) newConfig.tts_models[modelId] = {};
			
			newConfig.tts_models[modelId][key] = input.value;
		});
		

		// Audio export settings
		newConfig.audio_export.format = dom.exportFormat.value;
		newConfig.audio_export.quality = dom.exportQuality.value;

		try {
			setStatus('æ­£åœ¨ä¿å­˜æ‰€æœ‰è®¾ç½®...', 'info');
			const result = await fetchFromServer('/api/update_llm_config', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ config: newConfig })
			});
			state.globalConfig = newConfig;
			setStatus(result.message, 'success');
			return true;
		} catch (error) {
			setStatus(`ä¿å­˜è®¾ç½®å¤±è´¥: ${error.message}`, 'error');
			return false;
		}
	}

	dom.settingsBtn.addEventListener('click', () => {
		renderGlobalSettingsModal();
		dom.globalSettingsModal.classList.add('active'); // ä½¿ç”¨ active ç±»
	});

	// æ–°å¢è¿™ä¸ªäº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºæ ¹æ®â€œå¯ç”¨ä»£ç†â€å¤é€‰æ¡†æ˜¾ç¤º/éšè—è¯¦ç»†ä¿¡æ¯
	dom.settingsProxyEnabled.addEventListener('change', (e) => {
		dom.proxyDetailsGroup.style.display = e.target.checked ? 'block' : 'none';
	});

	dom.globalSettingsCloseBtn.addEventListener('click', () => {
		dom.globalSettingsModal.classList.remove('active'); // ç§»é™¤ active ç±»
	});

	dom.globalSettingsSaveBtn.addEventListener('click', async () => {
        const success = await saveAllSettings();
        if (success) {
            dom.globalSettingsModal.classList.remove('active'); // ç§»é™¤ active ç±»
            // Also update the main LLM selector to reflect the new default
            if (state.globalConfig.general) { // Add safety check
                
                dom.llmModelSelector.value = state.globalConfig.general.default_model;
                // åŒæ—¶ï¼Œä¹Ÿåº”è¯¥æ›´æ–° state.selectedLLM çš„å€¼ï¼Œä»¥ä¿æŒçŠ¶æ€ä¸€è‡´
                state.selectedLLM = state.globalConfig.general.default_model;
            }
			if (dom.contentTable.style.display === 'table') {
				renderContentTable();
				checkAllPlayableFiles();
			}
			
			const elevenlabsConfig = state.globalConfig.elevenlabs; // elevenlabs æ˜¯é¡¶çº§é”®
			const hasElevenlabsKey = elevenlabsConfig && elevenlabsConfig.api_key && elevenlabsConfig.api_key.trim() !== '';

            if (hasElevenlabsKey) {
                dom.transcribeBtn.style.display = 'inline-flex'; // å¦‚æœæœ‰ Keyï¼Œåˆ™æ˜¾ç¤ºæŒ‰é’®
                dom.transcribeBtn.title = ''; 
                // æ­¤æ—¶ï¼ŒtranscribeBtn åº”è¯¥å˜ä¸ºå¯ç”¨
                dom.transcribeBtn.disabled = false;
            } else {
                dom.transcribeBtn.style.display = 'none'; // æ²¡æœ‰ Keyï¼Œåˆ™éšè—æŒ‰é’®
            }
        }
    });
	
	dom.contentTableBody.addEventListener('change', (e) => {
		const row = e.target.closest('tr');
		if (!row) return;
		const lineId = row.id.replace('content-row-', ''); // <--- ä¿®æ”¹: è·å– line_id
		const item = state.novelData.find(d => d.line_id === lineId); // <--- ä¿®æ”¹: ä½¿ç”¨ line_id æŸ¥æ‰¾
		if (!item) return;

		let changed = false;
		
        if (e.target.matches('.speaker-select')) {
            const newSpeaker = e.target.value;
            if (item.speaker !== newSpeaker) {
                item.speaker = newSpeaker;
                item.timbre_override = null; 
                const newTimbre = state.characterMapping[newSpeaker];
				
                const timbreSelect = row.querySelector('.timbre-override-select');
                if (timbreSelect) {
                    // æ¸…ç©ºå½“å‰é€‰ä¸­é¡¹
                    timbreSelect.querySelector('option:checked')?.removeAttribute('selected');
                    
                    // æ‰¾åˆ°åŒ¹é…æ–°éŸ³è‰²çš„é€‰é¡¹å¹¶è®¾ç½®ä¸ºé€‰ä¸­
                    let optionToSelect = timbreSelect.querySelector(`option[value="${newTimbre}"]`);
                    
                    // å¦‚æœæ‰¾ä¸åˆ°ï¼ˆä¾‹å¦‚æ–°è§’è‰²æ²¡æœ‰åˆ†é…éŸ³è‰²ï¼‰ï¼Œåˆ™é€‰æ‹©å ä½ç¬¦
                    if (!optionToSelect) {
                        optionToSelect = timbreSelect.querySelector('option[disabled][selected]');
                        if (optionToSelect) optionToSelect.textContent = '-- è¯·é€‰æ‹©éŸ³è‰² --';
                        
                    } else {
                        optionToSelect.setAttribute('selected', 'selected');
                    }
                    
                    // æ‰‹åŠ¨è®¾ç½® value ä»¥ç¡®ä¿ UI åŒæ­¥
                    timbreSelect.value = newTimbre || '';

                }
                markChapterAsDirty(); // è§’è‰²å˜æ›´éœ€è¦ä¿å­˜
                // ç¡®ä¿ç¬¬äºŒåˆ—è§’è‰²åˆ—è¡¨ä¹Ÿèƒ½æ›´æ–°
                loadCharacters();
                setStatus(`ç¬¬ ${rowIndex + 1} è¡Œè§’è‰²å·²æ›´æ–°ä¸º: ${newSpeaker}ï¼ŒéŸ³è‰²å·²å›é€€åˆ°å…¶å…¨å±€é…ç½®ã€‚`, 'info');
                // é‡æ–°æ£€æŸ¥æ–‡ä»¶æ’­æ”¾çŠ¶æ€ï¼Œå› ä¸ºéŸ³è‰²æ”¹å˜äº†
                checkAllPlayableFiles();
            }
        }

		// 1. TTSæ¨¡å‹é€‰æ‹©å˜åŒ– (é€»è¾‘ä¸å˜)
		if (e.target.matches('.tts-model-select')) {
            const newTtsModelId = e.target.value;
            // (è·å– item å’Œ changed çš„é€»è¾‘ä¸å˜)

            if (item.tts_model !== newTtsModelId) {
                item.tts_model = newTtsModelId;
                changed = true;
                
                const modeSelect = row.querySelector('.mode-select');

                if (modeSelect) {
                    const emoPromptOption = modeSelect.querySelector('option[value="emo_prompt"]');
                    const shouldHaveEmoPrompt = newTtsModelId.toLowerCase().includes('indextts');

                    // 1. æ›´æ–°æ¨¡å¼é€‰é¡¹
                    if (shouldHaveEmoPrompt && !emoPromptOption) {
                         modeSelect.insertAdjacentHTML('beforeend', '<option value="emo_prompt">æƒ…ç»ªå‚è€ƒ</option>');
                    } else if (!shouldHaveEmoPrompt && emoPromptOption) {
                        if (modeSelect.value === 'emo_prompt') {
                           modeSelect.value = 'zero_shot';
                        }
                        emoPromptOption.remove();
                    }

                    // 3. è§¦å‘æ¨¡å¼åˆ‡æ¢çš„UIæ›´æ–°
                    const newDefaultMode = state.globalConfig.tts_models[newTtsModelId]?.default_mode || 'zero_shot';
                    modeSelect.value = newDefaultMode;
                    item.inference_mode = newDefaultMode;
                    
                    // 4. æ‰‹åŠ¨è°ƒç”¨ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥åŒæ­¥UIå¯è§æ€§
                    updateModeDependentUI(row, newDefaultMode);
                }
            }
		}

		if (e.target.matches('.mode-select')) {
            const newMode = e.target.value;
            if (item.inference_mode !== newMode) {
                item.inference_mode = newMode;
                changed = true;
            }
            // ä½¿ç”¨åŒä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ›´æ–°UI
            updateModeDependentUI(row, newMode);
		}

		// 3. ä¸´æ—¶éŸ³è‰² (timbre-override-select) å˜åŒ–
		if (e.target.matches('.timbre-override-select')) {
			const newTimbre = e.target.value;
			item.timbre_override = newTimbre;
			setStatus(`ç¬¬ ${rowIndex + 1} è¡Œçš„ä¸´æ—¶éŸ³è‰²å·²è®¾ç½®ä¸º: ${newTimbre}`, 'info');
			const generateBtn = row.querySelector('.btn-generate');
			if (generateBtn) generateBtn.disabled = !newTimbre;
			changed = true;
		}
		
		if (e.target.matches('.tone-select')) {
			const newTone = e.target.value;
			if (item.tone !== newTone) {
				item.tone = newTone;
				changed = true;
                // å¦‚æœç”¨æˆ·ä»â€œé»˜è®¤â€æˆ–è‡ªå®šä¹‰å€¼åˆ‡æ¢åˆ°äº†ä¸€ä¸ªæ ‡å‡†æƒ…ç»ªï¼Œ
                // é‚£ä¹ˆéœ€è¦ç§»é™¤ä¸´æ—¶çš„ <option> å…ƒç´ ï¼Œè®©ä¸‹æ‹‰æ¡†çœ‹èµ·æ¥æ›´å¹²å‡€ã€‚
                const tempOption = e.target.querySelector('option:disabled');
                if (tempOption) {
                    // åªæœ‰å½“ç”¨æˆ·é€‰æ‹©äº†ä¸€ä¸ªéç¦ç”¨çš„é€‰é¡¹æ—¶æ‰ç§»é™¤
                    if (!e.target.options[e.target.selectedIndex].disabled) {
                        e.target.removeChild(tempOption);
                    }
                }
			}
		}

		if (e.target.matches('.intensity-input')) {
			// å°†è¾“å…¥å€¼è½¬æ¢ä¸º1åˆ°10ä¹‹é—´çš„æ•´æ•°
			let newIntensity = parseInt(e.target.value, 10);
			if (isNaN(newIntensity)) newIntensity = 5; // å¦‚æœè¾“å…¥æ— æ•ˆï¼Œé»˜è®¤ä¸º5
			newIntensity = Math.max(1, Math.min(10, newIntensity)); // å¼ºåˆ¶çº¦æŸåœ¨1-10
			e.target.value = newIntensity; // å°†çº¦æŸåçš„å€¼å†™å›è¾“å…¥æ¡†
			
			// æ³¨æ„ï¼šè¿™é‡Œç”¨ != è€Œä¸æ˜¯ !==ï¼Œå› ä¸º item.intensity å¯èƒ½æ˜¯å­—ç¬¦ä¸² "5"
			if (item.intensity != newIntensity) {
				item.intensity = newIntensity;
				changed = true;
			}
		}
		
		// å¦‚æœæœ‰ä»»ä½•å˜åŒ–ï¼Œåˆ™æ¿€æ´»ä¿å­˜æŒ‰é’®
		if (changed) {
			markChapterAsDirty();
		}
	});

	// åœ¨ä¸Šé¢é‚£ä¸ªå‡½æ•°çš„æ­£ä¸‹æ–¹ï¼Œã€æ·»åŠ ã€‘è¿™ä¸ªæ–°çš„ input äº‹ä»¶ç›‘å¬å™¨
	dom.contentTableBody.addEventListener('input', (e) => {
		if (e.target.matches('.instruct-input')) {
			const row = e.target.closest('tr');
			if (!row) return;
			const lineId = row.id.replace('content-row-', ''); // <--- ä¿®æ”¹: è·å– line_id
			const item = state.novelData.find(d => d.line_id === lineId); // <--- ä¿®æ”¹: ä½¿ç”¨ line_id æŸ¥æ‰¾
			if (!item) return;
			
			// å°†ç”¨æˆ·è¾“å…¥çš„æŒ‡ä»¤æ–‡æœ¬å®æ—¶ä¿å­˜åˆ° state.novelData
			item.instruct_text = e.target.value;
			//markChapterAsDirty();
		}
	});
	
    const tabsContainer = document.querySelector('.settings-tabs');
    const contentPanels = document.querySelectorAll('.tab-content');
    
    tabsContainer.addEventListener('click', (e) => {
        if (e.target.matches('.tab-link')) {
            const tabId = e.target.dataset.tab;

            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„ active ç±»
            tabsContainer.querySelectorAll('.tab-link').forEach(tab => tab.classList.remove('active'));
            // éšè—æ‰€æœ‰å†…å®¹é¢æ¿
            contentPanels.forEach(panel => panel.classList.remove('active'));

            // ä¸ºè¢«ç‚¹å‡»çš„æ ‡ç­¾å’Œå¯¹åº”çš„å†…å®¹é¢æ¿æ·»åŠ  active ç±»
            e.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
    });
		
    // 1. ç‚¹å‡»ä¸»ç•Œé¢ä¸Šçš„åˆ é™¤å›¾æ ‡æŒ‰é’®
    dom.deleteNovelBtn.addEventListener('click', () => {
        const novelName = state.novelName;
        if (!novelName) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„å°è¯´é¡¹ç›®ã€‚');
            return;
        }

        // æ‰“å¼€ç¡®è®¤æ¨¡æ€æ¡†
        dom.novelToDeleteName.textContent = `ã€Œ${novelName}ã€`;
        dom.deleteConfirmInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
        dom.confirmDeleteBtn.disabled = true; // åˆå§‹ç¦ç”¨ç¡®è®¤æŒ‰é’®
        dom.deleteNovelModal.classList.add('active');
        dom.deleteConfirmInput.focus();
    });

    // 2. åœ¨æ¨¡æ€æ¡†çš„è¾“å…¥æ¡†ä¸­è¾“å…¥æ—¶ï¼Œè¿›è¡ŒéªŒè¯
    dom.deleteConfirmInput.addEventListener('input', () => {
        // åªæœ‰å½“ç”¨æˆ·è¾“å…¥çš„å†…å®¹å®Œå…¨ç­‰äº "åˆ é™¤" æ—¶ï¼Œæ‰æ¿€æ´»ç¡®è®¤æŒ‰é’®
        if (dom.deleteConfirmInput.value.trim() === 'åˆ é™¤') {
            dom.confirmDeleteBtn.disabled = false;
        } else {
            dom.confirmDeleteBtn.disabled = true;
        }
    });

    // 3. ç‚¹å‡»æ¨¡æ€æ¡†ä¸­çš„â€œå–æ¶ˆâ€æŒ‰é’®
    dom.cancelDeleteBtn.addEventListener('click', () => {
        dom.deleteNovelModal.classList.remove('active');
    });
    // ç‚¹å‡»èƒŒæ™¯å…³é—­
    dom.deleteNovelModal.addEventListener('click', (e) => {
        if (e.target === dom.deleteNovelModal) {
            dom.deleteNovelModal.classList.remove('active');
        }
    });

    // 4. ç‚¹å‡»æœ€ç»ˆçš„â€œç¡®è®¤åˆ é™¤â€æŒ‰é’®
    dom.confirmDeleteBtn.addEventListener('click', async () => {
        const novelName = state.novelName;
        if (!novelName) return;

        // è¿›å…¥å¤„ç†ä¸­çŠ¶æ€
        dom.confirmDeleteBtn.disabled = true;
        dom.confirmDeleteBtn.textContent = 'åˆ é™¤ä¸­...';
        setStatus(`æ­£åœ¨æ°¸ä¹…åˆ é™¤å°è¯´é¡¹ç›®: ${novelName}...`, 'info');

        try {
            const result = await fetchFromServer(`/api/delete_novel?novel_name=${encodeURIComponent(novelName)}`, {
                method: 'DELETE',
            });

            setStatus(result.message, 'success');
            dom.deleteNovelModal.classList.remove('active');

            // å…³é”®ï¼šåˆ·æ–°å°è¯´åˆ—è¡¨
            await loadNovels();
            // loadNovels åä¼šè‡ªåŠ¨å¡«å……ä¸‹æ‹‰æ¡†ï¼Œä½†æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡é€‰æ‹©é€»è¾‘æ¥æ¸…ç©ºå³ä¾§é¢æ¿
            handleNovelSelection();

        } catch (error) {
            setStatus(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
            alert(`åˆ é™¤å¤±è´¥: ${error.message}`); // åŒæ—¶ç”¨alertç»™å‡ºå¼ºæç¤º
        } finally {
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            dom.confirmDeleteBtn.textContent = 'ç¡®è®¤åˆ é™¤';
            // æ­¤æ—¶ç¡®è®¤æŒ‰é’®åº”è¯¥ä¿æŒç¦ç”¨ï¼Œå› ä¸ºè¾“å…¥æ¡†æ˜¯ç©ºçš„
            dom.confirmDeleteBtn.disabled = true; 
        }
    });
	
    dom.exportFormat.addEventListener('change', updateQualityOptions);
    dom.novelSelector.addEventListener('change', () => {
        handleNovelSelection(); // ç›´æ¥è°ƒç”¨ï¼Œä¸å†éœ€è¦å…¶ä»–é€»è¾‘
    });
    dom.uploadTxtLabelBtn.addEventListener('click', () => {
        dom.novelTxtFile.click(); // æ¨¡æ‹Ÿç‚¹å‡»éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†
    });
    dom.novelTxtFile.addEventListener('change', e => { if (e.target.files[0]) handleTxtFileUpload(e.target.files[0]); });
    dom.llmModelSelector.addEventListener('change', () => {
        state.selectedLLM = dom.llmModelSelector.value;
        console.log(`LLM for processing changed to: ${state.selectedLLM}`);
    });
    
	// æ›¿æ¢åŸæœ‰çš„ dom.chapterListEl click äº‹ä»¶ç›‘å¬å™¨
    dom.chapterListEl.addEventListener('click', e => {
        const checkbox = e.target.closest('input.chapter-checkbox');
        
        // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯å¤é€‰æ¡†ï¼ˆæˆ–è€… label è§¦å‘äº†å¤é€‰æ¡†ç‚¹å‡»ï¼‰ï¼Œåˆ™å¿½ç•¥
        if (!checkbox) return;

        const visibleCheckboxes = Array.from(dom.chapterListEl.querySelectorAll('.chapter-checkbox'));
        const currentIndex = visibleCheckboxes.indexOf(checkbox);

        // === é€»è¾‘ A: èŒƒå›´é€‰æ‹©æ¨¡å¼ (æ–°å¢é€»è¾‘) ===
        if (state.isRangeSelectMode) {
            // å¦‚æœè¿˜æ²¡æœ‰é€‰èµ·ç‚¹
            if (!state.rangeStartCheckbox) {
                state.rangeStartCheckbox = checkbox;
                checkbox.checked = true; // ç¡®ä¿èµ·ç‚¹è¢«é€‰ä¸­
                
                // ç»™æ‰€åœ¨çš„è¡Œæ·»åŠ è§†è§‰æç¤º
                checkbox.closest('li').classList.add('range-start-item');
                
                setStatus(`å·²è®¾å®šèµ·ç‚¹: ${checkbox.dataset.title}ã€‚è¯·ç‚¹å‡»ã€ç»“æŸã€‘ç« èŠ‚ã€‚`, 'info');
                
                // æ­¤æ—¶ä¸é€€å‡ºï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»ç¬¬äºŒä¸ªç‚¹
                updateGlobalButtons();
                handleChapterSelectionChange();
                return; 
            } 
            // å¦‚æœå·²ç»æœ‰äº†èµ·ç‚¹ï¼Œç°åœ¨ç‚¹å‡»çš„æ˜¯ç»ˆç‚¹
            else {
                const startBox = state.rangeStartCheckbox;
                const endBox = checkbox;
                
                const startIndex = visibleCheckboxes.indexOf(startBox);
                const endIndex = currentIndex;

                if (startIndex !== -1 && endIndex !== -1) {
                    const min = Math.min(startIndex, endIndex);
                    const max = Math.max(startIndex, endIndex);

                    // é€‰ä¸­åŒºé—´å†…çš„æ‰€æœ‰ç« èŠ‚
                    for (let i = min; i <= max; i++) {
                        visibleCheckboxes[i].checked = true;
                    }

                    setStatus(`èŒƒå›´é€‰æ‹©å®Œæˆï¼Œå·²é€‰ä¸­ ${max - min + 1} ä¸ªç« èŠ‚ã€‚`, 'success');
                }

                // å®Œæˆåè‡ªåŠ¨å…³é—­æ¨¡å¼
                state.isRangeSelectMode = false;
                state.rangeStartCheckbox = null;
                dom.rangeSelectBtn.classList.remove('btn-active-mode');
                dom.chapterListEl.classList.remove('range-selection-active');
                dom.chapterListEl.querySelectorAll('li').forEach(li => li.classList.remove('range-start-item'));
                
                updateGlobalButtons();
                handleChapterSelectionChange();
                return;
            }
        }

        // === é€»è¾‘ B: Shift é”®å¤šé€‰ (åŸæœ‰é€»è¾‘ä¿æŒä¸å˜) ===
        if (e.shiftKey && state.lastCheckedIndex > -1 && state.lastCheckedIndex !== currentIndex) {
            const start = Math.min(currentIndex, state.lastCheckedIndex);
            const end = Math.max(currentIndex, state.lastCheckedIndex);
            
            const anchorCheckbox = visibleCheckboxes[state.lastCheckedIndex];
            const targetState = anchorCheckbox.checked;

            for (let i = start; i <= end; i++) {
                visibleCheckboxes[i].checked = targetState;
            }
        }

        // æ›´æ–° lastCheckedIndexï¼Œä¸ºä¸‹ä¸€æ¬¡ Shift ç‚¹å‡»åšå‡†å¤‡
        state.lastCheckedIndex = currentIndex;
        
        // å»¶è¿Ÿè°ƒç”¨æ›´æ–°ï¼Œç¡®ä¿ checkbox çŠ¶æ€å·²å˜æ›´
        setTimeout(() => {
            updateGlobalButtons();
            handleChapterSelectionChange();
        }, 0);
    });


    dom.selectAllChaptersBtn.addEventListener('click', () => {
        dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => cb.checked = true);
        updateGlobalButtons();
		handleChapterSelectionChange();
    });
    dom.selectNoneChaptersBtn.addEventListener('click', () => {
        dom.chapterListEl.querySelectorAll('.chapter-checkbox').forEach(cb => cb.checked = false);
        updateGlobalButtons();
		handleChapterSelectionChange();
    });

    dom.processTxtBtn.addEventListener('click', processTxtChapters);
    dom.processAllBtn.addEventListener('click', processAllAndSplice);

    // *** æ ¸å¿ƒä¿®æ”¹ 4: ä¸ºæ‰¹é‡ä¸‹è½½æŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ ***
    dom.downloadSpliceBtn.addEventListener('click', async () => {
        const selectedCheckboxes = dom.chapterListEl.querySelectorAll('.chapter-checkbox:checked');
        const filePathsToDownload = [];
        
        if (state.novelName && state.allNovelsData[state.novelName]) {
            const novelChapters = state.allNovelsData[state.novelName].chapters;
            for (const checkbox of selectedCheckboxes) {
                const chapterTitle = checkbox.dataset.title;
                const chapterData = novelChapters.find(c => c.title === chapterTitle);
                
                // åªæ·»åŠ å·²æ‹¼æ¥çš„ç« èŠ‚
                if (chapterData && chapterData.spliced) {
                    const novel = state.novelName;
                    const chapter = sanitizeTitleForFilename(chapterTitle);
                    const format = state.globalConfig.audio_export?.format || 'mp3';
					filePathsToDownload.push(`${novel}/${chapter}.${format}`);
                }
            }
        }

        if (filePathsToDownload.length === 0) {
            alert('æ²¡æœ‰æ‰¾åˆ°å¯ä»¥ä¸‹è½½çš„å·²æ‹¼æ¥æ–‡ä»¶ã€‚');
            return;
        }

        setStatus(`æ­£åœ¨æ‰“åŒ… ${filePathsToDownload.length} ä¸ªæ–‡ä»¶...`, 'info');
        dom.downloadSpliceBtn.disabled = true;
        dom.downloadSpliceBtn.textContent = 'æ‰“åŒ…ä¸­...';

        try {
            const response = await fetch('/api/download_spliced_chapters', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_paths: filePathsToDownload })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.detail || 'æ‰“åŒ…å¤±è´¥ã€‚');
            }

            // å°†å“åº”ä½“è½¬æ¢ä¸º Blob
            const blob = await response.blob();
            
            // ä»å“åº”å¤´ä¸­è·å–æ¨èçš„æ–‡ä»¶å
            const contentDisposition = response.headers.get('content-disposition');
            let filename = 'chapters.zip'; // é»˜è®¤æ–‡ä»¶å
            if (contentDisposition) {
                const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                if (filenameMatch.length > 1) {
                    filename = filenameMatch[1];
                }
            }

            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ a æ ‡ç­¾æ¥è§¦å‘ä¸‹è½½
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // é‡Šæ”¾ Object URL
            URL.revokeObjectURL(link.href);
            setStatus('æ–‡ä»¶æ‰“åŒ…ä¸‹è½½æˆåŠŸï¼', 'success');

        } catch (error) {
            setStatus(`ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
        } finally {
            dom.downloadSpliceBtn.disabled = false;
            dom.downloadSpliceBtn.textContent = 'ä¸‹è½½å£°éŸ³';
        }
    });

	
	dom.chapterPlayStopBtn.addEventListener('click', toggleChapterAudio);

    dom.characterListEl.addEventListener('click', e => {
        const li = e.target.closest('li.selectable');
		if (e.target.matches('.btn-profile')) {
			e.stopPropagation(); // <-- é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘ li çš„ç‚¹å‡»é€»è¾‘
			showProfileModal(e.target.dataset.characterName);
			return; // ç»“æŸå¤„ç†
		}
		if (e.target.matches('.audio-player-btn')) { 
			e.stopPropagation(); // <-- é˜»æ­¢äº‹ä»¶å†’æ³¡
			const timbreName = state.characterMapping[e.target.closest('li').dataset.characterName];
			if(timbreName) toggleSimpleAudio(e.target, `/wav/${timbreName}/1.wav`);
			return; // ç»“æŸå¤„ç†
		}
		
		// å¤„ç†åˆ é™¤éŸ³è‰²æŒ‰é’®ç‚¹å‡»
		if (e.target.matches('.btn-delete-timbre-assignment')) {
			const charName = e.target.dataset.characterName;
			e.stopPropagation(); // <-- é˜»æ­¢äº‹ä»¶å†’æ³¡
			if (charName && state.characterMapping[charName]) {
				if (confirm(`æ‚¨ç¡®å®šè¦åˆ é™¤è§’è‰² '${charName}' å·²åˆ†é…çš„éŸ³è‰² '${state.characterMapping[charName]}' å—ï¼Ÿ`)) {
					state.characterMapping[charName] = null; // å°†éŸ³è‰²è®¾ç½®ä¸º null
					setStatus(`å·²åˆ é™¤è§’è‰² '${charName}' çš„éŸ³è‰²åˆ†é…ã€‚`, 'info');
					// é‡æ–°æ¸²æŸ“è§’è‰²åˆ—è¡¨ä»¥æ›´æ–° UI
					loadCharacters(); 
					// è§¦å‘è‡ªåŠ¨ä¿å­˜
					saveConfig(); 
					// å¦‚æœå†…å®¹ç¼–è¾‘å™¨æ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿéœ€è¦åˆ·æ–°ï¼Œä»¥æ›´æ–°éŸ³è‰²ä¸‹æ‹‰æ¡†çš„æ˜¾ç¤º
					if (state.selectedChapterPaths.length === 1 && dom.contentTable.style.display === 'table') {
						renderContentTable();
						checkAllPlayableFiles();
					}
				}
			}
			return; // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°çˆ¶å…ƒç´ ï¼ˆä¾‹å¦‚ li çš„ç‚¹å‡»äº‹ä»¶ï¼‰
		}
		
        if (!li) return; // å¦‚æœæ²¡ç‚¹åˆ°è¡Œï¼Œå°±ä»€ä¹ˆéƒ½ä¸åš

		const clickedCharacterName = li.dataset.characterName;
		
		// å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰å·²é€‰ä¸­çš„è§’è‰²ï¼Œåˆ™å–æ¶ˆé€‰ä¸­
		if (state.selectedCharacter === clickedCharacterName) {
			state.selectedCharacter = null; // å–æ¶ˆé€‰ä¸­
			li.classList.remove('selected'); // ç§»é™¤é€‰ä¸­æ ·å¼
			updateTimbreConflictHighlight(null); // æ¸…é™¤éŸ³è‰²é«˜äº®
			setStatus('å·²å–æ¶ˆè§’è‰²é€‰ä¸­çŠ¶æ€ã€‚', 'info');
			document.querySelectorAll('#content-table-body tr').forEach(row => {
				row.classList.remove('highlighted-row');
			});
			return; // ç»“æŸå¤„ç†ï¼Œä¸æ‰§è¡Œåç»­çš„é€‰ä¸­é€»è¾‘
		}
		
        // --- 1. è§’è‰²é€‰æ‹©é€»è¾‘ (ä¿æŒä¸å˜) ---
        state.selectedCharacter = li.dataset.characterName;
        // ç§»é™¤æ‰€æœ‰æ—§çš„é€‰ä¸­æ ·å¼
        document.querySelectorAll('#character-list li.selected').forEach(el => el.classList.remove('selected'));
        // ä¸ºå½“å‰è¡Œæ·»åŠ é€‰ä¸­æ ·å¼
        li.classList.add('selected');
        updateTimbreConflictHighlight(state.selectedCharacter);
        setStatus(`å·²é€‰ä¸­è§’è‰²: ${state.selectedCharacter}`, 'info');
		
        // *** 2: å®ç°é«˜äº®å’Œæ»šåŠ¨é€»è¾‘ ***

        // a. æ£€æŸ¥ç¼–è¾‘å™¨æ˜¯å¦å¯è§
        if (dom.editorView.style.display !== 'block' || state.novelData.length === 0) {
            return; // å¦‚æœç¼–è¾‘å™¨ä¸å¯è§æˆ–æ²¡æœ‰å†…å®¹ï¼Œåˆ™ä¸æ‰§è¡Œåç»­æ“ä½œ
        }

        const characterToHighlight = state.selectedCharacter;
        const tableRows = dom.contentTableBody.querySelectorAll('tr');
        let firstHighlightedRow = null;

        // b. éå†æ‰€æœ‰è¡Œï¼Œè¿›è¡Œé«˜äº®å¤„ç†
		state.novelData.forEach(item => {
			const rowId = `content-row-${item.line_id}`;
			const row = document.getElementById(rowId);
			if (!row) return; // æ‰¾ä¸åˆ°è¡Œï¼Œè·³è¿‡

			// ç§»é™¤æ—§çš„é«˜äº®ï¼Œæ— è®ºå¦‚ä½•éƒ½å…ˆç§»é™¤
			row.classList.remove('highlighted-row');

			// b. åŒ¹é…å’Œé«˜äº®
			if (item.speaker === characterToHighlight) {
				row.classList.add('highlighted-row');
				// è®°å½•ç¬¬ä¸€ä¸ªè¢«é«˜äº®çš„è¡Œ
				if (!firstHighlightedRow) {
					firstHighlightedRow = row;
				}
			}
		});

        // c. å¦‚æœæ‰¾åˆ°äº†åŒ¹é…çš„è¡Œï¼Œåˆ™æ»šåŠ¨åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…è¡Œ
        if (firstHighlightedRow) {
			firstHighlightedRow.scrollIntoView({
				behavior: 'smooth',
				block: 'center'
			});
            setStatus(`å·²é«˜äº®è§’è‰²ã€Œ${characterToHighlight}ã€çš„æ‰€æœ‰å¯¹è¯ã€‚`, 'info');
        } else {
             setStatus(`å½“å‰ç« èŠ‚å†…å®¹ä¸­æœªæ‰¾åˆ°è§’è‰²ã€Œ${characterToHighlight}ã€çš„å¯¹è¯ã€‚`, 'info');
        }
    });
    dom.characterListEl.addEventListener('dblclick', e => {
        const li = e.target.closest('li.character-row');
        if (li) {
            const characterName = li.dataset.characterName;
            showCharacterDialogues(characterName);
        }
    });
	
	
	// 6. æ¨¡æ€æ’­æ”¾å™¨å†…éƒ¨çš„äº‹ä»¶ç›‘å¬å™¨ 
	dom.playerPlayPauseBtn.addEventListener('click', () => {
		if (state.globalAudioPlayer) {
			if (state.globalAudioPlayer.paused) {
				state.globalAudioPlayer.play();
			} else {
				state.globalAudioPlayer.pause();
			}
		}
	});

	dom.playerProgressBar.addEventListener('input', () => {
		if (state.globalAudioPlayer) {
			state.globalAudioPlayer.currentTime = dom.playerProgressBar.value;
		}
	});

	dom.playerModalCloseBtn.addEventListener('click', stopAllAudio);
	dom.audioPlayerModal.addEventListener('click', (e) => {
		if (e.target === dom.audioPlayerModal) {
			stopAllAudio();
		}
	});

    // *** æ ¸å¿ƒä¿®æ”¹ 4: ä¸ºæ–°æ¨¡æ€æ¡†æ·»åŠ å…³é—­äº‹ä»¶ ***
    dom.dialogueModalCloseBtn.addEventListener('click', () => {
        dom.dialogueModal.classList.remove('active'); // ç§»é™¤ active ç±»
    });
    dom.dialogueModal.addEventListener('click', (e) => {
        if (e.target === dom.dialogueModal) {
            dom.dialogueModal.classList.remove('active');
        }
    });

    dom.timbreFile.addEventListener('change', e => { if (e.target.files[0]) showTimbreUploadModal(e.target.files[0]); e.target.value = ''; });
    dom.confirmUploadBtn.addEventListener('click', handleTimbreUpload);
    dom.cancelUploadBtn.addEventListener('click', hideTimbreUploadModal);
    	
	dom.contentTableBody.addEventListener('click', async (event) => {
		const target = event.target; // æ­£ç¡®è·å–äº‹ä»¶ç›®æ ‡
		const targetRow = target.closest('tr'); // æ­£ç¡®è·å–ç‚¹å‡»çš„è¡Œ
		if (!targetRow) return;
		
		const lineId = targetRow.id.replace('content-row-', ''); // <--- ä¿®æ”¹: è·å– line_id

		if (target.matches('.btn-fine-tune')) {
			event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
            // åœ¨æ‰“å¼€å¾®è°ƒæ¨¡æ€æ¡†å‰ï¼Œæ£€æŸ¥ç« èŠ‚æ˜¯å¦ dirty
            if (state.isChapterDirty) { // <--- æ–°å¢
                alert('ç« èŠ‚å†…å®¹å·²ä¿®æ”¹ï¼Œè¯·å…ˆä¿å­˜æ‰èƒ½è¿›è¡Œç”Ÿæˆæˆ–å¾®è°ƒæ“ä½œã€‚');
                return;
            }
			const rowIndex = state.novelData.findIndex(item => item.line_id === lineId); // æ‰¾åˆ°å¯¹åº”çš„ index ä¼ ç»™ openFineTuneModal
			if (rowIndex !== -1) {
				openFineTuneModal(rowIndex); // æ‰“å¼€å¾®è°ƒæ¨¡æ€æ¡†
			} else {
				setStatus(`é”™è¯¯ï¼šæœªæ‰¾åˆ° line_id ä¸º ${lineId} çš„è¡Œæ•°æ®ã€‚`, 'error');
			}
			return;
		}

		// --- å¤„ç†è¡Œå†…çš„åˆ é™¤å’Œæ’å…¥æŒ‰é’® ---
		if (target.matches('.btn-delete-row')) {
            const indexToDelete = state.novelData.findIndex(item => item.line_id === lineId);
			if (indexToDelete !== -1 && confirm(`æ‚¨ç¡®å®šè¦åˆ é™¤ç¬¬ ${indexToDelete + 1} è¡Œå—ï¼Ÿ`)) {
				state.novelData.splice(indexToDelete, 1);
				renderContentTable(); // é‡æ–°æ¸²æŸ“è¡¨æ ¼ï¼Œä¼šåˆ·æ–°æ‰€æœ‰ç´¢å¼•å’Œé€‰ä¸­çŠ¶æ€
				markChapterAsDirty(); 
                await checkAllPlayableFiles(); 
                await refreshTableStructure();
			}
			return; // å¤„ç†å®Œæ¯•ï¼Œé˜»æ­¢å…¶ä»–äº‹ä»¶
		}
		if (target.matches('.btn-insert-row')) {
            const indexToInsertAfter = state.novelData.findIndex(item => item.line_id === lineId);
			const newRow = { speaker: "æ—ç™½", content: "ï¼ˆæ–°æ’å…¥çš„è¡Œï¼‰", tone: "å¹³é™", intensity: 5, delay: 500, line_id: generateUUID() }; 
			state.novelData.splice(indexToInsertAfter + 1, 0, newRow);
			renderContentTable(); // é‡æ–°æ¸²æŸ“è¡¨æ ¼ï¼Œä¼šåˆ·æ–°æ‰€æœ‰ç´¢å¼•å’Œé€‰ä¸­çŠ¶æ€
			markChapterAsDirty(); 
            await checkAllPlayableFiles(); 
            await refreshTableStructure();
			return; // å¤„ç†å®Œæ¯•ï¼Œé˜»æ­¢å…¶ä»–äº‹ä»¶
		}

		// --- è¡Œå†…æ’­æ”¾æŒ‰é’®çš„é€»è¾‘ ---
		if (target.matches('.btn-play')) { 
            if (state.generatedFiles[lineId] && state.selectedChapterPaths.length === 1) { 
				const fullChapterPath = state.selectedChapterPaths[0];
				const pathParts = fullChapterPath.replace(/\.json$/, '').split(/[/\\]/);
				const originalChapterTitle = pathParts[pathParts.length - 1];
				const safeChapterName = sanitizeTitleForFilename(originalChapterTitle);
                const audioPath = `/output/${state.novelName}/wavs/${safeChapterName}/${state.generatedFiles[lineId]}`; 
				toggleSimpleAudio(target, audioPath); // target å°±æ˜¯æ’­æ”¾æŒ‰é’®
			}
			return; // å¤„ç†å®Œæ¯•ï¼Œé˜»æ­¢å…¶ä»–äº‹ä»¶
		}
	});


	// New listener for adding a row at the end
	dom.addRowStartBtn.addEventListener('click', async () => {
		const newRow = { speaker: "æ—ç™½", content: "ï¼ˆæ–°æ’å…¥çš„è¡Œï¼‰", tone: "å¹³é™", intensity: 5, delay: 500, line_id: generateUUID() }; 
		state.novelData.unshift(newRow);
		renderContentTable();
		markChapterAsDirty(); 
        await checkAllPlayableFiles(); 
	});

	// Modify the existing blur listener to also enable the save button
	dom.contentTableBody.addEventListener('blur', (event) => {
		if (event.target.matches('.content-cell')) {
			const row = event.target.closest('tr');
            const lineId = row.id.replace('content-row-', '');
            const item = state.novelData.find(d => d.line_id === lineId);
			const newContent = event.target.textContent.trim();
            if (item && item.content !== newContent) { //ä½¿ç”¨ item
				item.content = newContent;
				setStatus(`è¡Œ ${item.line_id}: å†…å®¹å·²æ›´æ–°`, 'info'); //ä¿®æ”¹çŠ¶æ€æ¶ˆæ¯
				markChapterAsDirty(); // Enable save button on content change
				if (state.isProofreadMode) {
					updateSingleProofreadDisplay(lineId); 
				}
			}
		}
	}, true);

	// New listener for the save button
	
	// å¾®è°ƒæ¨¡æ€æ¡†ä¸­çš„â€œç”ŸæˆéŸ³é¢‘â€æŒ‰é’®
	dom.fineTuneGenerateBtn.addEventListener('click', async () => {
		const rowIndex = currentFineTuneRowIndex;
		if (rowIndex === -1 || !state.novelData[rowIndex]) return;

		const itemForPayload = state.novelData[rowIndex];
		dom.fineTuneGenerateBtn.disabled = true;
		dom.fineTuneGenerateBtn.textContent = 'ç”Ÿæˆä¸­...';
        dom.fineTuneEffectsBtn.disabled = true; 
        dom.fineTunePlayBtn.disabled = true; 
		
		// ä»æ¨¡æ€æ¡†æ§ä»¶è·å–å½“å‰å‚æ•°
		const payloadTtsModel = dom.fineTuneTtsModelSelect.value;
		const payloadInferenceMode = dom.fineTuneModeSelect.value;
		const payloadInstructText = dom.fineTuneInstructInput.value.trim();
		const payloadEmoPrompt = dom.fineTuneEmoPromptSelect.value || null;
		let payloadEmoWeight = parseInt(dom.fineTuneEmoWeightInput.value, 10);
		if (isNaN(payloadEmoWeight)) payloadEmoWeight = 5;
		payloadEmoWeight = Math.max(0, Math.min(10, payloadEmoWeight));

		const lineIdForPayload = itemForPayload.line_id;
		
		const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
		const originalChapterTitle = pathParts.length > 1 ? pathParts[1] : pathParts[0];
		const currentChapterName = sanitizeTitleForFilename(originalChapterTitle);
		
		const timbreOverrideEl = document.querySelector(`#content-row-${itemForPayload.line_id} .timbre-override-select`); 
		const timbre = timbreOverrideEl ? timbreOverrideEl.value : (state.characterMapping[itemForPayload.speaker] || null);
		
		if (!timbre) { 
			setStatus(`é”™è¯¯: è§’è‰²'${itemForPayload.speaker}'æœªåˆ†é…éŸ³è‰²`, 'error');
			dom.fineTuneGenerateBtn.disabled = false;
			dom.fineTuneGenerateBtn.textContent = 'ç”ŸæˆéŸ³é¢‘';
			return; 
		}
		
		const payload = {
			novel_name: state.novelName, 
			chapter_name: currentChapterName, 
            line_identifier: lineIdForPayload, 
			speaker: itemForPayload.speaker, 
			timbre: timbre, 
			tts_text: itemForPayload.content,
			inference_mode: payloadInferenceMode, 
			instruct_text: payloadInstructText,   
			tts_model: payloadTtsModel,         
			tone: itemForPayload.tone,
			intensity: itemForPayload.intensity,
			emo_audio_prompt: payloadEmoPrompt,   
			emo_weight: payloadEmoWeight         
		};

		try {
			const fileName = await generateSpeech(payload);
			
			if (fileName) {
                state.generatedFiles[lineIdForPayload] = fileName;
                const playBtn = document.querySelector(`#content-row-${lineIdForPayload} .btn-play`); 
				if (playBtn) {
					playBtn.disabled = false;
					playBtn.classList.add('playable');
					playBtn.classList.remove('disabled'); 
				}
				setStatus(`ç¬¬ ${rowIndex + 1} è¡ŒéŸ³é¢‘ç”ŸæˆæˆåŠŸï¼`, 'success');
				// ç”ŸæˆæˆåŠŸåï¼Œæ›´æ–°æ¨¡æ€æ¡†çš„æ’­æ”¾å’Œç‰¹æ•ˆæŒ‰é’®
				dom.fineTunePlayBtn.disabled = false;
				dom.fineTuneEffectsBtn.disabled = false;
			} else {
				setStatus(`ç¬¬ ${rowIndex + 1} è¡ŒéŸ³é¢‘ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æ—¥å¿—ã€‚`, 'error');
			}
		} catch (err) {
			setStatus(`ç”Ÿæˆå¤±è´¥: ${err.message}`, 'error');
		} finally {
			dom.fineTuneGenerateBtn.disabled = false;
			dom.fineTuneGenerateBtn.textContent = 'ç”ŸæˆéŸ³é¢‘';
		}
	});

	// å¾®è°ƒæ¨¡æ€æ¡†ä¸­çš„â€œæ’­æ”¾â€æŒ‰é’®
	dom.fineTunePlayBtn.addEventListener('click', () => {
		if (!state.currentFineTuneLineId || !state.generatedFiles[state.currentFineTuneLineId]) return;
		
		const fullChapterPath = state.selectedChapterPaths[0];
		const pathParts = fullChapterPath.replace(/\.json$/, '').split(/[/\\]/);
		const originalChapterTitle = pathParts[pathParts.length - 1];
		const safeChapterName = sanitizeTitleForFilename(originalChapterTitle);
        const audioPath = `/output/${state.novelName}/wavs/${safeChapterName}/${state.generatedFiles[state.currentFineTuneLineId]}`;
		
		toggleSimpleAudio(dom.fineTunePlayBtn, audioPath);
	});

	// å¾®è°ƒæ¨¡æ€æ¡†ä¸­çš„â€œç‰¹æ•ˆâ€æŒ‰é’®
	dom.fineTuneEffectsBtn.addEventListener('click', (event) => {
		const rowIndex = currentFineTuneRowIndex;
		if (rowIndex === -1 || !state.novelData[rowIndex] || !state.generatedFiles[rowIndex]) return;

		const effectBtn = event.target;
		const popoverContainer = effectBtn.closest('.popover-container');
		if (popoverContainer) {
			popoverContainer.classList.toggle('is-active'); // åˆ‡æ¢ popover çš„æ˜¾ç¤ºçŠ¶æ€
		}
	});

	// å¾®è°ƒæ¨¡æ€æ¡†ç‰¹æ•ˆèœå•å†…éƒ¨æŒ‰é’®ç‚¹å‡» (ä¸åº•éƒ¨çš„ç‰¹æ•ˆèœå•é€»è¾‘ç±»ä¼¼)
	dom.fineTuneModal.addEventListener('click', async (event) => {
		if (!state.currentFineTuneLineId || !state.generatedFiles[state.currentFineTuneLineId]) return;

		const target = event.target;
		if (!target.matches('.effects-menu button')) return;

		const effectBtn = target; // èœå•å†…éƒ¨çš„æŒ‰é’®
		const mainEffectsBtn = dom.fineTuneEffectsBtn; // ä¸»ç‰¹æ•ˆæŒ‰é’®

		// å¦‚æœç‚¹å‡»çš„æ˜¯â€œå¤šäººåŒå£°â€ï¼Œåˆ™æ˜¾ç¤ºæ–°æ¨¡æ€æ¡†
		if (effectBtn.dataset.effect === 'choral') {
			// å…³é—­ç‰¹æ•ˆèœå•
			mainEffectsBtn.closest('.popover-container').classList.remove('is-active');
			const rowIndex = state.novelData.findIndex(item => item.line_id === state.currentFineTuneLineId);
			if (rowIndex !== -1) {
				openChoralModal(rowIndex); 
			} else {
				setStatus(`é”™è¯¯ï¼šæœªèƒ½æ‰¾åˆ° line_id ä¸º ${state.currentFineTuneLineId} çš„è¡Œæ•°æ®ã€‚`, 'error');
			}
			return;
		}
		
		// --- å¤„ç†å…¶ä»–å•é¡¹ç‰¹æ•ˆ ---
		const effectType = effectBtn.dataset.effect;
        const fileName = state.generatedFiles[state.currentFineTuneLineId]; 

		const pathParts = state.selectedChapterPaths[0].replace('.json', '').split(/[/\\]/);
		const originalChapterTitle = pathParts.length > 1 ? pathParts[1] : pathParts[0];
		const currentChapterName = sanitizeTitleForFilename(originalChapterTitle);
		
		const payload = {
			novel_name: state.novelName,
			chapter_name: currentChapterName,
			file_name: fileName,
			effect_type: effectType
		};

		const originalEffectBtnText = effectBtn.innerHTML;
		effectBtn.innerHTML = `<span>â³</span> å¤„ç†ä¸­...`;
		effectBtn.disabled = true;
		mainEffectsBtn.disabled = true;
		setStatus(`æ­£åœ¨åº”ç”¨ "${effectBtn.textContent.trim()}" ç‰¹æ•ˆ...`, 'info');
		
		try {
			const result = await fetchFromServer('/api/apply_effect', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			});
			setStatus(result.message, 'success');
			// ç‰¹æ•ˆåº”ç”¨æˆåŠŸåï¼Œè‡ªåŠ¨æ’­æ”¾ç»“æœ
			const audioPath = `/output/${state.novelName}/wavs/${currentChapterName}/${fileName}`;
			toggleSimpleAudio(dom.fineTunePlayBtn, audioPath); // æ’­æ”¾æ¨¡æ€æ¡†å†…çš„æ’­æ”¾æŒ‰é’®
		} catch (err) {
			setStatus(`ç‰¹æ•ˆåº”ç”¨å¤±è´¥: ${err.message}`, 'error');
		} finally {
			effectBtn.innerHTML = originalEffectBtnText;
			effectBtn.disabled = false;
			mainEffectsBtn.disabled = false;
			// å…³é—­èœå•
			mainEffectsBtn.closest('.popover-container').classList.remove('is-active');
		}
	});

	// å¾®è°ƒæ¨¡æ€æ¡†çš„å…³é—­æŒ‰é’®
	dom.fineTuneCloseBtn.addEventListener('click', () => {
		dom.fineTuneModal.classList.remove('active');
		currentFineTuneRowIndex = -1; // é‡ç½®å½“å‰å¾®è°ƒè¡Œç´¢å¼•
        state.currentFineTuneLineId = null; 
		stopAllAudio(); // ç¡®ä¿å…³é—­æ—¶åœæ­¢æ’­æ”¾
	});

	// å¾®è°ƒæ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­
	dom.fineTuneModal.addEventListener('click', (e) => {
		if (e.target === dom.fineTuneModal) {
			dom.fineTuneModal.classList.remove('active');
			state.currentFineTuneRowIndex = -1; // é‡ç½®å½“å‰å¾®è°ƒè¡Œç´¢å¼•
			state.currentFineTuneLineId = null; 
			stopAllAudio(); // ç¡®ä¿å…³é—­æ—¶åœæ­¢æ’­æ”¾
		}
	});
	dom.saveChapterBtn.addEventListener('click', async () => {
		if (state.selectedChapterPaths.length !== 1) return;
		const filepath = state.selectedChapterPaths[0];
		setStatus('æ­£åœ¨ä¿å­˜ç« èŠ‚ä¿®æ”¹...', 'info');
		try {
			const payload = { filepath: filepath, content: state.novelData };
			const result = await fetchFromServer('/api/update_chapter_content', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			});
			setStatus(result.message, 'success');
			dom.saveChapterBtn.disabled = true; // ä¿å­˜æˆåŠŸåç¦ç”¨æŒ‰é’®
            state.isChapterDirty = false; // ä¿å­˜æˆåŠŸåé‡ç½® dirty æ ‡å¿—			
            loadCharacters(); 
            if (state.isProofreadMode) {
                await refreshEditorContent(); 
            }
		} catch (error) {
			setStatus(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
		}
	});
    dom.profileModalCloseBtn.addEventListener('click', () => dom.profileModal.classList.remove('active'));
    dom.profileModal.addEventListener('click', (e) => { if (e.target === dom.profileModal) dom.profileModal.classList.remove('active'); });
	
	function getTimbreCategory(timbreName) {
		if (!timbreData || !timbreData.categories || !timbreData.unassigned) {
			return null; // æ•°æ®æœªåŠ è½½
		}
		// æ£€æŸ¥æœªåˆ†ç±»
		if (timbreData.unassigned.includes(timbreName)) {
			return "æœªåˆ†ç±»";
		}
		// æ£€æŸ¥åˆ†ç±»
		for (const categoryName in timbreData.categories) {
			if (timbreData.categories[categoryName].includes(timbreName)) {
				return categoryName;
			}
		}
		return null; // æœªæ‰¾åˆ°
	}

	function checkIfTimbreConflicts(targetCharacter, potentialTimbre) {
		if (!targetCharacter || !potentialTimbre || !state.novelName || !state.chapterOrderList.length) {
			return false; // æ•°æ®ä¸å…¨ï¼Œæ— æ³•æ£€æµ‹ï¼Œé»˜è®¤ä¸å†²çª
		}
		
		// å¦‚æœéŸ³è‰²æ˜¯â€œæ—ç™½â€ï¼Œåˆ™ä¸ä¼šæœ‰å†²çª
		if (potentialTimbre === 'æ—ç™½') {
			return false;
		}

		const selectedCharChapters = []; // ç›®æ ‡è§’è‰²å‡ºç°è¿‡çš„ç« èŠ‚ç´¢å¼•
		state.chapterOrderList.forEach((chapterTitle, index) => {
			if (state.chapterCharacterMap[chapterTitle] && state.chapterCharacterMap[chapterTitle].includes(targetCharacter)) {
				selectedCharChapters.push(index);
			}
		});

		if (selectedCharChapters.length === 0) {
			return false; // ç›®æ ‡è§’è‰²åœ¨å°è¯´ä¸­æ— å¯¹è¯ï¼Œé»˜è®¤ä¸å†²çª
		}

		const conflictingChaptersIndexes = new Set();
		selectedCharChapters.forEach(idx => {
			conflictingChaptersIndexes.add(idx); // åŒä¸€ç« 
			if (idx > 0) conflictingChaptersIndexes.add(idx - 1); // å‰ä¸€ç« 
			if (idx < state.chapterOrderList.length - 1) conflictingChaptersIndexes.add(idx + 1); // åä¸€ç« 
		});

		const conflictingCharactersInAdjacentChapters = new Set();
		conflictingChaptersIndexes.forEach(idx => {
			const chapterTitle = state.chapterOrderList[idx];
			if (state.chapterCharacterMap[chapterTitle]) {
				state.chapterCharacterMap[chapterTitle].forEach(char => {
					// æ’é™¤ç›®æ ‡è§’è‰²è‡ªèº«å’Œæ—ç™½
					if (char !== targetCharacter && char !== 'æ—ç™½') {
						conflictingCharactersInAdjacentChapters.add(char);
					}
				});
			}
		});
		
		// æ£€æŸ¥è¿™äº›å†²çªè§’è‰²æ˜¯å¦å·²åˆ†é…äº† potentialTimbre
		for (const char of conflictingCharactersInAdjacentChapters) {
			const assignedTimbre = state.characterMapping[char];
			if (assignedTimbre === potentialTimbre) {
				return true; // å‘ç°å†²çªï¼
			}
		}
		
		return false; // æœªå‘ç°å†²çª
	}

    function updateTimbreConflictHighlight(selectedCharacter) {
        // æ¸…é™¤æ—§çš„å†²çªç¼“å­˜
        state.timbreConflictCache = {};
        dom.timbreListEl.querySelectorAll('li').forEach(li => {
            li.classList.remove('timbre-conflict', 'timbre-safe'); // ç§»é™¤æ‰€æœ‰è‡ªå®šä¹‰å†²çª/å®‰å…¨ç±»
            li.removeAttribute('title'); // æ¸…é™¤æç¤º
        });

        if (!selectedCharacter || !state.novelName || !state.chapterOrderList.length) {
            return; // æ²¡æœ‰é€‰ä¸­è§’è‰²æˆ–æ²¡æœ‰å°è¯´æ•°æ®ï¼Œä¸è¿›è¡Œæ£€æµ‹
        }
		
		dom.timbreListEl.querySelectorAll('li').forEach(li => {
			const timbreName = li.querySelector('.label')?.textContent;
			if (!timbreName) return;

			// è°ƒç”¨æ–°çš„è¾…åŠ©å‡½æ•°è¿›è¡Œå†²çªæ£€æµ‹
			const isConflicting = checkIfTimbreConflicts(selectedCharacter, timbreName);

			if (isConflicting) {
				li.classList.add('timbre-conflict');
				li.title = `åˆ†é…æ­¤éŸ³è‰²å°†å¯èƒ½å¯¼è‡´å†²çªï¼`;
				state.timbreConflictCache[timbreName] = true;
			} else {
				li.classList.add('timbre-safe');
				li.title = 'æ­¤éŸ³è‰²æ— å†²çªé£é™©';
				state.timbreConflictCache[timbreName] = false;
			}
		});

        const selectedCharChapters = []; // é€‰ä¸­è§’è‰²å‡ºç°è¿‡çš„ç« èŠ‚ç´¢å¼•
        state.chapterOrderList.forEach((chapterTitle, index) => {
            if (state.chapterCharacterMap[chapterTitle] && state.chapterCharacterMap[chapterTitle].includes(selectedCharacter)) {
                selectedCharChapters.push(index);
            }
        });

        if (selectedCharChapters.length === 0) {
            // å¦‚æœé€‰ä¸­è§’è‰²åœ¨ä»»ä½•ç« èŠ‚éƒ½æ²¡æœ‰å¯¹è¯ï¼Œé‚£ä¹ˆæ‰€æœ‰éŸ³è‰²éƒ½æ˜¯â€œå®‰å…¨çš„â€
            dom.timbreListEl.querySelectorAll('li').forEach(li => {
                li.classList.add('timbre-safe');
                li.title = 'å½“å‰é€‰å®šè§’è‰²åœ¨å°è¯´ä¸­æ— å¯¹è¯ï¼Œåˆ†é…ä»»ä½•éŸ³è‰²ç†è®ºä¸Šå‡å®‰å…¨ã€‚';
            });
            return;
        }

        // æ‰¾åˆ°ä¸å½“å‰é€‰ä¸­è§’è‰²ç« èŠ‚ç›¸é‚»çš„æ‰€æœ‰ç« èŠ‚çš„è§’è‰²
        const conflictingChaptersIndexes = new Set();
        selectedCharChapters.forEach(idx => {
            conflictingChaptersIndexes.add(idx); // åŒä¸€ç« 
            if (idx > 0) conflictingChaptersIndexes.add(idx - 1); // å‰ä¸€ç« 
            if (idx < state.chapterOrderList.length - 1) conflictingChaptersIndexes.add(idx + 1); // åä¸€ç« 
        });

        const conflictingCharactersInAdjacentChapters = new Set();
        conflictingChaptersIndexes.forEach(idx => {
            const chapterTitle = state.chapterOrderList[idx];
            if (state.chapterCharacterMap[chapterTitle]) {
                state.chapterCharacterMap[chapterTitle].forEach(char => {
                    // æ’é™¤å½“å‰é€‰ä¸­è§’è‰²è‡ªèº«
                    if (char !== selectedCharacter && char !== 'æ—ç™½') {
                        conflictingCharactersInAdjacentChapters.add(char);
                    }
                });
            }
        });
        
        // æ‰¾å‡ºè¿™äº›å†²çªè§’è‰²å·²ç»ä½¿ç”¨çš„éŸ³è‰²
        const conflictingTimbres = new Set();
        conflictingCharactersInAdjacentChapters.forEach(char => {
            const assignedTimbre = state.characterMapping[char];
            if (assignedTimbre) {
                conflictingTimbres.add(assignedTimbre);
            }
        });

        // æ›´æ–°éŸ³è‰²åº“çš„æ˜¾ç¤º
        dom.timbreListEl.querySelectorAll('li').forEach(li => {
            const timbreName = li.querySelector('.label')?.textContent;
            if (timbreName && conflictingTimbres.has(timbreName)) {
                li.classList.add('timbre-conflict');
                li.title = `åˆ†é…æ­¤éŸ³è‰²å°†å¯èƒ½å¯¼è‡´å†²çªï¼`;
                state.timbreConflictCache[timbreName] = true;
            } else {
                li.classList.add('timbre-safe');
                li.title = 'æ­¤éŸ³è‰²æ— å†²çªé£é™©';
                state.timbreConflictCache[timbreName] = false;
            }
        });
    }

    /**
     * å…¨å±€æ£€æµ‹æ‰€æœ‰å·²åˆ†é…éŸ³è‰²çš„å†²çªï¼Œå¹¶æ˜¾ç¤ºæŠ¥å‘Šã€‚
     */
    async function detectAllTimbreConflicts() {
        setStatus('æ­£åœ¨æ£€æµ‹éŸ³è‰²å†²çª...', 'info');
        dom.detectTimbreConflictsBtn.disabled = true;
        dom.detectTimbreConflictsBtn.textContent = 'æ£€æµ‹ä¸­...';

        const conflicts = [];
        const checkedTimbres = new Set(); // è®°å½•å·²æ£€æŸ¥è¿‡çš„éŸ³è‰²ï¼Œé¿å…é‡å¤æŠ¥å‘Š

        // 1. éå†æ‰€æœ‰éŸ³è‰²ï¼Œæ‰¾å‡ºè¢«å¤šä¸ªè§’è‰²ä½¿ç”¨çš„éŸ³è‰²
        const timbreToCharactersMap = {}; // {'timbreX': ['è§’è‰²A', 'è§’è‰²B'], ...}
        for (const char in state.characterMapping) {
            const timbre = state.characterMapping[char];
            if (timbre && char !== 'æ—ç™½') { // æ—ç™½ä¸å‚ä¸å†²çªæ£€æµ‹
                if (!timbreToCharactersMap[timbre]) {
                    timbreToCharactersMap[timbre] = [];
                }
                timbreToCharactersMap[timbre].push(char);
            }
        }

        // 2. å¯¹äºæ¯ä¸ªè¢«å¤šä¸ªè§’è‰²ä½¿ç”¨çš„éŸ³è‰²ï¼Œè¿›è¡Œå†²çªæ£€æµ‹
        for (const timbre in timbreToCharactersMap) {
            const charactersWithThisTimbre = timbreToCharactersMap[timbre];

            if (charactersWithThisTimbre.length < 2) {
                // åªå¯¹åˆ†é…ç»™å¤šä¸ªè§’è‰²çš„éŸ³è‰²è¿›è¡Œæ£€æµ‹
                continue;
            }

            // æ£€æŸ¥è¿™ä¸ªéŸ³è‰²æ˜¯å¦å·²ç»ä½œä¸ºå†²çªè¢«æŠ¥å‘Šè¿‡
            if (checkedTimbres.has(timbre)) {
                continue;
            }
            
            // æ„å»ºä¸€ä¸ªç« èŠ‚å‡ºç°çŸ©é˜µï¼Œæ–¹ä¾¿æ£€æŸ¥
            const charChapterIndexes = {}; // {'è§’è‰²A': [idx1, idx2], 'è§’è‰²B': [idx3], ...}
            charactersWithThisTimbre.forEach(char => {
                charChapterIndexes[char] = [];
                state.chapterOrderList.forEach((chapterTitle, idx) => {
                    if (state.chapterCharacterMap[chapterTitle] && state.chapterCharacterMap[chapterTitle].includes(char)) {
                        charChapterIndexes[char].push(idx);
                    }
                });
            });

            // æ£€æŸ¥ä»»æ„ä¸¤ä¸ªè§’è‰²ä¹‹é—´æ˜¯å¦å­˜åœ¨å†²çª
            for (let i = 0; i < charactersWithThisTimbre.length; i++) {
                const charA = charactersWithThisTimbre[i];
                const charA_chapters = charChapterIndexes[charA];

                if (charA_chapters.length === 0) continue; // è§’è‰²æ²¡æœ‰å¯¹è¯ï¼Œè·³è¿‡

                for (let j = i + 1; j < charactersWithThisTimbre.length; j++) {
                    const charB = charactersWithThisTimbre[j];
                    const charB_chapters = charChapterIndexes[charB];

                    if (charB_chapters.length === 0) continue; // è§’è‰²æ²¡æœ‰å¯¹è¯ï¼Œè·³è¿‡

                    // æ ¸å¿ƒå†²çªé€»è¾‘ï¼šAå’ŒBæ˜¯å¦æœ‰å¯¹è¯ç« èŠ‚ç›¸é‚»ï¼ˆæˆ–ç›¸åŒï¼‰
                    let hasConflict = false;
                    let conflictDetails = [];

                    for (const idxA of charA_chapters) {
                        for (const idxB of charB_chapters) {
                            // ç›¸é‚»æˆ–ç›¸åŒç« èŠ‚ï¼š|idxA - idxB| <= 1
                            if (Math.abs(idxA - idxB) <= 1) {
                                hasConflict = true;
                                conflictDetails.push({
                                    charA: charA,
                                    chapterA: state.chapterOrderList[idxA],
                                    charB: charB,
                                    chapterB: state.chapterOrderList[idxB]
                                });
                            }
                        }
                    }

                    if (hasConflict) {
                        conflicts.push({
                            timbre: timbre,
                            characters: [charA, charB], // æŠ¥å‘Šè¿™ä¸¤ä¸ªè§’è‰²ä¹‹é—´çš„å†²çª
                            details: conflictDetails
                        });
                        // æ ‡è®°éŸ³è‰²å·²æ£€æŸ¥ï¼Œä¸å†é‡å¤æŠ¥å‘Šæ­¤éŸ³è‰²
                        checkedTimbres.add(timbre);
                        break; // æ‰¾åˆ°ä¸€ä¸ªå†²çªï¼Œå°±å¯ä»¥è·³å‡ºå†…å±‚å¾ªç¯æ£€æŸ¥ä¸‹ä¸€ä¸ªéŸ³è‰²äº†
                    }
                }
            }
        }

        // æ¸²æŸ“æŠ¥å‘Šæ¨¡æ€æ¡†
		dom.timbreConflictModal.classList.add('active');
        let reportHtml = '';

        if (conflicts.length === 0) {
            reportHtml = '<p class="placeholder-text" style="color: var(--success-color);">ğŸ‰ æœªå‘ç°éŸ³è‰²å†²çªï¼æ‰€æœ‰éŸ³è‰²åˆ†é…å‡ç¬¦åˆç›¸é‚»ç« èŠ‚è§„åˆ™ã€‚</p>';
        } else {
            reportHtml += `<p style="color: var(--danger-color); font-weight: bold;">âš ï¸ å‘ç° ${conflicts.length} å¤„éŸ³è‰²å†²çªï¼š</p><ul>`;
            conflicts.forEach(conflict => {
                reportHtml += `<li style="margin-bottom: 1rem; border-bottom: 1px dashed var(--border-color); padding-bottom: 0.5rem;">
                                <strong>éŸ³è‰²ï¼š<span style="color: var(--primary-color);">${conflict.timbre}</span></strong> è¢« <span style="font-weight: bold;">${conflict.characters[0]}</span> å’Œ <span style="font-weight: bold;">${conflict.characters[1]}</span> åŒæ—¶ä½¿ç”¨ï¼Œå¹¶åœ¨ä»¥ä¸‹ç« èŠ‚å‘ç”Ÿå†²çªï¼š
                                <ul>`;
                conflict.details.forEach(detail => {
                    reportHtml += `<li>è§’è‰²â€œ${detail.charA}â€åœ¨<span style="font-style: italic;">â€œ${detail.chapterA}â€</span>æœ‰å¯¹è¯ï¼Œè§’è‰²â€œ${detail.charB}â€åœ¨<span style="font-style: italic;">â€œ${detail.chapterB}â€</span>æœ‰å¯¹è¯ã€‚</li>`;
                });
                reportHtml += `</ul></li>`;
            });
            reportHtml += '</ul>';
        }
        dom.timbreConflictModalBody.innerHTML = reportHtml;

        setStatus('éŸ³è‰²å†²çªæ£€æµ‹å®Œæˆã€‚', 'info');
        dom.detectTimbreConflictsBtn.disabled = false;
        dom.detectTimbreConflictsBtn.textContent = 'æ£€æµ‹éŸ³è‰²å†²çª';
    }
	
    dom.manageReplaceDictBtn.addEventListener('click', async () => {
        if (!state.novelName) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå°è¯´é¡¹ç›®ã€‚');
            return;
        }
        dom.replaceDictNovelName.textContent = state.novelName;
        dom.replaceDictModal.classList.add('active');
        await loadReplaceDict();
    });

    dom.closeReplaceDictBtn.addEventListener('click', () => {
        dom.replaceDictModal.classList.remove('active');
    });
    // ç‚¹å‡»èƒŒæ™¯å…³é—­
    dom.replaceDictModal.addEventListener('click', (e) => {
        if (e.target === dom.replaceDictModal) {
            dom.replaceDictModal.classList.remove('active');
        }
    });

    dom.addReplaceRuleBtn.addEventListener('click', async () => {
        const original = dom.newOriginalWord.value.trim();
        const replacement = dom.newReplacementWord.value.trim();
        const description = dom.newDescription.value.trim();

        if (!original || !replacement) {
            alert('åŸè¯å’Œæ›¿æ¢è¯ä¸èƒ½ä¸ºç©ºã€‚');
            return;
        }

        state.replaceDict.push({ original_word: original, replacement_word: replacement, description: description });
        await saveReplaceDict();
        dom.newOriginalWord.value = '';
        dom.newReplacementWord.value = '';
        dom.newDescription.value = '';
        renderReplaceRules();
    });

    dom.replaceRuleSearchInput.addEventListener('input', () => {
        renderReplaceRules(dom.replaceRuleSearchInput.value);
    });

    dom.replaceRulesList.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.matches('.btn-delete-rule')) {
            const li = target.closest('li');
            const originalWordToDelete = li.dataset.originalWord;
            const replacementWordToDelete = li.dataset.replacementWord;

            if (confirm(`æ‚¨ç¡®å®šè¦åˆ é™¤è§„åˆ™ã€Œ${originalWordToDelete} â†’ ${replacementWordToDelete}ã€å—ï¼Ÿ`)) {
                //  æŸ¥æ‰¾è¦åˆ é™¤è§„åˆ™çš„çœŸå®ç´¢å¼•
                const indexToDelete = state.replaceDict.findIndex(rule => 
                    rule.original_word === originalWordToDelete && 
                    rule.replacement_word === replacementWordToDelete
                );

                if (indexToDelete !== -1) {
                    state.replaceDict.splice(indexToDelete, 1); 
                    await saveReplaceDict();
                    renderReplaceRules(dom.replaceRuleSearchInput.value); // åˆ·æ–°æ—¶ä¿ç•™æœç´¢çŠ¶æ€
                    setStatus(`å·²åˆ é™¤è§„åˆ™: ${originalWordToDelete} â†’ ${replacementWordToDelete}`, 'success');
                } else {
                    setStatus('é”™è¯¯ï¼šæœªæ‰¾åˆ°è¦åˆ é™¤çš„è§„åˆ™ã€‚', 'error');
                }
            }
        }
    });
	
	dom.filterBtn.addEventListener('click', () => {
		dom.filterModal.classList.add('active'); // ä½¿ç”¨ active ç±»
		// Populate modal with current filter state
		document.querySelector(`input[name="filterStatus"][value="${state.filter.status}"]`).checked = true;
		dom.rangeStartInput.value = state.filter.start || '';
		dom.rangeEndInput.value = state.filter.end || '';
	});

	function closeFilterModal() {
		dom.filterModal.classList.remove('active'); // ç§»é™¤ active ç±»
	}

	dom.applyFilterBtn.addEventListener('click', () => {
		state.filter.status = document.querySelector('input[name="filterStatus"]:checked').value;
		state.filter.start = dom.rangeStartInput.value;
		state.filter.end = dom.rangeEndInput.value;
		renderChapterList(); // Re-render the list with new filters
		closeFilterModal();
	});

	dom.clearFilterBtn.addEventListener('click', () => {
		state.filter.status = 'all';
		state.filter.start = null;
		state.filter.end = null;
		renderChapterList(); // Re-render the full list
		closeFilterModal();
	});

	// Also add closing handlers for the modal overlay
	dom.filterModal.addEventListener('click', (e) => {
		if (e.target === dom.filterModal) {
			closeFilterModal();
		}
	});
	
	
    dom.detectTimbreConflictsBtn.addEventListener('click', async () => {
        if (!state.novelName) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå°è¯´é¡¹ç›®ã€‚');
            return;
        }
        await detectAllTimbreConflicts();
    });
	
	dom.autoAssignTimbreBtn.addEventListener('click', autoAssignTimbres);
	
	dom.transcribeBtn.addEventListener('click', async () => {
		if (!state.fileToUpload) {
			alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶ã€‚");
			return;
		}

		// --- UI åé¦ˆ ---
		const originalBtnText = dom.transcribeBtn.innerHTML;
		dom.transcribeBtn.innerHTML = 'è¯†åˆ«ä¸­...';
		dom.transcribeBtn.disabled = true;
		setStatus('æ­£åœ¨è‡ªåŠ¨è¯†åˆ«æ–‡æœ¬...', 'info');

		const formData = new FormData();
		formData.append('file', state.fileToUpload);

		try {
			const result = await fetchFromServer('/api/stt_elevenlabs', {
				method: 'POST',
				body: formData
			});

			if (result.status === 'success') {
				dom.newTimbreTextInput.value = result.text;
				setStatus('æ–‡æœ¬è¯†åˆ«æˆåŠŸï¼', 'success');
			} else {
				// å¦‚æœåç«¯è¿”å›äº†å·²çŸ¥çš„é”™è¯¯ä¿¡æ¯
				throw new Error(result.message || 'è¯†åˆ«å¤±è´¥ï¼ŒæœªçŸ¥é”™è¯¯');
			}

		} catch (error) {
			setStatus(`æ–‡æœ¬è¯†åˆ«å¤±è´¥: ${error.message}`, 'error');
			alert(`æ–‡æœ¬è¯†åˆ«å¤±è´¥: ${error.message}`);
		} finally {
			// --- æ¢å¤ UI ---
			dom.transcribeBtn.innerHTML = originalBtnText;
			dom.transcribeBtn.disabled = false;
		}
	});
	
    dom.previewUploadBtn.addEventListener('click', () => {
        if (state.fileToUpload) {
            // è°ƒç”¨æ–°çš„ã€ä¸“é—¨çš„å‡½æ•°
            toggleLocalBlobAudio(dom.previewUploadBtn, state.fileToUpload);
        }
    });
	
    async function loadReplaceDict() {
        if (!state.novelName) {
            dom.replaceRulesList.innerHTML = '<p class="placeholder-text">è¯·å…ˆé€‰æ‹©å°è¯´é¡¹ç›®</p>';
            return;
        }
        setStatus(`æ­£åœ¨åŠ è½½å°è¯´ã€Œ${state.novelName}ã€çš„æ›¿æ¢è¯å…¸...`, 'info');
        try {
            // Note: We use _t parameter to prevent caching for dynamic content
            const data = await fetchFromServer(`/api/novel/${encodeURIComponent(state.novelName)}/replace_dict?_t=${new Date().getTime()}`);
            state.replaceDict = data.rules || [];
            renderReplaceRules();
            setStatus(`å°è¯´ã€Œ${state.novelName}ã€æ›¿æ¢è¯å…¸åŠ è½½æˆåŠŸã€‚`, 'success');
        } catch (error) {
            setStatus(`åŠ è½½æ›¿æ¢è¯å…¸å¤±è´¥: ${error.message}`, 'error');
            state.replaceDict = [];
            renderReplaceRules();
        }
    }

    async function saveReplaceDict() {
        if (!state.novelName) {
            setStatus('è¯·å…ˆé€‰æ‹©å°è¯´é¡¹ç›®å†ä¿å­˜æ›¿æ¢è¯å…¸ã€‚', 'error');
            return;
        }
        setStatus(`æ­£åœ¨ä¿å­˜å°è¯´ã€Œ${state.novelName}ã€çš„æ›¿æ¢è¯å…¸...`, 'info');
        try {
            await fetchFromServer(`/api/novel/${encodeURIComponent(state.novelName)}/replace_dict`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rules: state.replaceDict })
            });
            setStatus(`å°è¯´ã€Œ${state.novelName}ã€æ›¿æ¢è¯å…¸ä¿å­˜æˆåŠŸã€‚`, 'success');
        } catch (error) {
            setStatus(`ä¿å­˜æ›¿æ¢è¯å…¸å¤±è´¥: ${error.message}`, 'error');
        }
    }

    function renderReplaceRules(filterTerm = '') {
        const listEl = dom.replaceRulesList;
        listEl.innerHTML = '';
        
        const lowerFilterTerm = filterTerm.toLowerCase().trim();
        const filteredRules = state.replaceDict.filter(rule => 
            rule.original_word.toLowerCase().includes(lowerFilterTerm) ||
            rule.replacement_word.toLowerCase().includes(lowerFilterTerm) ||
            (rule.description && rule.description.toLowerCase().includes(lowerFilterTerm))
        );

        if (filteredRules.length === 0) {
            listEl.innerHTML = '<p class="placeholder-text">æš‚æ— æ›¿æ¢è§„åˆ™æˆ–æ²¡æœ‰åŒ¹é…é¡¹ã€‚</p>';
            return;
        }

        filteredRules.forEach((rule, index) => { // è¿™é‡Œçš„ index åªæ˜¯ä¸ºäº†æ¸²æŸ“ï¼Œä¸å†å­˜å‚¨åˆ° dataset
            const li = document.createElement('li');
            // ä¸ºäº†è°ƒè¯•æ–¹ä¾¿ï¼Œå¯ä»¥æš‚æ—¶å­˜å‚¨è§„åˆ™çš„åŸå§‹è¯å’Œæ›¿æ¢è¯
            li.dataset.originalWord = rule.original_word;
            li.dataset.replacementWord = rule.replacement_word;
            li.innerHTML = `
                <div class="replace-rule-display" style="display: flex; align-items: center; justify-content: space-between; flex-grow: 1;">
                    <div>
                        <span class="original-word" style="font-weight: bold;">${rule.original_word}</span> 
                        <span style="color: var(--text-color-secondary); margin: 0 0.5rem;">â†’</span> 
                        <span class="replacement-word" style="color: var(--primary-color);">${rule.replacement_word}</span>
                        ${rule.description ? `<span class="description" style="margin-left: 1rem; font-size: 0.85em; color: var(--text-color-secondary);">(${rule.description})</span>` : ''}
                    </div>
                    <div class="rule-actions" style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-danger btn-delete-rule">åˆ é™¤</button>
                    </div>
                </div>
            `;
            listEl.appendChild(li);
        });
    }

	async function loadAndRenderEmoPrompts(shouldRenderUI = true)  {
        const listEl = dom.emoPromptsListEl;
		
		// åªæœ‰å½“éœ€è¦æ¸²æŸ“UIæ—¶æ‰è®¾ç½®placeholder
		if (shouldRenderUI) {
			listEl.innerHTML = '<p class="placeholder-text">æ­£åœ¨åŠ è½½...</p>';
		}
		
		try {
			const data = await fetchFromServer('/api/emo_prompts/list');
			state.allEmoPrompts = data.emo_prompts || [];

			if (shouldRenderUI) { // <-- æ ¹æ®å‚æ•°å†³å®šæ˜¯å¦æ¸²æŸ“UI
				if (state.allEmoPrompts.length === 0) {
					listEl.innerHTML = '<p class="placeholder-text">æš‚æ— æƒ…ç»ªå‚è€ƒéŸ³é¢‘ã€‚</p>';
					return;
				}
				listEl.innerHTML = state.allEmoPrompts.map(filename => `
					<li style="display: flex; align-items: center; justify-content: space-between;">
						<span class="label">${filename}</span>
						<div class="actions" style="display: flex; gap: 0.5rem;">
							<button class="audio-player-btn playable btn-play-emo" data-filename="${filename}" title="è¯•å¬">â–¶</button>
							<button class="btn btn-danger circular-btn btn-delete-emo" data-filename="${filename}" title="åˆ é™¤">X</button>
						</div>
					</li>
				`).join('');
			}
		} catch (error) {
			if (shouldRenderUI) { // <-- æ ¹æ®å‚æ•°å†³å®šæ˜¯å¦æ¸²æŸ“UI
				listEl.innerHTML = `<p class="placeholder-text" style="color: var(--danger-color);">åŠ è½½å¤±è´¥: ${error.message}</p>`;
			} else {
				console.error("DEBUG: ä»…æ›´æ–°stateæ—¶ï¼ŒåŠ è½½æƒ…ç»ªå‚è€ƒéŸ³é¢‘å¤±è´¥:", error);
			}
		}
    }

    dom.manageEmoPromptsBtn.addEventListener('click', () => {
        dom.emoPromptsManageModal.classList.add('active'); // ä½¿ç”¨ active ç±»
        loadAndRenderEmoPrompts();
    });

    dom.closeEmoPromptsManageBtn.addEventListener('click', () => {
        stopAllAudio();
        dom.emoPromptsManageModal.classList.remove('active'); // ç§»é™¤ active ç±»
    });
    
    dom.uploadEmoPromptLabelBtn.addEventListener('click', () => dom.emoPromptFileInput.click());

    dom.emoPromptFileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const formData = new FormData();
        formData.append('file', file);
        setStatus(`æ­£åœ¨ä¸Šä¼ æƒ…ç»ªå‚è€ƒéŸ³é¢‘: ${file.name}...`, 'info');
        try {
            await fetchFromServer('/api/emo_prompts/upload', { method: 'POST', body: formData });
            setStatus('ä¸Šä¼ æˆåŠŸï¼', 'success');
            await loadAndRenderEmoPrompts();
            if (dom.contentTable.style.display === 'table') {
                console.log("æƒ…ç»ªå‚è€ƒéŸ³é¢‘å·²æ›´æ–°ï¼Œæ­£åœ¨åˆ·æ–°å†…å®¹ç¼–è¾‘å™¨...");
                renderContentTable();
                // æ³¨æ„ï¼šé‡æ–°æ¸²æŸ“åï¼Œæ–‡ä»¶å­˜åœ¨çŠ¶æ€éœ€è¦é‡æ–°æ£€æŸ¥
                await checkAllPlayableFiles(); 
            }
        } catch (error) {
            setStatus(`ä¸Šä¼ å¤±è´¥: ${error.message}`, 'error');
            alert(`ä¸Šä¼ å¤±è´¥: ${error.message}`);
        } finally {
            e.target.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©ï¼Œä»¥ä¾¿å†æ¬¡é€‰æ‹©åŒåæ–‡ä»¶
        }
    });

    dom.emoPromptsListEl.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.matches('.btn-play-emo')) {
            const filename = target.dataset.filename;
            toggleSimpleAudio(target, `/emo_prompts/${filename}`);
        }
        if (target.matches('.btn-delete-emo')) {
            const filename = target.dataset.filename;
            if (confirm(`æ‚¨ç¡®å®šè¦æ°¸ä¹…åˆ é™¤æƒ…ç»ªå‚è€ƒéŸ³é¢‘ã€Œ${filename}ã€å—ï¼Ÿ`)) {
                try {
                    await fetchFromServer(`/api/emo_prompts/delete?filename=${encodeURIComponent(filename)}`, { method: 'DELETE' });
                    setStatus('åˆ é™¤æˆåŠŸï¼', 'success');
                    await loadAndRenderEmoPrompts();
                    if (dom.contentTable.style.display === 'table') {
                        console.log("æƒ…ç»ªå‚è€ƒéŸ³é¢‘å·²æ›´æ–°ï¼Œæ­£åœ¨åˆ·æ–°å†…å®¹ç¼–è¾‘å™¨...");
                        renderContentTable();
                        await checkAllPlayableFiles();
                    }
                } catch (error) {
                    setStatus(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
                    alert(`åˆ é™¤å¤±è´¥: ${error.message}`);
                }
            }
        }
    });
	
    // éŸ³è‰²å†²çªæŠ¥å‘Šæ¨¡æ€æ¡†å…³é—­äº‹ä»¶
    dom.closeTimbreConflictBtn.addEventListener('click', () => {
        dom.timbreConflictModal.classList.remove('active');
    });
    dom.timbreConflictModal.addEventListener('click', (e) => {
        if (e.target === dom.timbreConflictModal) {
            dom.timbreConflictModal.classList.remove('active'); 
        }
    });
		
	async function autoAssignTimbres() {
		if (!state.novelName) {
			setStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå°è¯´é¡¹ç›®ã€‚', 'warning');
			return;
		}
		if (!state.allAvailableCharacters || state.allAvailableCharacters.length === 0) {
			setStatus('æœªåŠ è½½ä»»ä½•è§’è‰²ï¼Œæ— æ³•è‡ªåŠ¨åˆ†é…ã€‚', 'warning');
			return;
		}
		if (!state.allTimbres || state.allTimbres.length === 0) {
			setStatus('éŸ³è‰²åº“ä¸ºç©ºï¼Œæ— æ³•è‡ªåŠ¨åˆ†é…ã€‚', 'warning');
			return;
		}

		setStatus('æ­£åœ¨è‡ªåŠ¨åˆ†é…éŸ³è‰²...', 'info');
		dom.autoAssignTimbreBtn.disabled = true;
		dom.autoAssignTimbreBtn.textContent = 'åˆ†é…ä¸­...';

		try {
			// é‡æ–°åŠ è½½æœ€æ–°çš„è§’è‰²ç®€ä»‹ï¼Œä»¥é˜²åœ¨å…¶ä»–åœ°æ–¹æœ‰æ›´æ–°
			const profilesPath = `/projects/${state.novelName}/character_profiles.json`;
			let character_profiles = {};
			try {
				const profilesResponse = await fetch(profilesPath);
				if (profilesResponse.ok) {
					character_profiles = await profilesResponse.json();
				}
			} catch (e) {
				console.warn('åŠ è½½è§’è‰²ç®€ä»‹å¤±è´¥ï¼Œä½¿ç”¨ç©ºç®€ä»‹ã€‚', e);
			}

			let assignedCount = 0;
			const updatedCharacterMapping = { ...state.characterMapping }; // åˆ›å»ºä¸€ä¸ªå‰¯æœ¬è¿›è¡Œä¿®æ”¹
			
            // è·å–å½“å‰è§’è‰²åˆ—è¡¨é¢æ¿ä¸­æ˜¾ç¤ºçš„æ‰€æœ‰è§’è‰²å
            const displayedCharacterElements = dom.characterListEl.querySelectorAll('.character-row');
            if (displayedCharacterElements.length === 0) {
                setStatus('å½“å‰æ²¡æœ‰æ˜¾ç¤ºä»»ä½•è§’è‰²ï¼Œè¯·å…ˆé€‰æ‹©ç« èŠ‚ã€‚', 'warning');
                dom.autoAssignTimbreBtn.disabled = false;
                dom.autoAssignTimbreBtn.textContent = 'è‡ªåŠ¨åˆ†é…éŸ³è‰²';
                return;
            }

            const charactersToProcess = Array.from(displayedCharacterElements)
                .map(el => el.dataset.characterName)
                .filter(charName => charName !== 'æ—' && !updatedCharacterMapping[charName]); // æ’é™¤æ—ç™½å’Œå·²åˆ†é…çš„

            if (charactersToProcess.length === 0) {
                setStatus('å½“å‰é€‰ä¸­ç« èŠ‚ä¸­æ²¡æœ‰æœªåˆ†é…éŸ³è‰²çš„è§’è‰²éœ€è¦å¤„ç†ã€‚', 'info');
                dom.autoAssignTimbreBtn.disabled = false;
                dom.autoAssignTimbreBtn.textContent = 'è‡ªåŠ¨åˆ†é…éŸ³è‰²';
                return;
            }
            
            setStatus(`æ­£åœ¨ä¸ºé€‰ä¸­ç« èŠ‚ä¸­çš„ ${charactersToProcess.length} ä¸ªæœªåˆ†é…è§’è‰²è‡ªåŠ¨åˆ†é…éŸ³è‰²...`, 'info');

            for (const charName of charactersToProcess) { 
				if (charName === 'æ—ç™½' || updatedCharacterMapping[charName]) {
					continue; // è·³è¿‡æ—ç™½å’Œå·²åˆ†é…éŸ³è‰²çš„è§’è‰²
				}
                console.log(`DEBUG: æ­£åœ¨ä¸ºè§’è‰² '${charName}' å°è¯•è‡ªåŠ¨åˆ†é…ã€‚`);
                const profile = character_profiles[charName] || {};
                const gender = profile.gender || 'æœªçŸ¥';
                const ageGroup = profile.ageGroup || 'æœªçŸ¥';

                // æ„å»ºæ€§åˆ«å…³é”®è¯
                let genderKeywords = [];
                if (gender === 'ç”·') genderKeywords = ['ç”·'];
                else if (gender === 'å¥³') genderKeywords = ['å¥³'];

				// æ„å»ºå¹´é¾„æ®µå…³é”®è¯
				let ageGroupKeywords = [];
				if (ageGroup === 'å­©ç«¥') ageGroupKeywords = ['å­©ç«¥', 'å„¿ç«¥', 'å°å­©', 'å¥³å­©', 'ç”·å­©'];
				else if (ageGroup === 'å°‘å¹´') ageGroupKeywords = ['å°‘å¹´', 'å°‘ç”·', 'å°‘å¥³'];
				else if (ageGroup === 'é’å¹´') ageGroupKeywords = ['é’å¹´', 'å¹´è½»'];
				else if (ageGroup === 'ä¸­å¹´') ageGroupKeywords = ['ä¸­å¹´', 'æˆç†Ÿ'];
				else if (ageGroup === 'è€å¹´') ageGroupKeywords = ['è€å¹´', 'è€å¤´', 'è€è€…', 'å¹´é•¿'];

                let primaryEligibleTimbres = []; // å¾—åˆ†2ä¸”ä¸å†²çªï¼Œä¸”æœªè¢«å…¶ä»–è§’è‰²åˆ†é…çš„éŸ³è‰²
                // let fallbackEligibleTimbres = []; // åˆ é™¤è¿™ä¸€è¡Œï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªæ›´å¤æ‚çš„å¯¹è±¡æ•°ç»„
                let scoredFallbackTimbres = []; // æ–°å¢ï¼šå­˜å‚¨å¤‡é€‰éŸ³è‰²åŠå…¶è·ç¦»å¾—åˆ†

                for (const timbreName of state.allTimbres) {
                    let score = 0;
                    const lowerTimbreName = timbreName.toLowerCase();
                    const timbreCategory = (getTimbreCategory(timbreName) || '').toLowerCase();

                    // æ£€æŸ¥æ€§åˆ«åŒ¹é…
                    const genderMatched = genderKeywords.some(kw => lowerTimbreName.includes(kw) || timbreCategory.includes(kw));
                    if (genderMatched) score += 1;

                    // æ£€æŸ¥å¹´é¾„æ®µåŒ¹é…
                    const ageGroupMatched = ageGroupKeywords.some(kw => lowerTimbreName.includes(kw) || timbreCategory.includes(kw));
                    if (ageGroupMatched) score += 1;

                    // --- å¾—åˆ†å¿…é¡»ä¸º 2 æ‰èƒ½è‡ªåŠ¨åˆ†é… ---
                    if (score < 2) {
                        // console.log(`DEBUG: éŸ³è‰² '${timbreName}' å¾—åˆ†ä¸è¶³ 2 (å®é™…å¾—åˆ† ${score})ï¼Œè·³è¿‡ã€‚`);
                        continue; // ä¸æ»¡è¶³å¾—åˆ†æ¡ä»¶ï¼Œè·³è¿‡
                    }

                    // --- å†²çªæ£€æµ‹ ---
                    const conflicts = checkIfTimbreConflicts(charName, timbreName);
                    if (conflicts) {
                        // console.log(`DEBUG: éŸ³è‰² '${timbreName}' ä¸è§’è‰² ${charName} å­˜åœ¨å†²çªï¼Œè·³è¿‡ã€‚`);
                        continue; // éŸ³è‰²å†²çªï¼Œè·³è¿‡
                    }

                    // æ£€æŸ¥éŸ³è‰²æ˜¯å¦å·²è¢«å…¶ä»–è§’è‰²åˆ†é… (ç”¨äºåŒºåˆ† primary å’Œ fallback å€™é€‰)
                    let assignedOtherCharNames = [];
                    for (const [assignedChar, assignedTimbre] of Object.entries(updatedCharacterMapping)) {
                        if (assignedChar !== charName && assignedTimbre === timbreName) {
                            assignedOtherCharNames.push(assignedChar);
                        }
                    }

                    if (assignedOtherCharNames.length > 0) {
                        // --- æ–°å¢ï¼šè®¡ç®—è·ç¦»å¾—åˆ† ---
                        let totalDistance = 0;
                        const targetCharChapterIndexes = [];
                        state.chapterOrderList.forEach((chapterTitle, index) => {
                            if (state.chapterCharacterMap[chapterTitle] && state.chapterCharacterMap[chapterTitle].includes(charName)) {
                                targetCharChapterIndexes.push(index);
                            }
                        });

                        for (const otherChar of assignedOtherCharNames) {
                            const otherCharChapterIndexes = [];
                            state.chapterOrderList.forEach((chapterTitle, index) => {
                                if (state.chapterCharacterMap[chapterTitle] && state.chapterCharacterMap[chapterTitle].includes(otherChar)) {
                                    otherCharChapterIndexes.push(index);
                                }
                            });

                            // è®¡ç®—ä¸¤ä¸ªè§’è‰²ç« èŠ‚å‡ºç°ä½ç½®çš„æœ€å°è·ç¦»
                            let minDistanceBetweenChars = Infinity;
                            if (targetCharChapterIndexes.length > 0 && otherCharChapterIndexes.length > 0) {
                                for (const idx1 of targetCharChapterIndexes) {
                                    for (const idx2 of otherCharChapterIndexes) {
                                        minDistanceBetweenChars = Math.min(minDistanceBetweenChars, Math.abs(idx1 - idx2));
                                    }
                                }
                            } else {
                                // å¦‚æœå…¶ä¸­ä¸€ä¸ªè§’è‰²æ²¡æœ‰å¯¹è¯ï¼Œè®¤ä¸ºè·ç¦»æ— ç©·è¿œï¼Œä¸å½±å“
                                minDistanceBetweenChars = state.chapterOrderList.length; // è§†ä¸ºæœ€å¤§å¯èƒ½è·ç¦»
                            }
                            totalDistance += minDistanceBetweenChars;
                        }
                        scoredFallbackTimbres.push({ timbreName: timbreName, distance: totalDistance });
                        // console.log(`DEBUG: éŸ³è‰² '${timbreName}' åŠ å…¥å¤‡é€‰ (å·²è¢«åˆ†é…ä½†æ— å†²çª)ï¼Œè·ç¦»å¾—åˆ†: ${totalDistance}ã€‚`);

                    } else {
                        primaryEligibleTimbres.push(timbreName);
                        // console.log(`DEBUG: éŸ³è‰² '${timbreName}' åŠ å…¥ä¸»è¦å€™é€‰ (æœªè¢«åˆ†é…ä¸”æ— å†²çª)ã€‚`);
                    }
                }

                let selectedTimbre = null;

                // ä¼˜å…ˆä»ä¸»è¦å€™é€‰éŸ³è‰²ä¸­é€‰æ‹©
                if (primaryEligibleTimbres.length > 0) {
                    selectedTimbre = primaryEligibleTimbres[Math.floor(Math.random() * primaryEligibleTimbres.length)];
                    console.log(`DEBUG: ä¸ºè§’è‰² '${charName}' é€‰æ‹©äº†ä¸»è¦å€™é€‰éŸ³è‰²: '${selectedTimbre}'`);
                } 
                // å¦‚æœä¸»è¦å€™é€‰ä¸ºç©ºï¼Œåˆ™ä»å¤‡é€‰éŸ³è‰²ä¸­é€‰æ‹©ï¼ŒæŒ‰è·ç¦»å¾—åˆ†ä»é«˜åˆ°ä½æ’åº
                else if (scoredFallbackTimbres.length > 0) {
                    // æŒ‰è·ç¦»å¾—åˆ†é™åºæ’åºï¼Œç¡®ä¿é€‰æ‹©è·ç¦»æœ€å¤§çš„éŸ³è‰²
                    scoredFallbackTimbres.sort((a, b) => b.distance - a.distance);
                    selectedTimbre = scoredFallbackTimbres[0].timbreName; // é€‰æ‹©è·ç¦»å¾—åˆ†æœ€é«˜çš„
                    console.log(`DEBUG: ä¸ºè§’è‰² '${charName}' é€‰æ‹©äº†å¤‡é€‰éŸ³è‰²: '${selectedTimbre}' (è·ç¦»å¾—åˆ†: ${scoredFallbackTimbres[0].distance})`);
                }

                // å¦‚æœæ‰¾åˆ°éŸ³è‰²ï¼Œåˆ™è¿›è¡Œåˆ†é…
                if (selectedTimbre) {
                    updatedCharacterMapping[charName] = selectedTimbre;
                    assignedCount++;
                    setStatus(`å·²è‡ªåŠ¨åˆ†é… '${selectedTimbre}' ç»™ '${charName}'`, 'info');
                } else {
                    console.log(`DEBUG: è§’è‰² '${charName}' æœªæ‰¾åˆ°å¾—åˆ†2ä¸”ä¸å†²çªçš„åˆé€‚éŸ³è‰² (åŒ…æ‹¬å¤‡é€‰)ã€‚`);
                }
            }
			
			state.characterMapping = updatedCharacterMapping; // æ›´æ–°çŠ¶æ€
			await saveConfig(); // è§¦å‘è‡ªåŠ¨ä¿å­˜
			await loadCharacters(); // åˆ·æ–°è§’è‰²åˆ—è¡¨ UI
			// å¦‚æœå†…å®¹ç¼–è¾‘å™¨æ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿéœ€è¦åˆ·æ–°ï¼Œä»¥æ›´æ–°è§’è‰²ä¸‹æ‹‰æ¡†çš„æœ€æ–°åˆ†é…
			if (state.selectedChapterPaths.length === 1 && dom.contentTable.style.display === 'table') {
				renderContentTable();
				await checkAllPlayableFiles();
			}

			setStatus(`è‡ªåŠ¨éŸ³è‰²åˆ†é…å®Œæˆã€‚æˆåŠŸä¸º ${assignedCount} ä¸ªè§’è‰²åˆ†é…äº†éŸ³è‰²ã€‚`, 'success');

		} catch (error) {
			setStatus(`è‡ªåŠ¨éŸ³è‰²åˆ†é…å¤±è´¥: ${error.message}`, 'error');
			console.error('è‡ªåŠ¨éŸ³è‰²åˆ†é…å¤±è´¥:', error);
		} finally {
			dom.autoAssignTimbreBtn.disabled = false;
			dom.autoAssignTimbreBtn.textContent = 'è‡ªåŠ¨åˆ†é…éŸ³è‰²';
		}
	}

    // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
    document.addEventListener('mousedown', (e) => {
        // æ£€æŸ¥æ˜¯å¦åœ¨ modal-header ä¸ŠæŒ‰ä¸‹ï¼Œä¸”è¯¥æ¨¡æ€æ¡†æ˜¯æ´»åŠ¨çš„
        const modalHeader = e.target.closest('.modal-header');
        if (modalHeader) {
            const modalContent = modalHeader.closest('.modal-content');
            if (modalContent && modalContent.parentElement.classList.contains('active')) { 
                e.preventDefault(); 
                state.isDraggingModal = true;
                state.activeDraggableModal = modalContent;

                const rect = modalContent.getBoundingClientRect();

                state.dragOffsetX = e.clientX - rect.left;
                state.dragOffsetY = e.clientY - rect.top;

                // *** æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨ body å’Œ modalContent ä¸Šè®¾ç½® grabbing å…‰æ ‡ ***
                document.body.style.cursor = 'grabbing'; 
                modalContent.style.cursor = 'grabbing'; 
            }
        }
    });

    // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ (ä¿æŒä¸å˜)
    document.addEventListener('mousemove', (e) => {
        if (!state.isDraggingModal || !state.activeDraggableModal) return;

        e.preventDefault(); 

        const modalContent = state.activeDraggableModal;

        let newX = e.clientX - state.dragOffsetX;
        let newY = e.clientY - state.dragOffsetY;

        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const modalWidth = modalContent.offsetWidth;
        const modalHeight = modalContent.offsetHeight;

        newX = Math.max(0, Math.min(newX, viewportWidth - modalWidth));
        newY = Math.max(0, Math.min(newY, viewportHeight - modalHeight));

        modalContent.style.left = `${newX}px`;
        modalContent.style.top = `${newY}px`;
        modalContent.style.transform = 'none'; 
    });

    // é¼ æ ‡æŠ¬èµ·äº‹ä»¶
    document.addEventListener('mouseup', () => {
        if (state.isDraggingModal && state.activeDraggableModal) {
            // *** æ ¸å¿ƒä¿®æ”¹ï¼šå°†å…‰æ ‡æ¢å¤ä¸º 'auto'ï¼Œè€Œä¸æ˜¯ 'grab' ***
            document.body.style.cursor = 'auto'; // æ¢å¤ body å…‰æ ‡
            state.activeDraggableModal.style.cursor = 'auto'; // æ¢å¤æ¨¡æ€æ¡†å…‰æ ‡
            
            state.isDraggingModal = false;
            state.activeDraggableModal = null; // æ¸…ç©ºæ´»åŠ¨æ¨¡æ€æ¡†
        }
    });

    // --- é¡µé¢å¤§å°è°ƒæ•´æ—¶ï¼Œå¦‚æœæ¨¡æ€æ¡†è¢«æ‹–æ‹½è¿‡ï¼Œé‡æ–°å±…ä¸­å®ƒï¼ˆå¯é€‰ï¼Œä½†æ¨èï¼‰ ---
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            // éå†æ‰€æœ‰ active çš„ modal-overlay
            document.querySelectorAll('.modal-overlay.active .modal-content').forEach(modalContent => {
                // å¦‚æœæ¨¡æ€æ¡†çš„ transform æ˜¯ 'none'ï¼Œè¯´æ˜å®ƒå¯èƒ½è¢«æ‹–æ‹½è¿‡
                // æ­¤æ—¶æˆ‘ä»¬é‡æ–°åº”ç”¨ transform å±…ä¸­ï¼Œå› ä¸ºå®ƒåœ¨æ‹–æ‹½åè¢«ç§»é™¤äº†
                if (modalContent.style.transform === 'none') {
                    modalContent.style.left = '50%';
                    modalContent.style.top = '50%';
                    modalContent.style.transform = 'translate(-50%, -50%)';
                }
            });
        }, 200); // 200ms åæ‰§è¡Œ
    });

    // --- åœ¨æ¨¡æ€æ¡†å…³é—­æ—¶ï¼Œç¡®ä¿é‡ç½®å…¶ä½ç½® (å¯é€‰ï¼Œä½†æ¨èï¼Œä½¿å…¶ä¸‹æ¬¡æ‰“å¼€ä»å±…ä¸­) ---
    // ä¸ºæ¯ä¸ªæ¨¡æ€æ¡†æ·»åŠ å…³é—­äº‹ä»¶ç›‘å¬ï¼Œæˆ–è€…åœ¨é€šç”¨çš„ hideModal å‡½æ•°ä¸­å¤„ç†
    // ä»¥ sourceTextModal ä¸ºä¾‹
    dom.sourceTextModalCloseBtn.addEventListener('click', () => {
        dom.sourceTextModal.classList.remove('active');
        // é‡ç½®æ¨¡æ€æ¡†ä½ç½®
        const modalContent = dom.sourceTextModal.querySelector('.modal-content');
        if (modalContent) {
            modalContent.style.left = '50%';
            modalContent.style.top = '50%';
            modalContent.style.transform = 'translate(-50%, -50%)';
            modalContent.style.cursor = 'auto'; // æ¢å¤é»˜è®¤å…‰æ ‡
        }
    });
    dom.sourceTextModal.addEventListener('click', (e) => {
        if (e.target === dom.sourceTextModal) {
            dom.sourceTextModal.classList.remove('active');
            // é‡ç½®æ¨¡æ€æ¡†ä½ç½®
            const modalContent = dom.sourceTextModal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.left = '50%';
                modalContent.style.top = '50%';
                modalContent.style.transform = 'translate(-50%, -50%)';
                modalContent.style.cursor = 'auto';
            }
        }
    });
	
// =============================================================
// ã€æ–°å¢ã€‘æ—¥å¿—å¤„ç†å‡½æ•° (è¯·ç¡®ä¿å®ƒä»¬åœ¨ domContentLoaded å—å†…)
// =============================================================

function updateLogDisplay(logs) {
    const logContainer = dom.backendLogDisplay;
    if (!logContainer) {
        console.error("DOM Error: #backend-log-display å…ƒç´ æœªæ‰¾åˆ°ã€‚");
        return;
    }

    if (logs && logs.length > 0) {
        // æ¸²æŸ“æ—¥å¿—
        logContainer.innerHTML = logs.map(log => `<p>${log}</p>`).join('');
        // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
        //logContainer.scrollTop = logContainer.scrollHeight; 
    } else {
        // å¦‚æœæ—¥å¿—æ˜¯ç©ºçš„ï¼Œæ˜¾ç¤ºâ€œæ— æ—¥å¿—â€æç¤ºï¼Œè¦†ç›–åˆå§‹çš„â€œåŠ è½½ä¸­â€
        logContainer.innerHTML = `<p style="color: var(--text-color-secondary); font-size: 0.8rem;">[${new Date().toLocaleTimeString()}] åç«¯å·²å¯åŠ¨ï¼Œå½“å‰æ— ä»»åŠ¡æ—¥å¿—ã€‚</p>`;
    }
}

    function fetchLatestLogs() {
        const logApiUrl = '/api/latest_logs'; 

        fetch(logApiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json(); 
            })
            .then(data => {
               if (data && Array.isArray(data.logs)) {
                    updateLogDisplay(data.logs); 
                } else {
                     dom.backendLogDisplay.innerHTML = `<p style="color: var(--error-color);">[${new Date().toLocaleTimeString()}] é”™è¯¯: API å“åº”æ ¼å¼ä¸æ­£ç¡®ã€‚</p>`;
                }
            })
            .catch(error => {
                dom.backendLogDisplay.innerHTML = `<p style="color: var(--error-color);">[${new Date().toLocaleTimeString()}] æ— æ³•è¿æ¥åˆ°åç«¯ (${error.message || 'æœªçŸ¥é”™è¯¯'})ã€‚</p>`;
            });
    }

    function startLogPolling() {
        fetchLatestLogs(); 
        // æ¯ 2 ç§’åˆ·æ–°ä¸€æ¬¡æ—¥å¿—
        setInterval(fetchLatestLogs, 500); 
    }
    
    // === 6. INITIALIZATION ===    
	async function initialize() {
        setStatus('æ­£åœ¨åˆå§‹åŒ–åº”ç”¨...');
        try {
            state.globalConfig = await fetchFromServer(`/api/get_llm_config?_t=${new Date().getTime()}`);
            
            startLogPolling();

            // --- é…ç½®åŠ è½½æˆåŠŸåçš„é€»è¾‘ ---
            const mainModelSelect = dom.llmModelSelector;
            mainModelSelect.innerHTML = '';
            if (state.globalConfig.models) {
                // ç¡®ä¿æŒ‰æ˜¾ç¤ºåç§°æ’åºï¼Œæˆ–è€…æŒ‰ç…§ç‰¹å®šé¡ºåº
                const sortedModels = Object.keys(state.globalConfig.models).sort((a, b) => {
                    const nameA = state.globalConfig.models[a]?.display_name || a;
                    const nameB = state.globalConfig.models[b]?.display_name || b;
                    return nameA.localeCompare(nameB);
                });

                sortedModels.forEach(modelId => {
                    const model = state.globalConfig.models[modelId];
                    if (model) { // ç¡®ä¿æ¨¡å‹å­˜åœ¨
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = model.display_name || modelId;
                        mainModelSelect.appendChild(option);
                    }
                });
            }

            state.selectedLLM = state.globalConfig.general?.default_model || 'gemini-2.5-flash';
            mainModelSelect.value = state.selectedLLM;
			
			
			const elevenlabsConfig = state.globalConfig.elevenlabs; // elevenlabsé…ç½®
			const hasElevenlabsKey = elevenlabsConfig && elevenlabsConfig.api_key && elevenlabsConfig.api_key.trim() !== '';
            
            if (hasElevenlabsKey) {
                dom.transcribeBtn.style.display = 'inline-flex'; // å¦‚æœæœ‰ Keyï¼Œåˆ™æ˜¾ç¤ºæŒ‰é’®
                dom.transcribeBtn.title = ''; // æ¸…é™¤æç¤ºï¼Œç¦ç”¨çŠ¶æ€ç”±æ–‡ä»¶é€‰æ‹©å†³å®š
            } else {
                dom.transcribeBtn.style.display = 'none'; // æ²¡æœ‰ Keyï¼Œåˆ™éšè—æŒ‰é’®
                setStatus('ElevenLabs API Key æœªé…ç½®ï¼Œè‡ªåŠ¨è¯†åˆ«æ–‡æœ¬åŠŸèƒ½å·²éšè—ã€‚', 'warning');
            }
            
        } catch (error) {
            setStatus('åŠ è½½å…¨å±€é…ç½®å¤±è´¥ï¼Œå°†ä½¿ç”¨é»˜è®¤è®¾ç½®ã€‚', 'warning');
            // --- æä¾›ä¸€ä¸ªé»˜è®¤çš„ globalConfig ç»“æ„ï¼Œç¡®ä¿åç»­ä»£ç ä¸ä¼šå›  undefined å‡ºé”™ ---
            state.globalConfig = {
                general: { default_model: 'gemini-2.5-flash' },
                models: {
                    'gemini-2.5-flash': { display_name: 'Gemini Flash' },
                    'qwen-plus-latest': { display_name: 'é€šä¹‰åƒé—® Plus' }
                },
                audio_export: { format: 'mp3', quality: '192k' }
            };
            // åŒæ ·éœ€è¦å¡«å……ä¸»ç•Œé¢çš„ä¸‹æ‹‰æ¡†
            const mainModelSelect = dom.llmModelSelector;
            mainModelSelect.innerHTML = '';
             for (const modelId in state.globalConfig.models) {
                const model = state.globalConfig.models[modelId];
                const option = document.createElement('option');
                option.value = modelId;
                option.textContent = model.display_name || modelId;
                mainModelSelect.appendChild(option);
            }
            mainModelSelect.value = state.globalConfig.general.default_model;
			
            dom.transcribeBtn.style.display = 'none';
        }

        try {
            const data = await fetchFromServer('/api/emo_prompts/list');
            state.allEmoPrompts = data.emo_prompts || [];
        } catch(e) { console.error("åˆå§‹åŒ–åŠ è½½æƒ…ç»ªå‚è€ƒéŸ³é¢‘å¤±è´¥:", e); }
		
		await loadNovels();
		await loadTimbres(); // 1. å…ˆåŠ è½½æ‰€æœ‰æ•°æ®å¹¶å¡«å……UIæ§ä»¶
        await loadAllCharactersForDropdown();
        // --- åˆå§‹åŒ–æ—¶åŠ è½½ç« èŠ‚è§’è‰²åˆ†å¸ƒæ•°æ® ---
        if (state.novelName) { // ç¡®ä¿åœ¨å°è¯´åå­˜åœ¨æ—¶æ‰å°è¯•åŠ è½½
            try {
                const chapterPresenceData = await fetchFromServer(`/api/get_chapter_presence_data?novel_name=${encodeURIComponent(state.novelName)}`);
                state.chapterCharacterMap = chapterPresenceData.data.chapter_character_map || {};
                state.chapterOrderList = chapterPresenceData.data.chapter_order_list || [];
            } catch (error) {
                console.error("åˆå§‹åŒ–åŠ è½½ç« èŠ‚åˆ†å¸ƒæ•°æ®å¤±è´¥:", error);
                state.chapterCharacterMap = {};
                state.chapterOrderList = [];
            }
        }		
		
		renderTimbreList();
		updateRelatedRolesPopovers();
        setStatus('åˆå§‹åŒ–å®Œæˆã€‚', 'info');
    }
    
    initialize();
	
    let isResizing = false;
    let currentColIndex = -1;
    let initialX = 0;
    let initialWidths = [];
    const mainContainer = document.querySelector('.main-container.spa-layout');
    
    // å°† Grid æ¨¡æ¿å­—ç¬¦ä¸²è½¬æ¢ä¸ºæµ®ç‚¹æ•°æ•°ç»„
    function getFrArray() {
        const style = window.getComputedStyle(mainContainer);
        const gridTemplateColumns = style.getPropertyValue('grid-template-columns');
        // gridTemplateColumns å¯èƒ½æ˜¯ "181.5px 181.5px 181.5px 479.25px"
        // æˆ‘ä»¬éœ€è¦è®¡ç®—å‡º fr çš„ç›¸å¯¹æ¯”ä¾‹ï¼Œç”¨åƒç´ å€¼é™¤ä»¥ fr æ€»å’Œ
        
        // ç®€åŒ–ï¼šå¦‚æœ Grid å±æ€§è¢« JS è¦†ç›–ï¼Œç›´æ¥ä½¿ç”¨ JS å­˜å‚¨çš„ fr å€¼
        // å¦åˆ™ï¼Œä» DOM è·å–å¹¶è®¡ç®—
        const currentFrString = mainContainer.style.gridTemplateColumns || '1fr 1fr 1fr 2.5fr'; // ä½¿ç”¨åˆå§‹é»˜è®¤å€¼ä½œä¸ºå›é€€
        return currentFrString.split(' ').map(s => parseFloat(s.replace('fr', '')));
    }

    // é‡æ–°è®¡ç®— Grid æ¨¡æ¿å­—ç¬¦ä¸²
    function updateGridTemplateColumns(widths) {
        const newTemplate = widths.map(w => w + 'fr').join(' ');
        mainContainer.style.gridTemplateColumns = newTemplate;
    }
    
    // === 7. EVENT LISTENERS AND FINAL CALLS ===

    // JS ä»£ç : äº‹ä»¶ç›‘å¬å™¨éƒ¨åˆ†
    // ã€æ–°å¢ã€‘æ—¥å¿—åˆ‡æ¢é€»è¾‘
    if (dom.toggleLogBtn && dom.backendLogDisplay) {
        dom.toggleLogBtn.addEventListener('click', () => {
            // åˆ‡æ¢ .hidden-log-display ç±»
            dom.backendLogDisplay.classList.toggle('hidden-log-display');
        
            // å¯é€‰ï¼šæ›´æ–°æŒ‰é’®çš„æç¤ºä¿¡æ¯
            const isHidden = dom.backendLogDisplay.classList.contains('hidden-log-display');
            dom.toggleLogBtn.title = isHidden ? 'æ˜¾ç¤ºå®æ—¶æ—¥å¿—' : 'éšè—å®æ—¶æ—¥å¿—';
        
            // å¯é€‰ï¼šæ›´æ”¹æŒ‰é’®çš„æ–‡æœ¬å›¾æ ‡æ¥è¡¨ç¤ºçŠ¶æ€
            dom.toggleLogBtn.textContent = isHidden ? 'ğŸ—’ï¸' : 'ğŸ“œ';
        });
    }

    // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
    document.querySelectorAll('.column-resizer').forEach(resizer => {
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ–‡æœ¬é€‰æ‹©è¡Œä¸º
            isResizing = true;
            currentColIndex = parseInt(e.target.dataset.col, 10) - 1; // 0-based index
            initialX = e.clientX;
            
            // è·å–å½“å‰çš„ fr æ•°ç»„
            initialWidths = getFrArray();
            
            e.target.classList.add('active');
            document.body.style.cursor = 'col-resize';
        });
    });

    // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        // è·å–å®¹å™¨çš„æ€»å®½åº¦å’Œå½“å‰ fr æ€»å’Œ
        const containerWidth = mainContainer.clientWidth;
        const totalFr = initialWidths.reduce((a, b) => a + b, 0);
        
        // è®¡ç®—é¼ æ ‡ç§»åŠ¨çš„è·ç¦»å æ€»å®½åº¦çš„æ¯”ä¾‹
        const dx = e.clientX - initialX;
        const frChange = (dx / containerWidth) * totalFr;
        
        // åªæœ‰å‰ä¸¤åˆ—å¯ä»¥è°ƒæ•´å…¶å³ä¾§è¾¹ç•Œï¼Œç¬¬ä¸‰åˆ—ï¼ˆéŸ³è‰²åº“ï¼‰è°ƒæ•´å·¦ä¾§è¾¹ç•Œ
        const colAIndex = currentColIndex;
        const colBIndex = currentColIndex + 1;
        
        // ç¡®ä¿è¾¹ç•Œä¸è¢«è¶Šè¿‡ (æœ€å°å®½åº¦é™åˆ¶)
        const MIN_FR = 0.1; 

        let newWidths = [...initialWidths];
        
        // è°ƒæ•´ Col A å’Œ Col B çš„å®½åº¦
        let newFrA = initialWidths[colAIndex] + frChange;
        let newFrB = initialWidths[colBIndex] - frChange;

        // æœ€å°å®½åº¦æ£€æŸ¥
        if (newFrA < MIN_FR) {
            newFrA = MIN_FR;
            newFrB = initialWidths[colBIndex] + (initialWidths[colAIndex] - MIN_FR); // ä¿®æ­£ B çš„å®½åº¦
        } else if (newFrB < MIN_FR) {
            newFrB = MIN_FR;
            newFrA = initialWidths[colAIndex] + (initialWidths[colBIndex] - MIN_FR); // ä¿®æ­£ A çš„å®½åº¦
        }
        
        newWidths[colAIndex] = newFrA;
        newWidths[colBIndex] = newFrB;

        updateGridTemplateColumns(newWidths);
    });

    // é¼ æ ‡æŠ¬èµ·äº‹ä»¶
    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.querySelectorAll('.column-resizer.active').forEach(r => r.classList.remove('active'));
            document.body.style.cursor = 'default';
        }
    });
});

</script>

<!-- NEW: Audio Player Modal -->
<div id="audioPlayerModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 600px;">
        <h3 id="playerModalTitle" class="modal-header">æ­£åœ¨æ’­æ”¾...</h3>
        <div class="player-modal-body">
            <div class="player-controls">
                <button id="playerPlayPauseBtn" class="btn btn-primary">âšâš</button>
            </div>
            <div class="player-timeline">
                <span id="playerCurrentTime" class="time-display">00:00</span>
                <input type="range" id="playerProgressBar" class="progress-bar-slider" value="0" step="0.1">
                <span id="playerTotalDuration" class="time-display">00:00</span>
            </div>
        </div>
        <div class="modal-actions">
            <button id="playerModalCloseBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>

<!-- Timbres Management Modal -->
<div id="timbresManageModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 900px; height: 85vh; display: flex; flex-direction: column;">
        <h3 class="modal-header">éŸ³è‰²ç®¡ç†å™¨</h3>
        <div class="manager-container" style="display: flex; flex-grow: 1; gap: 1rem; overflow: hidden;">
            <!-- Left Panel: Categories -->
            <div class="manager-panel" style="flex: 0.8; border: 1px solid var(--border-color); border-radius: 4px; display: flex; flex-direction: column;">
                <div id="manager-category-list" class="scrollable-content" style="padding: 0.5rem;"></div>
                <div class="input-group" style="padding: 0.5rem; border-top: 1px solid var(--border-color); margin-bottom: 0; display:flex; gap: 0.5rem;">
                    <input type="text" id="managerNewCategoryInput" placeholder="è¾“å…¥æ–°åˆ†ç±»å">
                    <button id="managerAddCategoryBtn" class="btn btn-primary" style="flex-shrink: 0;">åˆ›å»º</button>
                </div>
            </div>
            <!-- Right Panel: Timbres in selected category -->
            <div class="manager-panel" style="flex: 2; border: 1px solid var(--border-color); border-radius: 4px; display: flex; flex-direction: column;">
                <h4 id="manager-timbres-title" style="padding: 0.8rem; margin: 0; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">é€‰æ‹©ä¸€ä¸ªåˆ†ç±»</h4>
                <div id="manager-timbres-list" class="scrollable-content info-list"></div>
            </div>
        </div>
        <div class="modal-actions">
            <button id="closeTimbresManageBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>
<!-- NEW: Timbre Conflict Report Modal -->
<div id="timbreConflictModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 700px;">
        <h3 class="modal-header">éŸ³è‰²å†²çªæ£€æµ‹æŠ¥å‘Š</h3>
        <div id="timbreConflictModalBody" class="scrollable-content" style="max-height: 60vh; background-color: var(--surface-color-secondary); padding: 1rem; border-radius: var(--border-radius);">
            <p class="placeholder-text">æœªå‘ç°éŸ³è‰²å†²çªã€‚</p>
            <!-- å†²çªè¯¦æƒ…å°†åŠ¨æ€åŠ è½½åˆ°è¿™é‡Œ -->
        </div>
        <div class="modal-actions" style="margin-top: 1rem;">
            <button id="closeTimbreConflictBtn" class="btn">å…³é—­</button>
        </div>
    </div>
</div>
</body>
</html>